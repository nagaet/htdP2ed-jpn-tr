How to Design Programs, Second Edition.
Matthias Felleisen, Robert Bruce Findler, Matthew Flatt, Shriram Krishnamurthi 著.

---

序文

    システム的なプログラム設計

    DrRacketと教育用言語

    継承される技術

    本書とその構成要素

    相違点

---

多くの職業が何らかの形でプログラミングを必要としています。会計士はスプレッドシートを、音楽家はシンセサイザーを、作家はワープロを、ウェブデザイナーはスタイルシートをプログラムするのです。本書の初版（1995年～2000年）でこの言葉を書いたとき、読者は未来的だと思ったかもしれません。しかし今では、プログラミングは必須のスキルとなり、書籍、オンラインコース、K-12カリキュラムなど、数多くの媒体でこのニーズに対応し、常に人々の仕事の可能性を高めるという目標を掲げているのです。

一般的なプログラミングの講座では、「動くまでいじりなさい」というアプローチを教えています。うまくいくと、生徒たちは「うまくいった！」と叫んで、次に進みます。悲しいことに、この言葉はコンピュータで最も短い嘘であり、多くの人が人生の多くの時間を犠牲にしてきました。これに対し、本書は優れたプログラミングの習慣に焦点を当て、プロのプログラマーと職業プログラマーの両方を対象にしています。

「良いプログラミング」とは、ソフトウェアを作る際に、最初から、すべての段階で、すべての段階において、体系的に考え、計画し、理解するアプローチを意味します。この点を強調するために、私たちは体系的なプログラム設計と体系的に設計されたプログラムという言い方をします。後者では、望まれる機能の根拠が明確に示されていることが重要です。また、良いプログラミングは美的感覚も満足させます。良いプログラムの優雅さは、時間をかけて作られた詩や過ぎ去った時代の白黒写真に匹敵するものです。つまり、プログラミングと優れたプログラミングは、食堂のクレヨン画と美術館の油絵のような違いがあるのです。

いいえ、この本で誰もが名画家になれるわけではありません。しかし、

    誰でもプログラムを設計できる

ということと

    誰もが創造的な設計とともに満足感を経験できる

ということを信じていなかったら、私たちは15年もの歳月をかけてこの本を書き上げなかったでしょう。

実際、私たちはさらに踏み込んで、次のように主張しています。

    ―プログラミングすることではなく―プログラムを設計することは、教養教育の中で数学や言語スキルと同じように位置づけられるべきものである。

デザインを学ぶ学生が二度とプログラムに触れないとしても、普遍的に役立つ問題解決のスキルを身につけ、深く創造的な活動を経験し、新しい形の美学を理解することができるようになるのです。この序文では、「システム的な設計」とは何か、誰がどのような方法で恩恵を受けるのか、そして私たちはどのようにそれを教えていくのかということについて詳しく説明します。


=====
システム的なプログラム設計

プログラムは、ユーザーと呼ばれる人々や他のプログラムと相互作用します。他のプログラムと相互作用する場合、サーバーとクライアントのコンポーネントと呼ばれます。したがって、合理的に完成されたプログラムは、多くの構成要素から構成されています。あるものは入力を処理し、あるものは出力を生成し、あるものはその間のギャップを埋めるのです。私たちは、基本的な構成要素として関数を使うことを選びました。なぜなら、誰もが代数の前に関数に出会い、最も単純なプログラムはまさにそのような関数だからです。重要なのは、どの関数が必要で、それらをどのように接続し、基本的な材料からどのように組み立てるかを発見することです。

この文脈では、「システム的なプログラム設計」は、設計レシピと反復的改良という2つの概念の混合を指します。設計レシピは著者の創り出したものであり、それらは後者の利用を可能にしています。

（我々は、Michael JacksonのCOBOLプログラム作成方法からインスピレーションを受け、Daniel Friedmanとの再帰に関する会話、Robert Harperの型理論、Daniel Jacksonのソフトウェア設計に関する会話も参考にしている）


---
 1. 問題分析からデータ定義へ
　表現しなければならない情報と、選択したプログラミング言語での表現方法を明確にする。データ定義を定式化し、例で説明する。

 2. シグネチャー、目的の声明、ヘッダー
　目的の関数がどのようなデータを消費し、生成するかを述べる。その関数が計算するものは何かという質問に対する簡潔な答を定式化する。署名に沿うようなスタブを定義する。

 3. 関数の例
　関数の目的を説明するための例に取り組む。

 4. 関数のテンプレート
　データ定義を関数のアウトラインに変換する。

 5. 関数の定義
　関数のテンプレートにあるギャップを埋める。目的の声明と例を活用する。

 6. テスト
　例をテストとして明示し、その関数がすべてのテストをパスすることを確認する。そうすることで、間違いを発見することができます。テストはまた、必要なときに他の人が定義を読んで理解するのを助けるという意味で、例を補足するものです。

    図1：機能設計レシピの基本ステップ
---


設計レシピは、プログラム全体と個々の関数の両方に適用されます。本書では、完全なプログラムに関するレシピは、グラフィカルユーザインタフェース（GUI）を持つプログラムに関するものと、バッチプログラムに関するものの2つだけを扱います。一方、関数の設計レシピはさまざまな種類のものを扱います：数値のようなアトミックな形式のデータ、異なる種類のデータの列挙、一定の方法で他のデータを複合化するデータ、有限だが任意に大きなデータなどなど。

関数レベルの設計レシピは、共通の設計プロセスを採用しています。図1は、その6つの重要なステップを示したものです。各ステップのタイトルは期待される結果を示し、「コマンド」は主要な活動を示唆しています。ステップ1で選んだデータ表現について、実世界の情報がどのようにデータとして符号化され、データがどのように情報として解釈されるかを、例を挙げて書き出すことで証明します。ステップ3では、問題解決者は具体的なシナリオを通じて、具体的な例に対して求められる関数が何を計算するものなのかを理解する必要があるとしています。この理解は、ステップ5で関数を定義するときに生かされます。最後に、ステップ6では、例はを自動化されたテストコードに変換され、いくつかのケースで関数が適切に動作することを確認するのに使用されます。実際のデータで関数を実行すると、予想と結果の間に別の不一致が見つかるかもしれません。

(講師へ：生徒にインデックスカードの片面に図1をコピーさせてください。生徒が行き詰まったときは、カードを出してもらい、行き詰まったステップを指すように求めてください）

設計プロセスの各ステップには、本書の6つのパートにわたって紹介されている、ポイントを押さえた質問が用意されています。例えば、関数の例やテンプレートの作成など、ある特定のステップでは、質問はデータ定義に訴えかけることがあります、この足場作りが功を奏するのは、関数定義の完成というクリエイティブなステップを踏むときです。そして、そのときでさえ、ほとんどすべてのケースで助けが得られるのです。

(講師へ： 最も重要な質問は、ステップ4と5の質問です。これらの質問をインデックスカードの裏に自分の言葉で書き出すように指示してください)

この手法の新しさは、初級者向けのプログラムに対して、中級者向けの製品を作ることです。初心者が行き詰まったとき、専門家や講師がその中間的な製品を点検することができる。この検査では、設計過程での一般的な質問が使われる可能性が高いので、初心者が自分で修正するように仕向けることができます。そして、この自己啓発のプロセスこそが、プログラミングとプログラム設計の重要な違いです。


反復的洗練は、問題が複雑で多面的であるという問題に対処するものです。一度にすべてを正しく理解することは不可能に近い。そこで、コンピュータサイエンティストは、物理学から「反復的精密化」という手法を借りて、この設計問題に取り組んでいます。つまり、反復的洗練では、まず本質的でない部分をすべて取り除き、残った核となる問題に対して解決策を見出すことを推奨しているのです。洗練のステップでは、省略された細部の1つを追加し、既存の解決策を可能な限り使用して、拡張された問題を再解決します。この繰り返しで、最終的に完全な解を導き出します。

この意味で、プログラマーはミニ科学者です。科学者は、理想化された世界に対して近似モデルを作り、それについて予測を立てる。そして、予測したことが現実と異なる場合、科学者はその食い違いを減らすためにモデルを修正します。これと同じように、プログラマーは、ある課題を与えられたとき、最初の設計を行い、それをコード化し、実際のユーザーで評価し、プログラムの動作が目的の製品に近くなるまで設計を繰り返し改善します。

本書では、2種類の方法で反復的洗練を紹介します。洗練による設計は、プログラムの設計が複雑になっても有効であるため、本書では、問題がある程度の難易度を得た第4部でその手法を明示的に導入しています。さらに、本書の第1部から第3部にかけては、同じ問題に対して反復的な洗練を行い、より複雑なバリエーションを記述していきます。つまり、核となる問題を選び、それを1つの章で扱い、次の章では新たに導入された概念に合わせた詳細を持つ同様の問題を提起するのです。


=====
DrRacketと教育言語

プログラム設計の学習は、実践的な練習の積み重ねが必要です。ピアノを弾かずにピアノ弾きになる人はいないように、実際にプログラムを作って動作させなければプログラムデザイナーにはなれません。そこで、本書では、プログラムを記述するための言語と、プログラムをワード文書のように編集し、読者がプログラムを実行するためのプログラム開発環境という、ささやかなソフトウェアサポートを提供します。

私たちが出会う多くの人が、「プログラミングができたらいいのに」と言いながら、「どのプログラミング言語を学べばいいのか」と質問してきます。いくつかのプログラミング言語が報道されていることを考えると、この質問は驚くことではありません。初心者を対象としないコースでは、デザインレシピのある市販の言語を使用することも可能でしょう。現在流行しているプログラミング言語でプログラミングを学ぶと、最終的に失敗するように仕向けられることがよくあります。この世界での流行は極めて短命です。Xhのクイックプログラミングの本やコースでは、次の流行りの言語へ移行するための原則を教えることができません。さらに悪いことに、その言語自体が、解決策を表現したり、プログラミングの間違いに対処したりするためのスキルを習得する妨げになることが多いのです。

これに対して、プログラムを設計するための学習は、原理の学習と応用力の習得が主な目的です。理想的なプログラミング言語は、この2つの目標をサポートしなければならないが、市販の産業用言語にはそのようなものはありません。しかし、プログラミング言語では、初心者は言語をあまり知らないうちにミスを犯します。その結果、診断結果は初心者をつまずかせることになります。

私たちは、「BSL（Beginning Student Language）」と呼ばれる独自の教授法を用いて、この問題を解決しています。この言語は、基本的に「代数学」の授業で習う「外国語」です。関数の定義、関数の適用、条件式などの表記が含まれています。また、式はネストすることができます。BSLは、追加のデータ形式とそれらに対する事前定義関数のホストを持つプレ代数であることを説明するとよいでしょう。このように、この言語は非常に小さいので、言語全体から見たエラー診断が、代数以前の知識しかない読者にもまだ可能なのです。

構造設計の原則を習得した学生は、「中級者向け言語」やその他の高度な方言（総称して*SL）に進むことができます。本書では、これらの方言を使って、抽象化、一般再帰の設計原理を学びます。このような一連の教育言語を用いることで、JavaScript、Python、Ruby、Javaなどのプロフェッショナルなプログラミング言語のプログラムを作成するための優れた準備になると確信しています。

(注: 教材となる言語は、私たちがプログラミング言語構築のために作ったプログラミング言語、Racketで実装されています。Racketは研究室から実世界に飛び出し、ゲームから望遠鏡アレイの制御まで、さまざまな場面で選ばれるプログラミング手段になっています。本書はRacket言語の要素を借用した教育用言語ですが、Racketを教えるものではありません。また、本書を読み終えた学生は、簡単にRacketに移行することができます)

プログラミング環境に関しても、言語と同様に悪い選択に迫られます。プロフェッショナルのためのプログラミング環境は、ジャンボジェット機のコックピットのようなものです。プロが使うプログラミング環境は、ジャンボジェット機のコックピットのようなもので、数多くのコントロールやディスプレイがあり、初めてこのようなソフトを起動する人はそれらに圧倒されます。初心者は、2人乗りの単発プロペラ機で基礎練習ができればいいのです。そこで、私たちは初心者のためのプログラミング環境、DrRacketを作りました。

DrRacketは、関数定義を含む定義エリアと、プログラマが定義を参照する可能性のある式の評価を求めることができるインタラクションエリアという、たった2つのシンプルなインタラクティブペインによって、非常に遊び心のあるフィードバック指向の学習をサポートします。ここでは、表計算アプリケーションのように簡単に「もしも」のシナリオを探索することができます。従来の電卓的な例から、画像や単語などのデータを使った計算まで、初めてでもすぐに実験ができます。

DrRacketのようなインタラクティブなプログラム開発環境は、2つの点で学習プロセスを簡素化します。まず、初心者が直接データを操作できるようになります。ファイルやデバイスから入力情報を読み込むための設備が必要ないため、初心者はこれらの仕組みを理解するために貴重な時間を費やす必要がありません。第二に、データとデータ操作を、現実世界からの情報の入力と出力から厳密に分離していることです。DrRacketで作業することで、新しいプログラマーはこの基本的なソフトウェア工学の考え方に、最初から自然に触れることができるのです。


=====
継承される技術

プログラム設計の学習から得られるスキルは、2つの方向に体系的に伝達されます。もちろん、一般的なプログラミングはもちろん、表計算ソフト、シンセサイザー、スタイルシート、ワープロのプログラミングにも応用できます。図1の設計プロセスは、ほとんどのプログラミング言語に適用でき、10行のプログラムにも、1万行のプログラムにも適用できることが分かっています。しかし、いったんこの設計プロセスが自然に身につけば、さまざまな面でその効果が発揮されます。

プログラム設計を学ぶことは、2種類の普遍的に役立つスキルを身につけることでもあります。プログラム設計は、確かに数学、特に（予）代数や幾何学と同じ分析的なスキルを学ぶことができます。しかし、数学とは異なり、プログラムを扱うことは能動的な学習方法です。ソフトウェアを作ることは、すぐにフィードバックが得られるので、探求、実験、自己評価へとつながります。その結果、インタラクティブな製品になる傾向があり、教科書のドリル演習と比較すると、達成感が大幅に向上するアプローチである。

プログラム設計は、数学的な能力を高めるだけでなく、分析的な読解力と記述力を身につけることができます。小さな設計課題であっても、言葉の問題として定式化されます。しっかりとした読解力がなければ、それなりに複雑な問題を解決するプログラムを設計することはできない。逆に言えば、プログラム設計の手法によって、作り手は自分の考えを適切かつ正確な言葉で表現することを強いられる。実際、学生が本当に設計レシピを吸収すれば、何よりも表現力を高めることができる。

この点を説明するために、図1のプロセス説明をもう一度見てみましょう。この図では、設計者は以下のステップを実施する必要があります：

 1. 問題文を分析する（通常、単語問題として記述される）。

 2. そのエッセンスを抽出し、抽象的に表現する。

 3. エッセンスを例示して説明する。

 4. この分析に基づき、アウトラインやプランを作成します。

 5. 期待される結果に関して、結果を評価する。

 6. チェックとテストの失敗を踏まえて、製品を修正する。

それぞれのステップで、分析、正確さ、描写、集中、そして細部への注意を必要とします。経験豊富な起業家、エンジニア、ジャーナリスト、弁護士、科学者、その他の専門家であれば、日々の仕事にこれらのスキルがどれだけ必要であるか説明できるはずです。DrRacketでプログラム設計の練習をすることは、これらのスキルを身につけるための楽しい方法なのです。

同様に、デザインを洗練させることは、コンピュータサイエンスやプログラム作成に限ったことではありません。建築家、作曲家、作家、その他の専門家も同様です。頭の中にあるアイデアを、何とかして具現化する。そして、そのイメージを最大限に反映させるために、紙の上でアイデアを練り上げる。その際、建築物のスタイルや人物の性格、メロディーを表現するために、絵を描いたり、文章を書いたり、ピアノを弾いたりと、デザインレシピを吸収するのと同じような作業を行います。つまり、建築物の様式を表現したり、人物の性格を描写したり、メロディーの一部を構成したりするために、絵を描いたり、文章を書いたり、ピアノを弾いたりするのです。彼らが反復開発プロセスで生産的なのは、基本設計レシピを吸収して、現在の状況に応じてどのレシピを使うかを学んでいるためです。


=====
本書とその構成要素

本書の目的は、未経験の読者にプログラムの体系的な設計を紹介することである。同時に、計算の記号的な見方、つまり、データへのプログラムの適用がどのように機能するかを説明する方法を提示する。大雑把に言えば、小学校の算数や中学校の代数で習うことを一般化した方法です。しかし、恐れることはありません。DrRacketには、このステップバイステップの計算を図示することができる機構（代数ステッパー）が付属しています。

本書は、5つのインターメッツォで区切られた6つのパートからなり、プロローグとエピローグで締めくくられている。本書は、プログラム設計に焦点を当てた主要部分と、プログラミングの仕組みやコンピューティングに関する補足的な概念を紹介するインターメッツォで構成されています。

・プロローグ How to Programは、平易なプログラミングを簡単に紹介するものです。この本では、*SLで簡単なアニメーションを書く方法を説明します。この本を読み終えると、どんな初心者でも、力が湧いてくると同時に、圧倒されてしまうに違いない。そこで、最後のノートでは、なぜプレーンプログラミングがいけないのか、そして、プログラム設計への体系的で段階的なアプローチが、初心者プログラマーが通常経験する恐怖感をどのように解消するのかを説明しています。これで、本書の核となる部分の舞台は整った。

・I Fixed-Size Dataは、システム設計の最も基本的な概念を、簡単な例を使って説明します。中心的な考え方は，設計者は通常，プログラムがどのようなデータを消費し，どのようなデータを生成するかについて，大まかな知識を持っているということです．従って、設計のための系統的なアプローチは、プログラムに出入りするデータの記述から可能な限り多くのヒントを抽出しなければならない。本編では、数字や画像などの原子データから始まり、区間、列挙、項目別、構造、それらの組み合わせなど、データの新しい記述方法を徐々に紹介していくことで、物事をシンプルにしていく。

・Intermezzo 1: Beginning Student Languageでは、教える言語を語彙、文法、意味など、完全に詳しく説明します。コンピュータ科学者は、これらを構文と意味論と呼んでいます。プログラム設計者は、この計算モデルを用いて、作成したプログラムを実行したときの計算内容を予測したり、エラー診断の分析を行ったりします。

・II Arbitrarily Large DataはFixed-Size Dataを拡張し、最も興味深く有用なデータ形式である任意に大きな複合データを表現する手段を提供します。プログラマは情報を表現するために固定サイズデータからデータの種類をネストすることができますが、ネストは常に一定の深さと幅を持ちます。このパートでは、そこから微妙な一般化によって、任意の大きさのデータを表現する方法を紹介する。そして、このようなデータを処理するプログラムの体系的な設計に焦点を当てる。

・Intermezzo 2: Quote, Unquoteでは、大きなデータを書き留めるための簡潔で強力な表記法、quotationとanti-quotationを紹介します。

・III 抽象化とは、Arbitrarily Large Dataから得られる多くの関数が似ていることを認めることである。どんなプログラミング言語でも、プログラマーに似ているコードの断片を作ることを強いるべきではありません。逆に言えば、優れたプログラミング言語には、そのような類似性を排除する方法が備わっているのです。コンピュータ科学者は、類似性を排除するステップとその結果を抽象化と呼び、抽象化によってプログラマの生産性が大幅に向上することを知っています。そこで、このパートでは、抽象化を作成し、利用するための設計レシピを紹介します。

・Intermezzo 3: Scope and Abstractionは2つの役割を担っている。ひとつは、レキシカルスコープという概念で、プログラミング言語が、プログラマがコードを調べればわかるような定義と、ある名前の出現を結びつけているという考え方である。一方では、いわゆるforループを含む抽象化のための追加的なメカニズムを持つライブラリの説明をしている。

・IV Intertwined DataはArbitrarily Large Dataを一般化し、デザインコンセプトのカタログに反復的洗練のアイデアを明示的に導入しています。

・Intermezzo 4: The Nature of Numbersでは、すべてのプログラミング言語において、なぜ小数点以下の数字が奇妙な動きをするのかを説明し、解説しています。プログラマーを目指す人は、これらの基本的な事実を知っておく必要があります。

・V Generative Recursionは、新しい設計原理を追加したものである。構造的な設計や抽象化は、プログラマが遭遇するほとんどの問題に対して有効であるが、時として、十分な性能を発揮できないプログラムを導くことがある。つまり、構造的に設計されたプログラムは、求める答えを計算するのに必要な時間やエネルギーが多すぎる場合がある。そこで、計算機科学者は、構造的に設計されたプログラムを、問題領域に対するアドホックな洞察力を利用したプログラムに置き換えている。本書では、そのようなプログラムを設計する方法を紹介する。

・Intermezzo 5: The Cost of Computationは、Generative Recursionの例を用いて、コンピュータ科学者がパフォーマンスについてどのように考えているかを説明しています。

・VI アキュムレータは、設計者の道具箱に最後のトリックを追加します：アキュムレータ。大雑把に言うと、アキュムレータは関数に「メモリ」を追加します。メモリを追加することで、本書の最初の4つのパートで構造的に設計された関数の性能を大幅に向上させることができます。Generative Recursion のアドホックなプログラムでは、アキュムレータは答えを見つけるか見つけないかの違いをもたらすことができます。

・エピローグ。Moving On」は、評価であると同時に、次を見据えたものです。


---


  https://htdp.org/2023-8-14/Book/part_preface.html#%28counter._%28figure._fig~3adependence%29%29


    図2：部品とインターメッツォの依存関係
---


独立した読者は、最初のページから最後のページまで、この本全体を読み通す必要があります。私たちが「やり通す」と言うのは、読者はすべての練習問題を解かなければならない、あるいは少なくとも解き方を知らなければならない、というのが本当の意味だからです。

同様に、講師もプロローグからエピローグまで、できるだけ多くの要素をカバーする必要があります。私たちの指導経験から、これは可能であると思います。通常、私たちは、読者が学期中に大規模で楽しいプログラムを作成するようにコースを構成しています。しかし、状況によっては大幅な削減を余儀なくされることもあり、また、講師の好みによって本書の使い方が若干異なることも理解しています。

図2は、本書の要素から選びたい人のためのナビゲーションチャートです。この図は依存関係グラフである。ある要素から別の要素への実線の矢印は、例えば、第II部では第I部の理解が必要であるなど、必須の順序を示唆している。一方、点線の矢印は、例えば、プロローグの理解は残りの部分を読み進めるのに必要ないなど、ほとんど示唆に富んでいる。

この表をもとに、実現可能な3つの道筋を紹介します。

    高校生の指導者は、ゲームなどの小さなプロジェクトを含め、パートIとIIを（できるだけ）カバーしたいと思うかもしれません。

    クオーター制(訳注: 1年間を４つの学期に分けて授業をするシステム) の大学の先生は、Fixed-Size Data, Arbitrarily Large Data, Abstraction, Generative Recursionに加え、*SLとスコープに関するインターメッツォに注目するとよいでしょう。

    セメスター制(訳注: 半年を1学期として1科目の単位を取得するシステム) の大学の講師は、設計における性能のトレードオフをできるだけ早く議論することを好むかもしれません。この場合、Fixed-Size DataとArbitrarily Large Dataをカバーし、その後Generative Recursionに依存しないAccumulatorsからアキュムレータの資料を取り上げるとよいでしょう。その時点で、Intermezzo 5: The Cost of Computationを取り上げ、この本の残りの部分をこの角度から勉強することが可能である。

サンプルトピックの繰り返し この本では、特定の演習やサンプルトピックを何度も繰り返しています。例えば，仮想ペットはFixed-Size Dataの至る所に出てきますし，Arbitrarily Large Dataにも出てきます．同様に，Fixed-Size DataとArbitrarily Large Dataの両方で，対話型テキストエディタを実装するための別のアプローチを取り上げています．グラフはGenerative Recursionで現れ、すぐにAccumulatorsで再び現れる。これらの繰り返しの目的は、反復的な洗練を動機づけることと、裏口からそれを導入することである。講師の方々には、このようなテーマ別の演習を課したり、独自にこのような演習を作成したりすることを強くお勧めします。



=====

相違点

この『How to Design Programs』の第2版は、第1版と大きく異なる点がいくつかあります。

1. プログラム全体を設計することと、プログラムを構成する機能を設計することの違いを明確に認識した。具体的には、イベントドリブン（主にGUI、ネットワーク）プログラムとバッチプログラムの2種類を取り上げる。

2. プログラムの設計は、トップダウンの計画段階とボトムアップの構築段階を経て進行する。我々は、ライブラリへのインタフェースがどのようにプログラム要素の形状を決定するのかを明示的に示す。特に、プログラム設計の最初のフェーズでは、機能のウィッシュリストが作成される。第1版でもウィッシュリストの概念は存在したが、第2版ではこれを明示的な設計要素として扱う。

3. ウィッシュリストの項目を実現するためには、大きく分けて6つのパートで構成される機能設計のレシピが必要です。

4. 構造設計の重要な要素は、他の関数を構成する関数の定義である。この構成による設計は、特にバッチプログラムの世界では有効である。この点については、生成再帰と同様、Kathi Fislerが注意を喚起してくれたことに感謝する。このアプローチには、ある関数で中間データを生成し、この中間結果を第2の関数で処理することで全体の設計が単純化されるという、特にeureka！の認識が必要である。また、このアプローチには「欲しいものリスト」が必要ですが、この「欲しいものリスト」を作成するには、中間データの定義について洞察することが必要です。この版では、構成による設計に関する明示的な演習を数多く織り込んでいる。

5. テストは常に私たちの設計思想の一部でしたが、教育言語とDrRacketがそれを適切にサポートし始めたのは、私たちが初版をリリースした直後の2002年のことでした。この新版は、このテスティングサポートに大きく依存しています。

6. この版では、命令型プログラムの設計を落としています。旧版の章は引き続きオンラインで入手可能です。この資料の翻案は、本シリーズの第2巻「コンポーネントの設計法」に掲載される予定です。

7. この本の例題と練習問題では、新しいティーチパックを採用しています。これらのライブラリはrequireでリンクするのが好ましいのですが、DrRacketのメニューからティーチパックを追加することも可能です。

8. 最後に、この第2版は、用語と表記法のいくつかの点で第1版と異なっている。

    最後の3つの違いは、リストの引用を大幅に改善するものです。


=====

初版からの謝辞

特に、4人の方々に感謝したい。Robert Corky Cartwrightは、Rice大学入門コースの前身を筆者と共同開発しました。 Daniel P. Friedmanは、1984年に筆者にThe Little LISPer (MIT Press) の書き直しを依頼し、それがこのプロジェクトの始まりだったからです。

この本の開発には、この本を講座で使用したり、初期の草稿に詳細なコメントをくれたりした多くの友人や同僚が役に立ちました。彼らの協力と忍耐に感謝する。Ian Barland, John Clements, Bruce Duba, Mike Ernst, Kathi Fisler, Daniel P. Friedman, John Greiner, Geraldine Morin, John Stone, and Valdemar Tamez.です。

ライス大学の Comp 210 の学生十数世代がこのテキストの初期ドラフトを使用し、さまざまな方法で改良に貢献しました。さらに、私たちのTeachScheme！ワークショップの多数の参加者が、初期のドラフトを教室で使用しました。多くの人がコメントや提案を送ってくれました。その代表として、以下の積極的な貢献者を挙げることができる。バーバラ・アドラー氏、スティーブン・ブロック氏、カレン・ブラス氏、ジャック・クレイ氏、リチャード・クレメンス氏、カイル・ジレット氏、マーヴィン・ヘルナンデス氏、マイケル・ハント氏、カレン・ノース氏、ジェーミー・レイモンド氏、ロバート・リード氏。Christopher Felleisen氏は、父親と一緒に本の最初の数パートを辛抱強く読み、若い学生の意見に直接理解を示してくれました。Hrvoje Blazevic氏（当時LPG/C Harrietteの船長として航海中）、Joe Zachary氏（ユタ大学）、Daniel P. Friedman氏（インディアナ大学）は、初版に多数の誤植を発見してくれ、現在は修正されています。皆様に感謝いたします。

最後にMatthiasは、Helgaの長年の忍耐と、無気力な夫と父親のために家を作ってくれたことに感謝の意を表します。ロビーは、黄興惠のサポートと励ましに感謝している。彼女なしには、何も成し遂げることはできなかっただろう。マシューは、ウェン・ユアンの絶え間ないサポートと不朽の名曲に感謝しています。Shriramは、Kathi Fislerのサポート、忍耐、ダジャレ、そしてこのプロジェクトに参加してくれたことに感謝しています。


=====

謝辞

2001年に引き続き、John ClementsにはDrRacketの代数的ステッパーの設計、検証、実装、保守をお願いしています。Johnは20年近くもこの作業を続けており、ステッパーは説明や指導に欠かせないツールとなっています。

過去数年にわたり、何人かの同僚が様々なドラフトについてコメントし、改善点を提案してくれました。これらの方々との心のこもった会話や交流に感謝します。

    Kathi Fisler（WPIおよびBrown大学）、Gregor Kiczales（ブリティッシュコロンビア大学）、Prabhakar Ragde（ウォータールー大学）、Norman Ramsey（タフツ大学）の各氏。


長年にわたり、何千人もの先生やインストラクターが私たちのさまざまなワークショップに参加し、多くの方から貴重なご意見をいただきました。しかし、Dan Anderson、Stephen Bloch、Jack Clay、Nadeem Abdul Hamid、Viera Proulxは特に傑出しており、この版の制作において彼らの役割を称えたいと考えています。

Guillaume Marceau は、Kathi FislerとShriramと協力して、何ヶ月もかけてDrRacketのエラーメッセージを研究し、改良してくれました。彼の素晴らしい仕事に感謝しています。

Celeste Hollenbeck は、これまでで一番素晴らしい朗読者です。彼女は散文を理解するまで、飽きることなく背中を押してくれました。あるセクションがその論文を支え、その構成が一致し、その文章がつながるまで、彼女は決して止めないのです。本当にありがとうございました。

また、以下の方々にも感謝します: Ennas Abdussalam, Mark Aldrich, Mehmet Akif Akkus, Anisa Anuar, Christoph Badura, Franco Barbeite, Saad Bashir, Aaron Bauman, Suzanne Becker, Michael Bausch, Steven Belknap, Stephen Bloch, Elijah Botkin, Joseph Bogart, Sergey Bronnikov, William Brown, Tomas Cabrera, Xuyuqun C, Colin Caine, Anthony Carrico, Rodolfo Carvalho, Estevo Castro, Maria Chacon, Stephen Chang, David Chatman, Burleigh Chariton, Ni ChenYu, Tung Cheng, Nelson Chiu, Tomasz Chrzczonowicz, Jack Clay, Richard Cleis, John Clements, Scott Crymble, Pierce Darragh, Jonas Decraecker, Qu Dongfang, Dominique Dijkhuizen, Mark Engelberg, Thomas Evans, Andrew Fallows, Jiankun Fan, Christopher Felleisen, Sebastian Felleisen, Vladimir Gaji?, Xin Gao, Adrian German, Jack Gitelson, Kyle Gillette, Jonathan Gordon, Scott Greene, Ben Greenman, Ryan Golbeck, Josh Grams, Grigorios, Jane Griscti, Alberto E. F. Guerrero, Tyler Hammond, Nan Halberg, Li Junsong, Nadeem Abdul Hamid, Jeremy Hanlon, Tony Henk, Craig Holbrook, Connor Hetzler, Benjamin Hosseinzahl, Wayne Iba, John Jackaman, Jordan Johnson, Blake Johnson, Erwin Junge, Marc Kaufmann, Cole Kendrick, Gregor Kiczales, Eugene Kohlbecker, Jaroslaw Kolosowski, Caitlin Kramer, Roman Kunin, Jackson Lawler, Devon LePage, Ben Lerner, Shicheng Li, Chen Lj, Ed Maphis, YuSheng Mei, Andres Meza, Saad Mhmood, Elena Machkasova, Jay Martin, Alexander Martinez, Yury Mashika, Jay McCarthy, James McDonell, Mike McHugh, Wade McReynolds, David Moses, Ann E. Moskol, Naveen M V, Scott Newson, , ?t?pan N?mec, Paul Ojanen, Prof. Robert Ordonez, Laurent Orseau, Klaus Ostermann, Alanna Pasco, Sinan Pehlivanoglu, Eric Parker, Nico Niemikko, David Porter, Nick Pleatsikas, Prathyush Pramod, Alok Rai, Norman Ramsey, Krishnan Ravikumar, Jacob Rubin, Ilnar Salimzianov, Luis Sanjuan, Brian Schack, Ryan “Havvy” Scheel, Lisa Scheuing, Willi Schiegel, Vinit Shah, Nick Shelley, Edward Shen, Tubo Shi, Hyeyoung Shin, Atharva Shukla, Matthew Singer, Michael Siegel, Stephen Siegel, Milton Silva, Kartik Singhal, Joe Snikeris, Marc Smith, Matthijs Smith, Dave Smylie, Woncheol Song, Vincent St-Amour, Reed Stevens, William Stevenson, Kevin Sullivan, Yuriy Syrovetskiy, Asumu Takikawa, Eric Tanter, Sam Tobin-Hochstadt, Thanos Tsouanas, Aaron Tsay, Mariska Twaalfhoven, Bor Gonzalez Usach, Ricardo Ruy Valle-mena, Manuel del Valle, David Van Horn, Nick Vaughn, Simeon Veldstra, Andre Venter, Jan Vitek, Marco Villotta, Jiri Vlasak, Mitch Wand, Yuxu (Ewen) Wang, Michael Wijaya, G. Clifford Williams, Ewan Whittaker-Walker, Julia Wlochowski, Roelof Wobben, J.T. Wright, Mardin Yadegar, Huang Yichao, Yuwang Yin, Andrew Zipperer, Ari Zvi には、この第2版のドラフトに対してコメントをしていただいた。

htdp.orgのHTMLレイアウトは Matthew Butterick が担当し、オンラインドキュメントのためにこれらのスタイルを作成しました。

最後に、この『How to Design Programs』第2版をウェブ上で展開することを許可してくれたMIT Pressの編集者、Ada BrunsteinとMarie Lufkin Leeに感謝します。また、最終的な制作プロセスを管理してくださったWestchester Publishing ServicesのMITfs Christine Bridget SavageとJohn Hoeyに感謝します。John Donohue, Jennifer Robertson, Mark Woodworthは原稿のコピー編集で素晴らしい仕事をしてくれました。

