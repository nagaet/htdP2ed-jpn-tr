インテルメッツォ4：数の本質

    固定サイズの数値演算

    オーバーフロー

    アンダーフロー

    *SL番号


数に関して言えば、プログラミング言語は、基礎となるハードウェアと真の数学との間のギャップを調停する。一般的なコンピュータのハードウェアは、ビット、バイト、ワードと呼ばれる固定サイズのデータの塊で数を表現し、その塊だけを処理するプロセッサが搭載されている。紙と鉛筆で計算する場合、何桁の数字を処理するかは気にしないが、原理的には1桁、10桁、1万桁の数字を処理することができる。したがって、プログラミング言語がハードウェアの数字を使えば、できるだけ効率よく計算できる。しかし、数学的な数字にこだわると、ハードウェアのデータに変換しなければならず、その変換に時間がかかる。そのため、プログラミング言語の開発者の多くは、ハードウェアベースの選択をする。

このインターメッツォでは、データ表現の練習として、数値のハードウェア表現について説明する。具体的には、第1章で具体的な固定サイズの数値データ表現を紹介し、この表現に数値をどのようにマッピングするかを議論し、その数値でどのように計算が行われるかを示唆する。第2節と第3節では、このデータ表現の最も基本的な問題である算術のオーバーフローとアンダーフローをそれぞれ説明する。最後の章では、教育用言語における算術計算がどのように行われるか、その数体系が今日のプログラミング言語のほとんどに見られるものを一般化したものであることを概説する。最後の練習問題は、プログラムが数値計算をするときに、いかに悪いことが起こるかを示す。


-------------------------------------------------------------------------------------------------
固定長の数値演算

仮に4桁で数字を表すことができるとします。自然数を表現する場合、表現可能な範囲の1つは[0,10000]です。実数の場合、0と1の間に1万個の分数、0と1の間に5千個、1と2の間に5千個、といった具合に選ぶことができる。いずれの場合も、4桁の数字で表現できるのは、選んだ区間に対して最大1万個であり、この区間の数直線には無限の数字が含まれる。

ハードウェアの数字表記には、いわゆる科学的記数法を用いるのが一般的で、数字は2つの部分で表現される。

    1. 基数である仮数、および

    2. 指数、それは10を基準にした係数を決定するために使用されます?? 。

数式で表すと、次のように数字を書きます。

    m ・ 10^e

ここで、mは仮数、eは指数である。例えば、この方式で1200を表現すると、次のようになります。

    120・10^1

もう一つは

    12・10^2

一般に、数値はこの表現でいくつかの等価物を持つ。

また、負の指数を使うこともできます。これは、指数の符号という余分なデータを一つ代償に、分数を足すもの?? です。例えば

    1・10^(-2)

は次を意味します。

    1/100

この問題で仮数-指数表記を使うには、仮数を何桁、指数を何桁で表すかを決めなければなりません。ここでは、仮数を2桁、指数を1桁としていますが、他の選択肢もあります。このように決めても、0は次のように表せます：

    0・10^0

表現できる最大数は

    99・10^99

となり、99の後に99の0が続く。負の指数を使うと、分数は次のようになります??。

    01・10^(-99)

という、表現可能な最小の数字があります。要するに、4桁（と符号）の科学的記数法を使えば、膨大な数の表現と分数の表現が可能になるわけですが、この改良には問題があります。

; N Number N -> Inex
; 引数をチェックした後にInexのインスタンスを作る
(define (create-inex m s e)
  (cond
    [(and (<= 0 m 99) (<= 0 e 99) (or (= s 1) (= s -1)))
     (make-inex m s e)]
    [else (error "bad values given")]))
             
; Inex -> Number
; 非正規値を数値に変換する。
(define (inex->number an-inex)
  (* (inex-mantissa an-inex)
     (expt
       10 (* (inex-sign an-inex) (inex-exponent an-inex)))))

    図143：不正確な表現に対応する関数

この問題を理解するためには，ISL+によるデータ表現と実験によって，これらの選択を具体化するのが最も良い方法である．固定サイズの数を3つのフィールドを持つ構造体で表現してみよう。

    (define-struct inex [mantissa sign exponent])
    ; Inexは構造体である。
    (make-inex N99 S N99) 
    ; Sは以下のいずれかである。
    ; − -1
    ; −　1
    ; N99は0から99の間のNである (inclusive)。

Inexのフィールドに対する条件は非常に厳しいので、この構造体型の定義をインスタンス化する関数create-inexを定義する（図143参照）。また、この図には、Inexを上記の式で数値に変換する関数、inex->numberも定義されています。




上の例 1200をデータ表現に置き換えてみよう。

    (create-inex 12 1 2)

ただし、1200 を 120・10^1 として表現することは、われわれのInexのデータ定義に違反しています。

  > (create-inex 120 1 1)
  bad values given


しかし、他の数については、2つのInexに相当するものを見つけることができる。一例として5e-19がある。

  > (create-inex 50 -1 20)
  (make-inex 50 -1 20)

  > (create-inex 5 -1 19)
  (make-inex 5 -1 19)

この2つの数値の等価性を確認するために、inex->numberを使用します。

また、create-inexを使えば、表現可能な数値の範囲を簡単に区切ることができ、実際には多くのアプリケーションで非常に小さな範囲になります。

    (define MAX-POSITIVE (create-inex 99 1 99))
    (define MIN-POSITIVE (create-inex 1 -1 99))

0からMAX-POSITIVEの間の実数のうち、どれがInexに変換できるかが問題である。特に、

  10^(-99)

より小さい正の数は同等のInexがない。同様に、表現にも隙間がある。例えば、

    (create-inex 12 1 2)

の直後の後者(successor)は

    (create-inex 13 1 2)

です。最初のInexは1200を表し、2番目のInexは1300を表します。中間の数、例えば1240は、どちらか一方でしか表現できないが、他のInexは意味をなさない。標準的な選択は、表現可能な最も近い数字に丸めることであり、これがコンピュータ科学者の言う「不正確な数字」の意味である。つまり、選択されたデータ表現によって、数学的な数字を近似値に対応させることを余儀なくされるのだ。

最後に、Inex構造に対する算術演算も考えなければならない。同じ指数(exponent)を持つ2つのInex表現の足し算は、2つの仮数(mantissa)を足すことを意味する。

  (inex+ (create-inex 1 1 0) (create-inex 2 1 0))
  ==
  (create-inex 3 1 0)

数学の表記に置き換えると、次のようになります。

    1・10^0
  + 2・10^0
 -----------
    3・10^0

2つのマンティサの足し算で桁数が多くなりすぎる場合、Inexで最も近い隣の数を使うことになるのです。55・10^0をそれ自身に足すことを考える。数学的には次のようになる。

    110・10^0

しかし、この数字を選んだ表現に単純に置き換えることはできない。なぜなら、110 > 99 だからだ。正しい対処法は結果を

    11・10^1

として表現することです。

あるいは、ISL+に換算すると、以下のようにinex+ が計算されることを保証しなければならない。

  (inex+ (create-inex 55 1 0) (create-inex 55 1 0))
  ==
  (create-inex 11 1 1)

より一般的には、結果の仮数が大きすぎる場合、それを10で割って指数を1増やす必要があります。

時々、結果には表現できるよりも大きい桁の仮数を含まれています。そのような場合、inex+はInexの世界で最も近い等価値に丸めなければなりません。例えば

  (inex+ (create-inex 56 1 0) (create-inex 56 1 0))
  ==
  (create-inex 11 1 1)

正確な計算と比較してみてください。

    56・10^0 + 56・10^0 = (56 + 56)・10^0 = 112・10^0

この結果は仮数の桁が大きすぎるため、結果の仮数を10で整数除算することで近似的な結果が得られます。

    11・10^1

これは、Inexの計算の多くの近似の例です。

また、Inex数の乗算もできる。次のことを思い出してください。

    (a・10^n)・(b・10^m)
  = (a・b)・10^n・10^m
  = (a・b)・10^(n + m)

こうして得られるのは

    2・10^(+4)・8・10^(+10) = 16・10^(+14)

または、ISL+表記で:

  (inex* (create-inex 2 1 4) (create-inex 8 1 10))
  ==
  (create-inex 16 1 14)

足し算と同様、物事は単純ではありません。結果の仮数の桁数が大きすぎる場合、inex*は指数を増加させなければなりません。

  (inex* (create-inex 20 1 1) (create-inex  5 1 4))
  ==
  (create-inex 10 1 6)

また、Inex+と同様に、真の仮数がInexで正確に等価な値を持たない場合は、Inex* は近似値を導入します:

  (inex* (create-inex 27 -1 1) (create-inex  7 1 4))
  ==
  (create-inex 19 1 4)


Exercise 412. 
 inex+を設計しなさい。この関数は、同じ指数を持つ2つのInex表現を足し算します。この関数は、指数を増加させる入力を処理できなければならない。さらに、この関数は結果が範囲外の場合、エラーチェックのために create-inex に依存するのではなく、それ自身のエラーを通知しなければならない。

課題 指数が1だけ異なる入力を扱えるように、unix+を拡張する。

(check-expect
  (inex+ (create-inex 1 1 0) (create-inex 1 -1 1))
  (create-inex 11 -1 1))

以下のサブセクションを読まずに、これより大きなクラスの入力を扱おうとしないでください。■


Exercise 413. 
inex* を設計せよ。この関数は 2 つの Inex 表現の数値を乗算し、出力の指数をさらに増加させる入力を含む。inex+ のように、それは結果が範囲外の場合、エラーチェックを行うために create-inex に依存するのではなく、それ自身のエラーを通知しなければならない。■


Exercise 414. 
このセクションで説明したように、データ表現にギャップがあると、数値をInexにマッピングする際に丸め誤差が発生する。問題は、このような丸め誤差が計算中に蓄積されることである。

#i1/185をn個加算する関数、addを設計せよ。

あなたの例では0と1を使ってください；後者では許容誤差を0.0001とする。(← ??? 意味不明)

(add 185)の結果はどうなりますか？あなたは何を期待しますか？その結果に大きな数を掛けるとどうなりますか？

関数subを設計しなさい。この関数は、引数が 0 になるまで 1/185 を引くことができる回数を数えるものである。期待される結果は何ですか？(sub 1) と (sub #i1.0) の結果はどうなりますか? 2番目のケースでは何が起こりますか? それはなぜでしょうか？ ■


-------------------------------------------------------------------------------------------------
オーバーフロー

科学的記数法は、固定サイズのデータの塊で表現できる数値の範囲を広げるが、それでも有限である。中には、大きすぎて固定サイズの数値表現に収まらない数字もある。例えば

    99・10^500

は、指数500が2桁に収まらず、仮数も合法的に可能な限り大きいため、表現できない。

Inexにとって大きすぎる数は、計算中に発生することがあります。例えば、表現できる2つの数を足すと、表現できない数になることがある:

  (inex+ (create-inex 50 1 99) (create-inex 50 1 99))
  ==
  (create-inex 100 1 99)

となり、データ定義に違反する。Inexの演算で、表現できないほど大きな数値が出ることを（算術）オーバーフローと言います。

オーバーフローが発生した場合、言語実装によってはエラーを通知して計算を停止させます。また、無限大と呼ばれる記号値を指定して、そのような数値を表現し、算術演算でそれを伝播させるものもあります。

注 仮数部に符号フィールドがある場合、2つの負の数を足すと、どちらとも表現できないほど負の数になることがある。これを負方向のオーバーフローという。注終了


Exercise 415. 

ISL+はオーバーフローに対処するために+inf.0を使用する。次が成立するような整数nを求めよ。

 (expt #i10.0 n) は不正確な数であるのに対し、（expt #i10. (+ n 1)) は +inf.0 で近似されます。
(ヒント. n を計算する関数を設計してください。)■


-------------------------------------------------------------------------------------------------
アンダーフロー

反対に、Inexで表現できない小さな数字もあります。例えば、10^(-500)は0ではありませんが、私たちが表現できる最も小さな0でない数よりも小さい数です。2つの小さな数を掛け合わせたとき、その結果がInexにとって小さすぎる場合、（算術）アンダーフローが発生します。

  (inex* (create-inex 1 -1 10) (create-inex 1 -1 99))
  ==
  (create-inex 1 -1 109)

であり、エラーを通知する。

アンダーフローが発生すると、ある言語実装ではエラーを通知し、他の言語実装では0を使用して結果を近似します。0を使用してアンダーフローを近似することは、Inexで数値の近似表現を選択することとは質的に異なります。具体的には、1250を(create-inex 12 1 2)で近似すると仮数から有効数字が減りますが、結果は常に表現される数の10%以内となります。しかし、アンダーフローを近似すると、仮数全体を削除することになり、結果は真の結果の予測可能なパーセンテージの範囲に収まらないことになります。

Exercise 416. 
ISL+ はアンダーフローを近似するために #i0.0 を使用する。(expt #i10.0 n) が依然として非正確な ISL+ 数であり，かつ (expt #i10. (- n 1)) が 0 で近似されるような最小の整数 n を決定せよ．
(ヒント n を計算する関数を使用します。この関数と練習問題 415 の解答を抽象化して考えてみてください。)■


-------------------------------------------------------------------------------------------------
*SL数

ほとんどのプログラミング言語は、近似的な数値表現しかサポートしていません。非正規の実数表現には、float、double、extflonumなどの種類があります。典型的な言語では、整数を実行するハードウェアのチャンクの大きさに関係する区間に制限しています。実数の表現は、前節のスケッチに大まかに基づいているが、Inexが使う4桁よりも大きなチャンクと、2をベースとした数体系からの桁を用いている。

教育用の言語は正確な数と不正確な数の両方をサポートする。（それらの言語の）整数と有理数は、コンピュータの全メモリの絶対サイズによってのみ制限される、任意の大きさと精度を持つ。これらの数に対する計算では、有理数がサポートされているデータチャンクに収まっている限り、我々の教育用言語はそのハードウェアを使用し、この範囲外の数に対しては自動的に別の表現と別のバージョンの算術演算に切り替わります。その実数には、正確なものと不正確なものの2種類がある。正確な数は実数を本当に表し、不正確な数は前節の精神に則って実数を近似する。算術演算は可能な限り正確さを維持し、必要な場合は不正確な結果を出します。このように、sqrtは正確数4が与えられると正確数2を生成し、不正確数 #i4.0の入力に対しては不正確数 #i2.0を生成します。最後に、教育用プログラム中の数値定数は、#iが前に付いていない限り、正確な有理数として理解されます。

また、プレーンなRacket はすべての十進数を不正確数として解釈します；そしてまた、プレーンなRacketは正確か不正確かにかかわらず、すべての実数を十進数として表示します。つまり、このような数値はすべて、真の数値の不正確な近似値である可能性が高いため、危険であるということです。プログラマは、数値定数の前に#eを付けることで、Racketがドットの付いた数値を正確なものとして解釈するように強制することができます。

ここで、このような不正確な数値を使用した場合、プログラムの結果が真の結果とどれだけ違ってくるのだろうかと思うかもしれません。この問題は、初期のコンピュータ科学者がよく悩んだ問題で、過去数十年の研究により数値解析と呼ばれる独立した分野が生まれました。過去にコンピュータ・サイエンティストはもちろん、コンピュータやソフトウェアを使うすべての人が、数値解析の存在と、数値プログラムの動作に関する基本的な洞察について知っておく必要があります。まずは、以下の練習問題で、いかに悪いことが起こるかを体験してください。不正確数の問題点を見失わないように、これらの問題に取り組んでください。

Racketを使ったわかりやすい入門書として、Neil TorontoとJay McCarthyによるエラー解析に関する記事、Practically Accurate Floating-Point Mathを読んでみてください。また、YouTubeで公開されているNeil Torontofs RacketCon 2011の講演「Debugging Floating-Point Math in Racket」も面白いですよ。

練習問題417
Racket と ISL+ で (expt 1.001 1e-12) を評価しなさい．あなたが見たものを説明しなさい。■


練習問題418
expt を使わずに my-expt を設計せよ。この関数は、最初に与えられた数値を2番目の数値の自然数乗にする。この関数を用いて，次の実験を行いなさい．

    (define inex (+ 1 #i1e-12))
    (define exac (+ 1 1e-12))

を定義エリアに追加してください。(my-expt inex 30)とは何でしょうか？また、(my-expt exac 30)はどうでしょうか？どちらの答えがより有用でしょうか？■


(define JANUS
  (list 31.0
        #i2e+34
        #i-1.2345678901235e+80
        2749.0
        -2939234.0
        #i-2e+33
        #i3.2e+270
        17.0
        #i-2.4e+270
        #i4.2344294738446e+170
        1.0
        #i-8e+269
        0.0
        99.0))
    図144：ヤヌスの顔のような不正確な数字の羅列


練習問題419
桁数が大きく異なる2つの不正確な数を足すと、結果として大きい方が戻ってくることがあります。例えば、有効数字が15桁しかない数体系では、10^16以上の差がある数を足し算するときに問題にぶつかる。

    1.0・10^16 + 1 = 1.0000000000000001・10^16

ですが、最も近い表現可能な答は 10^16です。

一見すると、この近似式はあまり悪いようには見えません。10^16（1000000000000）分の1であれば、十分に真の値に近いと言えます。しかし、このような問題が積み重なると、大きな問題になる。図144の数字の羅列を考え、これらの式の値を求めよ。

    (sum JANUS)

    (sum (reverse JANUS))

    (sum (sort JANUS <))

sumがリストの数字を左から右へ足すと仮定して、これらの式が何を計算するのか説明しなさい。また、その結果をどう考えるか。

不正確な計算における一般的な助言として、プログラマーは足し算を最小の数から始めるように言われる。大きな数字と小さな数字の2つを足せば大きな数字が得られるかもしれないが、小さな数字を先に足せば結果を変えるような大きな数字が生まれてしまうかもしれない。

    > (expt 2 #i53.0)
    #i9007199254740992.0
    > (sum (list #i1.0 (expt 2 #i53.0)))
    #i9007199254740992.0
    > (sum (list #i1.0 #i1.0 (expt 2 #i53.0)))
    #i9007199254740994.0

このトリックはうまくいかないかもしれません。上記のJANUSのインタラクションを参照してください。

ISL+のような言語では、数値を正確な有理数に変換し、それに対して正確な演算を行い、その結果を元に変換することができるのです。

    (exact->inexact (sum (map inexact->exact JANUS)))

この式を評価し、その結果を上記の3つの合計と比較してみてください。Webからのアドバイスについて、あなたは今どう思いますか？■


練習問題420
JANUSは単なる固定リストですが、次の関数を見てください:

(define (oscillate n)
  (local ((define (O i)
            (cond
              [(> i n) '()]
              [else
               (cons (expt #i-0.99 i) (O (+ i 1)))])))
    (O 1)))

自然数 n に oscillate を適用すると、数学的級数の最初の n 要素が生成されます。これは図145のようなグラフとして理解するのが一番よいでしょう。DrRacket で (oscillate 15) を実行し、その結果を調べてみてください。

              

    図145：オシレートのグラフ

その結果を左から右に和算するのと、右から左に和算するのとでは、計算結果が異なる。

    > (sum (oscillate #i1000.0))
    #i-0.49746596003269394

    > (sum (reverse (oscillate #i1000.0)))
    #i-0.49746596003269533

ここでも、文脈を見るまでは、その差は小さいように見えるかもしれません。
 
  > (- (* 1e+16 (sum (oscillate #i1000.0)))
       (* 1e+16 (sum (reverse (oscillate #i1000.0)))))
  #i14.0

この違いは重要なのだろうか？コンピュータを信用してもいいのでしょうか？■


問題は、プログラマーが選択権を与えられた場合、どの数字をプログラムに使うべきかということです。もちろん、その答えは文脈に依存する。財務諸表の世界では、定数は正確数として解釈されるべきであり、財務諸表の計算操作は、数学的操作の正確さ保持の性質に依存できるはずである。不正確数やその演算に伴う重大な誤りに法律が対応できないからである。しかし、科学的な計算では、正確な結果を出すために余分な時間がかかると負担が大きくなることがある。そのため、科学者は不正確数を使う傾向があるが、プログラムの出力を利用する際には、数値の誤差が許容範囲内であるかどうか、注意深くプログラムを分析する。



