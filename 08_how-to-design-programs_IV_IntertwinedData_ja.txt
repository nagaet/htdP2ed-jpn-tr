How to Design Programs, Second Edition.
Matthias Felleisen, Robert Bruce Findler, Matthew Flatt, Shriram Krishnamurthi 著.

---

IV 絡み合うデータ

    19 S式の詩

      19.1 樹木

      19.2 森林

      19.3 S式

      19.4 データを絡めてデザインする

      19.5プロジェクトBST

      19.6 関数の簡略化

    20 繰り返しリファインメント

      20.1 データ分析

      20.2 リファイニングデータ定義

      20.3 精製機能

    21 リファイニング・インタープリター

      21.1 表現の解釈

      21.2 変数の解釈

      21.3 関数の解釈

      21.4 全てを解釈する

    22プロジェクトXMLの商取引

      22.1 S式としてのXML

      22.2 XML列挙型のレンダリング

      22.3 ドメイン特化型言語

      22.4 XMLの読み込み

    23 同時処理

      23.1 2つのリストを同時に処理する。ケース1

      23.2 2つのリストを同時に処理する。ケース2

      23.3 2つのリストを同時に処理する。ケース3

      23.4 関数の簡略化

      23.5 2つの複雑な入力を消費する関数を設計する

      23.6 フィンガーエクササイズ2つの入力

      23.7 プロジェクトデータベース

    24 まとめ


リストと自然数に関するデータ定義は非常に珍しいと思われるかもしれません。これらのデータ定義は自分自身を参照するものであり、おそらくあなたが今まで出会ったことのないデータ定義でしょう。しかし、多くのデータクラスでは、この2つのデータ定義よりもさらに複雑なデータ定義が必要です。一般的には、1つのデータ定義に多くの自己参照が含まれていたり、多くのデータ定義が互いに参照し合っていたりする。このようなデータ形式はどこにでもあるため、プログラマはデータ定義の集まりに対応できるようになることが重要である。それが、設計レシピなのだ。

このパートでは、まず、あらゆる形式の構造データ定義に対応できるよう、設計レシピを一般化することから始めます。次に、Projectsから反復的洗練の概念を導入する。複雑なデータ定義は一度に開発されるのではなく、いくつかの段階を経て開発されるため、厳密な根拠に基づいてProjects: Listsから反復改良の概念を導入する。実際、反復的洗練の利用は、すべてのプログラマがリトルサイエンティストであり、我々の学問分野がアメリカ名で「科学」という言葉を使っている理由の一つである。最後の2つの章は、これらのアイデアを説明するものです。1つはBSL用のインタプリタの設計方法を説明し、もう1つはWeb用のデータ交換言語であるXMLの処理について説明しています。最後の章では、設計レシピをもう一回拡張し、2つの複雑な引数を同時に処理する関数のために作り直した。


19 S式の詩

プログラミングは詩に似ている。詩人のように、プログラマーは一見無意味に見えるアイデアで技術を磨くのです。前章で説明したように、彼らは常に修正と編集を繰り返しています。この章では、だんだん複雑になっていく、一見何の役にも立たないようなデータを紹介する。動機づけの背景を説明しても、選ばれたデータの種類は極端に純粋であり、二度と出会うことはないだろう。

とはいえ、この章では設計レシピの威力を存分に発揮し、実世界のプログラムが扱うデータの種類を紹介します。この章では、プログラマとして生きていく上で遭遇するであろう事柄と結びつけるために、各章に適切な名前、すなわち木、森、XMLを付けています。S式とXMLの関係は「プロジェクト」で明らかにされています。The Commerce of XMLでは、この章とは対照的に、複雑な形式のデータの実世界での使用にかなり近い形で説明されています。


=====

19.1 木

私たちは皆、family treeを持っています。family treeの描き方のひとつは、子供が生まれるたびに要素を追加し、父親と母親の要素をつなげていく方法です。両親が不明な人については、描くべきつながりはない。その結果、どのような人物であっても、その人物の既知の先祖をすべて指し示す先祖family treeができあがるのである。

                イメージ

    図111:family tree

図111は3層のfamily treeを表示したものである。Gustavはエバとフレッドの子であり、エバはCarlとBettinaの子である。このfamily treeには、名前と家族関係だけでなく、生まれた年や目の色も記録されている。このスケッチから、何世代にもわたるfamily treeや、その他の情報を記録したfamily treeを容易に想像することができるだろう。

family treeが大きくなれば、それをデータとして表現し、そのデータを処理するプログラムを設計することは理にかなっている。family treeの1点は、父親、母親、名前、生年月日、目の色の5つの情報を組み合わせたものであるとすると、構造タイプを定義する必要がある。

    (define-struct child [father mother name date eyes])

構造体型定義は、データ定義を呼び出す。

 ; A Child is a structure: 
 ;   (make-child Child Child String N String)

このデータ定義は簡単そうに見えますが、役に立たないものでもあります。自分自身を参照しているが、節がないため、適切なインスタンスChildを作成する方法がない。大雑把に言うと、次のように書くしかない:

  (make-child (make-child (make-child ...) ...) ...)

が延々と続く。このような無意味なデータ定義を避けるために、自己言及的なデータ定義はいくつかの節を持ち、そのうちの少なくとも1つはデータ定義を参照しないことを要求する。

データの定義を少し先延ばしにして、実験してみよう。既存のfamily treeに子供を追加しようとするとき、すでに親の表現を持っているとする。この場合、単純に新しい子構造を構築することができる。例えば、CarlとBettinaを既に表現しているプログラムの中でAdamを表現するには、以下のような子構造を追加すればよい。

    (Adamを定義する
      (make-child Carl Bettina "Adam" 1950 "hazel"))

BettinaとCarlは、Adamの両親を象徴する存在です。

また、図111のfamily treeのBettinaのように、親が不明な場合もある。しかし、その場合でも、子表記の親フィールドに対応するものを記入しなければならない。どのようなデータを選ぶにせよ、情報がないことを示すものでなければならない。一方では、既存の値の中から#false、"none"、または'()を使用することができる。一方では、family treeから情報が欠落していることを本当に伝える必要がある。この目的を達成するためには、適切な名前を持つ構造体タイプを導入するのが最も効果的です。

    (define-struct no-parent [])

さて、Bettinaの子構造を作るには、次のようにします。

  (make-child (make-no-parent)
              (make-no-parent)
              "Bettina" 1926 "green")

もちろん、1つだけ情報が足りない場合は、そのフィールドだけにこの特別な値を記入します。

この実験から2つの知見が得られた。第一に、我々は子構造のインスタンスを生成する方法を記述したデータ定義を探しているのではなく、family treeを表現する方法を記述したデータ定義を探しているのである。第二に、データ定義は2つの節からなり、一つは未知の家系を記述するため、もう一つは既知の家系を記述するためである。

  (define-struct no-parent [])
  (define-struct child [father mother name date eyes])
  ; FT（family Tree (family tree) の略）とは、以下のうちの一つである。
  ; - (make-no-parent)
  ; - (make-child FT FT String N String)

gno parenth treeはプログラムの中でたくさん出てくるので、NPをショートハンドとして定義し、データ定義を少し修正します。

  (define NP (make-no-parent))
  ; FTは以下のいずれかである。
  ; - NP
  ; - (make-child FT FT String N String)

「自己参照型データ定義の設計」の設計レシピに従って、データ定義を使ってfamily treeの例を作成する。具体的には、図111のfamily treeをデータ表現に変換する。Carlの情報はデータ化しやすい。

    (make-child NP NP "Carl" 1926 "green")

BettinaとFredは同様のchildのインスタンスで表現されている。Adamの場合は、CarlとBettinaの入れ子になっている子が必要です。

  (make-child (make-child NP NP "Carl" 1926 "green")
    　        (make-child NP NP "Bettina" 1926 "green")
              "Adam"
              1950
              "hazel")

CarlとBettinaのレコードはDaveとEvaのレコードを構築するためにも必要なので、子の特定のインスタンスを指定する定義を導入し、その変数名を他の場所で使用するのがよい。図112は、図111のfamily treeの完全なデータ表現について、この方法を説明したものである。よく見てください。このツリーは、次の設計演習の実行例として使用します。

            ; 最古の世代:
            (define Carl (make-child NP NP "Carl" 1926 "green"))
            (define Bettina (make-child NP NP "Bettina" 1926 "green"))
             
            ; 中間の世代
            (define Adam (make-child Carl Bettina "Adam" 1950 "hazel"))
            (define Dave (make-child Carl Bettina "Dave" 1955 "black"))
            (define Eva (make-child Carl Bettina "Eva" 1965 "blue"))
            (define Fred (make-child NP NP "Fred" 1966 "pink"))
             
            ;最年少の世代:
            (define Gustav (make-child Fred Eva "Gustav" 1988 "brown"))

    図112：サンプルのfamily treeのデータ表現

family treeに関する具体的なプログラムを設計するのではなく、まず、そのような関数の一般的な構成に目を向ける。つまり、具体的なタスクは考えずに、できるだけ設計のレシピに沿って作業を進める。まず、ヘッダー、つまりレシピのステップ2から始めます。

    ; FT -> ?
    ; ...
    (define (fun-FT an-ftree) ...)

この関数の目的を述べていないにもかかわらず、この関数がfamily treeを消費することと、この形式のデータが主な入力であることは分かっています。シグネチャの中の "???" は、この関数がどのようなデータを生成するのかがわからないことを示し、"..."はその目的がわからないことを知らせている。

目的がわからないため、関数の例を作ることはできない。しかし、FTのデータ定義の構成を利用して、テンプレートを設計することができる。2つの節から構成されているので、テンプレートは2つの節を持つcond式で構成されなければならない。

  (define (fun-FT an-ftree)
    (cond
      [(no-parent? an-ftree) ...]
      [else ...]))

fun-FTの引数がno-parent?を満たす場合、構造体には追加のデータがないので、第1節は完了である。第2節に対しては、入力には5つのデータが含まれており、それをテンプレート中の5つのセレクタで示す。

  ; FT -> ???
  (define (fun-FT an-ftree)
    (cond
      [(no-parent? an-ftree) ...]
      [else (... (child-father an-ftree) ...
             ... (child-mother an-ftree) ...
             ... (child-name an-ftree) ...
             ... (child-date an-ftree) ...
             ... (child-eyes an-ftree) ...)]))

テンプレートに追加された最後の機能は、自己参照に関するものである。データ定義がそれ自身を参照する場合、その関数は再帰する可能性が高く、テンプレートはそれを示唆する自然な再帰で示す。FTの定義には2つの自己参照があり、テンプレートは2つの再帰を必要とする。

  ; FT -> ???
  (define (fun-FT an-ftree)
    (cond
      [(no-parent? an-ftree) ...]
      [else (... (fun-FT (child-father an-ftree)) ...
             ... (fun-FT (child-mother an-ftree)) ...
             ... (child-name an-ftree) ...
             ... (child-date an-ftree) ...
             ... (child-eyes an-ftree) ...)]))

具体的には、データ定義の第2節が対応する自己参照を含むため、第2cond節の父親と母親のデータ表現にfun-FTを適用する。

次に、具体的な例、blue-eyed-child? 関数を考えよう。この関数の目的は、与えられたfamily treeの中にある child 構造体が青い目をもっているかどうかを判断することです。fun-FTをコピーして貼り付け、名前を変えると、そのテンプレートが得られます。"???" をBooleanに置き換え、目的の声明を追加しています。

  ; FT -> Boolean
  ; an-ftreeは子を含むか？
  ; eyes フィールドが "blue "である構造体
  (define (blue-eyed-child? an-ftree)
    (cond
      [(no-parent? an-ftree) ...]
      [else (... (blue-eyed-child?
                   (child-father an-ftree)) ...
             ... (blue-eyed-child?
                   (child-mother an-ftree)) ...
             ... (child-name an-ftree) ...
             ... (child-date an-ftree) ...
             ... (child-eyes an-ftree) ...)]))

このように作業する場合、テンプレートの総称を特定の名前に置き換える必要があります。

レシピと照らし合わせると、定義のステップに進む前に、後戻りしていくつかの例を展開する必要があることに気づきます。family treeの最初の人物であるCarlから始めると、Carlのfamily treeには"blue" の目の色を持つ子供がいないことがわかります。具体的には、Carlを表すchild は目の色が "green"です。Carlの祖先の木が空であることを考えると、"blue" の目の色を持つ子供を含むことはあり得ません。

    (check-expect (blue-eyed-child? Carl) #false)

それに対して、Gustavは 青い目を持つEvaという child構造体を含んでいます。

    (check-expect (blue-eyed-child? Gustav) #true)

さて、いよいよ実際の関数を定義する。この関数は、no-parent と child の2つのケースを区別する。最初の場合については、まだ何も例を作っていないが、答は明らかであろう。与えられたfamily treeには子供が一人もいないので、目の色が「青」であるfamily treeを含むことはできない。したがって、最初のcond句の結果は#falseとなる。

2つ目のcond節では、設計にもっと多くの作業が必要です。ここでも設計のレシピに従って、まずテンプレートの中の式が何を達成するのかを思い出します。

  1. 関数の目的の声明によると、

         (blue-eyed-child? (child-father an-ftree))

    は、父親のFTの中のある子供が「青い」目をしているかどうかを決定する。

  2. 同様に、(blue-eyed-child? (child-mother an-ftree))は、母親のFTにおける誰かが青い目をしているかどうかを判定する。

  3. セレクタ式 (child-name an-ftree), (child-date an-ftree), (child-eyes an-ftree) は、それぞれ与えられたchild 構造体から名前、誕生日、目の色を抽出します。

あとは、これらの式をどのように組み合わせるかです。

明らかに、child 構造体のeyesフィールドに "blue "が含まれていれば、関数fsの答えは#trueである。次に、名前と生年月日に関する式は役に立たないので、再帰的な呼び出しが残る。前述のように、（blue-eyed-child? (child-father an-ftree))は父親側のツリーを走査し、母親側のツリーは、(blue-eyed-child? (child-mother an-ftree))で処理される。これらの式のいずれかが #true を返した場合、an-ftree には「青い」目を持つ child が含まれる。

我々の分析では、次の3つの式のうち1つが#trueであれば、結果は#trueになるはずである:

   ・ (string=? (child-eyes an-ftree) "blue")

   ・ (blue-eyed-child? (child-father an-ftree))

   ・ (blue-eyed-child? (child-mother an-ftree))

ということは、これらの式をorで結合する必要がある。

  (or (string=? (child-eyes an-ftree) "blue")
      (blue-eyed-child? (child-father an-ftree))
      (blue-eyed-child? (child-mother an-ftree)))

図113は、すべてを1つの定義にまとめたものである。


---
  ; FT -> Boolean
  ; an-ftreeは
  ; eyes フィールドに "blue "を持つ child 構造体を含むか?
  
  (check-expect (blue-eyed-child? Carl) #false)
  (check-expect (blue-eyed-child? Gustav) #true)
  
  (define (blue-eyed-child? an-ftree)
    (cond
      [(no-parent? an-ftree) #false]
      [else (or (string=? (child-eyes an-ftree) "blue")
                (blue-eyed-child? (child-father an-ftree))
                (blue-eyed-child? (child-mother an-ftree)))]))

    図113:祖先の木から青い目の子を探す
---

この関数は、2つの再帰を使用する最初の関数なので、どのように動作するかを印象づけるために、(blue-eyed-child? Carl) の 1ステップのアクションを以下のようにシミュレートします。

  (blue-eyed-child? Carl)
  ==
  (blue-eyed-child?
    (make-child NP NP "Carl" 1926 "green"))

NPを値とし、childのインスタンスの省略形としてcarlを使用して1ステップ動かします。

  ==
  (cond
    [(no-parent?
       (make-child NP NP "Carl" 1926 "green"))
     #false]
    [else (or (string=? (child-eyes carl) "blue")
              (blue-eyed-child? (child-father carl))
              (blue-eyed-child? (child-mother carl)))])

(falseなので)最初のcond行をdropし、carlをその値に置き換え、図114の3つの補助計算を実行します。これらを用いてequalsをequalsに置き換えることで、残りの計算を簡単に説明することができる。

  ==
  (or (string=? "green" "blue")
      (blue-eyed-child? (child-father carl))
      (blue-eyed-child? (child-mother carl)))
  == (or #false #false #false)
  == #false

数学の授業でこのような補助的な計算を見たことがあると思いますが、ステッパーはそのような計算をせず、絶対に必要な計算だけを行うことも理解しておいてください。

---
  ; (1)
  (child-eyes (make-child NP NP "Carl" 1926 "green"))
  ==
  "green"
  
  ; (2)
  (blue-eyed-child?
    (child-father
      (make-child NP NP "Carl" 1926 "green")))
  ==
  (blue-eyed-child? NP)
  ==
  #false
  
  ; (3)
  (blue-eyed-child?
    (child-mother
      (make-child NP NP "Carl" 1926 "green")))
  ==
  (blue-eyed-child? NP)
  ==
  #false

    図114:ツリーで計算する
---


練習問題310
count-personsを開発せよ。この関数は、family treeを消費し、ツリー内のchild構造体を数えます。■


練習問題311
関数 average-age を開発しなさい。この関数はfamily treeと現在の年号を消費する。それはfamily treeにあるすべてのchild構造体の平均年齢を生成する。■


練習問題 312
family treeを消費して、そのfamily treeに含まれるすべての目の色のリストを生成する関数 eye-colors を開発しなさい。1つの瞳の色は、結果のリストの中に複数回現れるかもしれない。ヒント append を使用して、再帰的な呼び出しから得られるリストを連結してください。■


練習問題313
blue-eyed-child? に似ているが、与えられたchild自身ではなく、適切な祖先が青い目をしているときだけ #true で応答する関数 blue-eyed-ancestor? が必要だとします。

目標は明らかに異なるが、署名は同じである。

    ; FT -> Boolean
    (define (blue-eyed-ancestor? an-ftree) ...)

ストップ! 関数の目的の声明を作成してください。

その違いを理解するために、Evaを取り上げます。

    (check-expect (blue-eyed-child? Eva) #true)

Evaは青い目をしているが、青い目の祖先はいない。したがって

    (check-expect (blue-eyed-ancestor? Eva) #false)

一方、GustavはEvaの息子で、青い目の祖先を持っている。

    (check-expect (blue-eyed-ancestor? Gustav) #true)

さて、友人がこんな解決策を思いついたとしよう。

  (define (blue-eyed-ancestor? an-ftree)
    (cond
      [(no-parent? an-ftree) #false]
      [else
       (or
         (blue-eyed-ancestor?
           (child-father an-ftree))
         (blue-eyed-ancestor?
           (child-mother an-ftree)))]))

この関数がテストの1つに失敗する理由を説明しなさい。どの A を選んでも (blue-eyed-ancestor? A) の結果はどうなりますか？あなたの友人の解答を修正できますか？■




19.2 森林

family tree (家系図) からfamily forest (家系図の森)になるのは、ほんの一歩です。

   FF（ファミリー・フォレストの略）とは、次のうちの一つです。

  ; - '()
  ; - (cons FT FF)
  ; 解釈: family forestは複数の家族（例えば町）とその祖先の木で表せます

図111から木(tree; ツリー)を抜粋し、森(forest; フォレスト)として並べてみました。

  (define ff1 (list Carl Bettina))
  (define ff2 (list Fred Eva))
  (define ff3 (list Fred Eva Carl))


最初の2つの森には、関係のない2つの家族が含まれており、3番目の森は、実際の森とは異なり、家族の森では木が重なり合うことがあることを示しています。

では、この代表的なfamily treeに関する問題を考えてみよう。

    サンプル問題 関数blue-eyed-child-in-forest? を設計し、family forestにeyes フィールドが "blue "のchildが含まれているかどうかを判断する。

---
  ; FF -> Boolean
  ; 森に「青い目」を持つchildが含まれるかどうか
  
  (check-expect (blue-eyed-child-in-forest? ff1) #false)
  (check-expect (blue-eyed-child-in-forest? ff2) #true)
  (check-expect (blue-eyed-child-in-forest? ff3) #true)
  
  (define (blue-eyed-child-in-forest? a-forest)
    (cond
      [(empty? a-forest) #false]
      [else
       (or (blue-eyed-child? (first a-forest))
           (blue-eyed-child-in-forest? (rest a-forest)))]))


    図115：family forestで青い目のchildを探す
---

その素直な解答が図115に表示されています。署名、目的の声明、例を自分で確認してください。ここでは、プログラムの構成に注目します。テンプレートについては、関数がリストを消費するため、設計ではリストテンプレートが使われるかもしれません。もしリストの各項目が eyes フィールドを持つ構造体であり、それ以外には何もない場合、この関数は eyes フィールドのセレクタ関数と文字列比較を使ってこれらの構造体を反復処理します。この場合、各項目はfamily treeですが、幸いなことに、family treeを処理する方法はすでに知っています。

図115をどのように説明したのか、一歩下がって検証してみましょう。出発点はデータ定義のペアで、2つ目が1つ目を参照し、両方が自分自身を参照します。その結果、2番目の関数が1番目の関数を参照し、両方が自分自身を参照する関数のペアができあがった。言い換えれば、データ定義がお互いを参照するのと同じように、関数定義もお互いを参照するのです。初期の章ではこのような関係は無視されていましたが、今では状況は十分に複雑であり、注意を払うに値します。

練習問題314
FFのデータ定義をList-ofの抽象化で再定式化しなさい。今度はblue-eyed-child-in-forest? 関数についても同様にしてください。最後に、前章のリスト抽象化の1つを使用してblue-eyed-child-in-forest? を定義してください。■


練習問題315
関数 average-age を設計せよ。この関数は家族の森と年(N)を消費する。このデータから、森にあるすべての子インスタンスの平均年齢を生成する。注意 この森の木が重なっている場合、ある人が他の人より多く貢献しているため、結果は本当の平均ではありません。この演習では、木が重なり合っていないものとして扱ってください。■



19.3 S-式

"Intermezzo 2: Quote, Unquote"では非公式にS式を紹介していたが、3つのデータ定義の組み合わせで記述することが可能である。

  ; S-exprは以下のいずれかである。
  ; - Atom
  ; - SL
  
  ; Atom は以下のいずれかである。
  ; - Number
  ; - String
  ; - Symbol 

  ; SLは以下のいずれかである。
  ; - '()
  ; - (cons S-expr SL)


Symbolは、先頭にシングルクオート (')をもち、末尾にシングルクオートを持たない文字列のように見えることを思い出してください。

S式のアイデアは、1958年にJohn McCarthyと彼のLisperたちが、Lispプログラムを他のLispプログラムで処理できるようにとS式を作ったことによります。この一見循環的な理由づけは難解に聞こえるかもしれませんが、Intermezzo 2: Quote, Unquoteで述べたように、S式は汎用性の高いデータ形式であり、最近ではWorld Wide Webへの応用でしばしば再発見されるようになっています。このように、S式を扱うことで、高度に絡み合ったデータ定義のための関数を設計する方法について議論する準備ができます。

練習問題316
atom? 関数を定義しなさい。■


本書のここまでで、S式ほど複雑なデータ定義が必要なデータはありません。しかし、1つのヒントを加えて、設計レシピに従えば、S式を処理する関数を設計することができるのです。この点を実証するために、具体的な例に取り組みましょう。

    サンプル問題 　あるsymbolがあるS式に何回出現するかを数える関数countを設計する。

最初のステップでは、データの定義が求められ、それが完了したように見えますが、定義が複雑な場合は特に、データの例を作成することも求められることを忘れないでください。

データ定義というのは、データをどう作るかということの処方箋であって、「テスト」はそれが有用かどうかです。S-exprのデータ定義では、atomはS-exprの要素であり、atomは簡単に作れるというのが一つのポイントです。

    'hello
    20.12
    "world"

同じように、すべてのSLはリストであると同時に、S-exprでもある。

    '()
    (cons 'hello (cons 20.12 (cons "world" '())))
    (cons (cons 'hello (cons 20.12 (cons "world" '())))
          '())

最初の2つは明白ですが、3つ目はもう一度見てみる価値があります。これは2番目のS-exprの繰り返しですが、(cons ... '())の中にネストされています。これはつまり、2番目の例のように、1つの項目を含むリストであることを意味します。この例はリストで単純化することができます。

    (list (cons 'hello (cons 20.12 (cons "world" '()))))
    ; または
    (list (list 'hello 20.12 "world"))

実際、Intermezzo 2: Quote, Unquote"のクォーテーションの機構を使えば、S式を書き出すのはさらに簡単です。最後の3つを紹介しよう:

  > '()
  '()

  > '(hello 20.12 "world")
  (list 'hello #i20.12 "world")

  > '((hello 20.12 "world"))
  (list (list 'hello #i20.12 "world"))

参考になるように、これらの例をDrRacketのインタラクションエリアで評価すると、引用符表記よりも上記の構文に近い結果を見ることができます。

クォーテーションによって、複雑な例も簡単に作ることができる。

  > '(define (f x))
       (+ x 55))
  (list 'define (list 'f 'x) (list '+ 'x 55))


この例は、BSLでの定義のように見えるので、奇妙に感じるかもしれませんが、DrRacketとの相互作用が示すように、これは単なるデータの一部なのです。もう一つ紹介しましょう。

    > '((6 f)
        (5 e)
        (4 d))

   (list (list 6 'f) (list 5 'e) (list 4 'd))

このデータは、文字と数字を関連づけた表のようなものです。最後の例は、芸術作品です。

    > '(wing (wing body wing) wing)
    (list 'wing (list 'wing 'body 'wing) 'wing))

あとは、関数 count のための割と明白なヘッダーを書き込むだけです。

    ; S-expr Symbol -> N
    ; sexp中のsyの出現を全て数える。
    (define (count sexp sy)
      0)


ヘッダーは明らかなので、関数の例題に移りましょう。与えられたS-exprが'worldで、カウントされるsymbolが'worldであれば、答えは明らかに1です。以下は、テストとしてすぐに定式化されるいくつかの例です。

    (check-expect (count 'world 'hello) 0)
    (check-expect (count '(world hello) 'hello) 1)
    (check-expect (count '(((world) hello) hello) 'hello) 2)

テストケースに引用符表記がいかに便利かわかるでしょう。しかし、テンプレートに関しては、引用符で考えると悲惨なことになります。

テンプレートのステップに進む前に、次のデザインのレシピを一般化するための準備が必要です。

    ヒント 相互に関連するデータ定義の場合、1つのデータ定義につき1つのテンプレートを作成します。並行して作成する。データ定義と同じようにお互いを参照していることを確認してください。ヒント終了

このヒントは、実際よりも複雑に聞こえます。今回の問題では、3つのテンプレートが必要だということです。

   1.  S-exprのsymbolの出現回数をカウントするcountのためのテンプレート。

   2. SL内のsymbolの出現回数をカウントする関数のためのテンプレート。

   3. atom内のsymbolの出現回数を数える関数のためのテンプレート。

そして次が、3つのデータ定義が示唆する条件付きの3つの部分テンプレートです。

    (define (count sexp sy))
      (cond
        [(atom? sexp) ...] 
        [else ...]))
    (define (count-atom at sy)
      (cond
        [(number? at) ...]
        [(string? at) ...]
        [(symbol? at) ...]))

    (define (count-sl sl sy))
      (cond
        [(empty? sl) ...] 
        [else ...]))

S-exprのデータ定義が2つの節を持つので、countのテンプレートは2つの条件を含んでいます。atomの場合とSLの場合を区別するためにatom?関数を使います。count-slというテンプレートはSLの要素とsymbolを消費し、SLは基本的にリストなので、count-slも二分岐のcondを含んでいます。最後に、count-atomはatomとsymbolの両方で動作することになっている。そして、これはそのテンプレートがatomのデータ定義で言及されている3つの異なる形式のデータをチェックすることを意味する。

次に、該当する部分の複合データを分解してみる。

    (define (count sexp sy))
      (cond
        [(atom? sexp) ...] 
        [else ...]))

    (define (count-atom at sy)
      (cond
        [(number? at) ...]
        [(string? at) ...]
        [(symbol? at) ...]))

    (define (count-sl sl sy)
      (cond
        [(empty? sl) ...]
        [else
          (... (first sl) ...
           ... (rest sl))]))

なぜ、count-slに2つのセレクタ式を追加するのか？

テンプレート作成の最後のステップは、データ定義の自己参照を検査することである。ここでは、自己参照と、あるデータ定義から別のデータ定義への参照、そして（場合によっては）その逆を意味する。3つのテンプレートのcond行を検証してみよう。

   1. countのatom?行はS-exprの定義の最初の行に対応する。ここからAtomへの相互参照を示すために、(count-atom sexp sy)を追加します。これは、sexpをAtomとして解釈し、適切な関数にそれを扱わせることを意味します。

   2. 同じ考え方で、countの2番目のcond行では、(count-sl sexp sy)の追加を要求しています。

   3. count-slのempty?行は、データ定義の中で他のデータ定義を参照しない行に相当する。

   4. これに対し、else行には2つのセレクタ式があり、それぞれ異なる種類の値を取り出している。具体的には、(first sl)はS-exprの要素なので、(count ...)でくくるということである。結局、countは任意のS-exprの内部でカウントする役割を担っている。次に、(rest sl)は自己参照に対応し、これらは再帰的な関数呼び出しで処理する必要があることがわかる。

   5. 最後に、Atomの3つのケースはすべて原子形式のデータを参照しています。したがって、count-atom関数は変更する必要はない。

---
    (define (count sexp sy)
      (cond
        [(atom? sexp)
         (count-atom sexp sy)]
        [else
         (count-sl sexp sy)]))

    (define (count-atom at sy)
      (cond
        [(number? at) ...]
        [(string? at) ...]
        [(symbol? at) ...]))

    (define (count-sl sl sy)
      (cond
        [(empty? sl) ...]
        [else
         (...
          (count (first sl) sy)
          ...
          (count-sl (rest sl) sy)
          ...)]))

    図 116:S式用のテンプレート
---

---
    ; S-expr Symbol -> N
    ; sexp中のsyの出現を全て数える。
    (define (count sexp sy)
      (cond
        [(atom? sexp) (count-atom sexp sy)]
         [else (count-sl sexp sy)]))

    ; SL Symbol -> N
    ; slにおけるsyの出現回数を数える。
    (define (count-sl sl sy)
      (cond
        [(empty? sl) 0]
        [else
         (+ (count (first sl) sy) (count-sl (rest sl) sy))]))

    ; Atom Symbol -> N 
    ; atに含まれるsyの出現回数を全て数える。
    (define (count-atom at sy)
      (cond
        [(number? at) 0]
        [(string? at) 0]
        [(symbol? at) (if (symbol=? at sy) 1 0)]))

    図 117。S式用のプログラム
---

図116は、3つの完全なテンプレートを示したものである。これらのテンプレートの空白を埋めるのは、図117が示すように簡単である。3つの定義にある任意の行を説明することができるはずである。例えば

    [(atom? sexp) (count-atom sexp sy) ]。

は sexp が Atom であるかどうかを判断し、もしそうなら count-atom を介して S-expr を Atom として解釈する。

    [else
     (+ (count (first sl) sy) (count-sl (rest sl) sy))]

は、与えられたリストがS-exprとSLの2つの部分からなることを意味する。countとcount-slを使うことで、それぞれの部分にsyが何回現れるかを数えることができ、その2つの数を足すことで、sexp全体に含まれるsyの総数が得られます。

    [(symbol? at) (if (symbol=? at sy) 1 0)]

は、atomがsymbolの場合、syがsexpと等しい場合に一度だけ発生し、それ以外は全く発生しないことを教えてくれる。2つのデータはアトミックであるから、それ以外の可能性はない。

練習問題317
3つの関数がつながっているプログラムは、この関係をlocalで表現しなければならない。

図117のプログラムをコピーして、localを使った1つの関数に再編成してください。修正したコードをcountのテストで検証しなさい。

ローカル関数の第2引数syは決して変化しない。それは常に元のsymbolと同じである。したがって、ローカル関数の定義からこれを削除することで、読者に、syがトラバーサルなプロセス全体にわたって一定であることを伝えることができる。■

練習問題318
関数depthを設計してください。この関数は S-expr を消費し、その深さを決定します。atomの深さは1とします。 S-exprのリストの深さは、その項目の最大の深さに1を加えたものです。■


練習問題319
substituteを設計してください。これはS-expr の s と2つのsymbol (oldとnew)を消費する。結果は s のようなもので、old の出現箇所はすべて new で置き換えられている。■


練習問題320
S-exprの定義に2つの変更を加えて、データ定義から関数設計へのステップを練習してください。

第一段階として、S-exprのデータ定義の1つ目の句をatomの定義の3つの句に展開し、S-exprのデータ定義の2つ目の句がList-ofの抽象化を用いるように再定義する。このデータ定義のためのcount関数を再設計しなさい。

第二段階として、SLのデータ定義をS-exprのデータ定義に統合し、countを再度簡略化してください。ヒント: lambdaを使用する。■


練習問題321
S-exprとSLのデータ定義を抽象化し、出現しうるatomの種類を抽象化してください。■


=====

19.4 つながりをもったデータで設計する

自己参照型データの定義から相互参照型データの定義のコレクションへの飛躍は、有限データのデータ定義から自己参照型データ定義へのジャンプよりはるかに小さい。実際、自己参照型データの定義の設計法（「自己参照型データ定義の設計」を参照）は、この一見複雑な状況に適用するためにわずかな調整を必要とするだけである。

  1. 相互に関連するデータ定義の「ネスト」の必要性は、自己言及的なデータ定義の必要性と同様である。問題の声明は多くの異なる種類の情報を扱い、ある情報形式は他の種類を参照する。

    このような場合、先に進む前に、参照と定義を結ぶ矢印を描いておく。図118の左側を考えてみよう。これはS-exprの定義を表示しており、SLとAtomへの参照を含み、矢印でそれぞれの定義に接続されている。同様に、SLの定義は、1つの自己参照とS-exprに戻る1つの参照を含み、やはり、両者は適切な矢印で結ばれている。

    自己言及的なデータ定義と同様に、これらの定義のネストも検証を必要とする。最低限、個々の定義について、いくつかの例を作成することができなければなりません。ネスト内の他のデータ定義を参照しない節から始める。そこから例を生成することが不可能な場合、その定義は無効である可能性があることを心に留めておいてください。

  2. 重要な変更点は、データ定義の数だけ関数を並列に設計しなければならないことです。各関数は、データ定義の1つに特化し、残りの引数はすべて同じものを使用します。それに基づいて、各関数のシグネチャ、目的の声明、ダミー定義から始めます。

  3. データ定義のネストの中で、すべての相互参照を使用する機能例を必ずやり通すこと。

  4. 機能ごとに、その主要なデータ定義に従って、テンプレートを設計する。図52を参考に、最後のステップまでテンプレートを作成する。最後のステップでは、すべての自己参照と相互参照のチェックを行います。このステップのガイドとして、矢印で注釈されたデータ定義を使用します。データ定義の各矢印について、テンプレートにも矢印を記載します。矢印で注釈されたテンプレートについては、図118の右側を参照してください。

---

  (画像ファイルのため省略)

        図118：データ定義とテンプレートのネストを表す矢印
---

    今度は、矢印を実際の関数呼び出しに置き換えてみてください。経験を積んでいくと、自然と矢印を描くステップを省略して、直接関数呼び出しを使うようになります。

    注: データ定義のネストと関数テンプレートのネストの両方に4つの矢印があり、矢印のペアが互いにどのように対応しているかを観察してください。研究者はこの対応関係を「対称性」と呼んでいます。これは、デザインレシピが問題から解決に至るための自然な方法を提供する証拠です。

    本体の設計では、まず、自然な再帰や他の関数の呼び出しを含まないコンダクトラインから始めます。これらは基本ケースと呼ばれる。対応する答えは、通常、容易に定式化できるか、すでに例題で与えられている。その後、自己言及的なケースと関数間呼び出しのケースを扱います。図53の質問と答えを参考にしてください。

    すべての定義が完了したら、テストを実行します。補助関数が壊れている場合、主関数に対するエラーと、欠陥のある補助関数定義に対するエラーの2つのエラーレポートが表示されることがあります。一度の修正で両方が解消されるはずです。テストを実行する際には、その関数のすべての部分をカバーすることを確認してください。

最後に、ステップ5で行き詰まったときは、テーブルベースで組合せ関数を推測する方法を思い出してください。絡み合ったデータの場合、場合ごとの表だけでなく、場合ごとの表と関数ごとの表がないと組み合わせがうまくいかないことがあります。


=====

19.5プロジェクトBST

プログラマーは、関数の性能を向上させるために、データの木表現に取り組むことが多い。特によく知られているのは二分探索木で、情報を素早く保存・検索するのに適しているからだ。

具体的には、人に関する情報を管理する二分木について説明する。family treeにおけるchild構造体の代わりに、二分木はノードを含む。

    (define-struct no-info [])
    (define NONE (make-no-info))
     
    (define-struct node [ssn name left right]).
    ; BT(BinaryTreeの略)は以下のいずれかである。
    ; - NONE
    ; - (make-node Number Symbol BT BT)

対応するデータ定義はfamily treeと同様で、NONEは情報の欠如を示し、各ノードには社会保障番号、名前、および他の2つの二分木が記録される。後者はfamily treeの親のようなものだが、ノードとその左右の木の関係は家族関係には基づいていない。

ここに2つの二分木があります。

    (make-node
      15
      'd
      NONE
      (make-node
        24 'i NONE NONE))

    (make-node
      15
      'd
      (make-node
        87 'h NONE NONE)
      NONE)


図119は、このような樹木を図面としてどのように考えるべきかを示したものである。木は逆さに描かれ、根(root)が上、樹冠(crown of tree)が下にある。各円はノードに対応し、対応するノード構造のssnフィールドでラベル付けされている。図面ではNONEは省略されている。

---

  (画像ファイルのため省略)

    図119：2分探索木と2分木
---


練習問題322
図119の要領で上の2つの木を描け。そして、ある数字があるBTに出現するかどうかを判定するcontains-bt?を設計せよ。■


練習問題323
search-bt を設計してください。この関数は、数値nとBTを消費する。二分木にssnフィールドがnであるノード構造が含まれている場合、関数はそのノードのnameフィールドの値を生成します。そうでなければ、#falseを返す。

ヒント 最初に二分木全体をチェックするcontains-bt?や、各ステージで自然再帰の結果をチェックするboolean?を使うことを検討してください。■


図119の2本の木の数字を左から右へ読むと、2種類の配列が得られる。


木Aの列は昇順でソートされていて、木Bの列はソートされていません。最初の種類の二分木は二分探索木である。すべての二分探索木は二分木であるが、すべての二分木が二分探索木であるわけではない。より具体的には、二分探索木と二分木を区別する条件（データ不変量）を定式化する。

BST 不変量

    BST（二分探索木(Binary Search Treeの略）)とは、以下の条件によるBTのことである。

        ● NONEは常にBSTです。

        ● (make-node ssn0 name0 L R)は以下の場合、BSTである。

            ○ LはBSTである。

            ○ RはBSTである。

            ○ Lのすべてのssnフィールドはssn0より小さい。

            ○ Rのすべてのssnフィールドはssn0より大きい。

つまり、あるBTがBSTにも属するかどうかを調べるには、すべての部分木のすべての数を調べ、それらがある与えられた数より小さいか大きいかを確認する必要があるのだ。これは、データの構築に追加の負担を強いるが、以下の演習で示すように、十分にその価値がある。

練習問題324
関数 inorder を設計せよ。これはニ分木を消費し、その二分木の構成を見たときに左から右に表示されるような、木の中のすべてのssn番号の並びを生成する。

ヒント 以下のようにリストを連結するappendを使用します。

    (append (list 1 2 3) (list 4) (list 5 6 7)) 
    ==
    (list 1 2 3 4 5 6 7)

二分探索木に対して、inorderは何を生成するのか？■


BSTの中からあるssnを持つノードを探すには、BST不変量を利用することができる。BTに特定のssnを持つノードがあるかどうかを調べるには、関数は木のすべてのノードを調べなければならないかもしれない。一方、二分探索木が同じssnを持つノードを含むかどうかを調べるには、関数はノードを調べるごとに2つの部分木のうち1つを調査から外すことができる。

BSTのサンプルで説明しましょう。

    (make-node 66 'a L R)

66を探す場合、探しているノードは見つかったことになります。それよりも小さい数、例えば63を探す場合、66より小さいssnを持つすべてのノードはLに含まれるのでLに注目することができます。同様に、99を探す場合は、66より大きいssnを持つすべてのノードがRにあるので、Lを無視してRに注目することになります。

練習問題325
search-bstを設計せよ。この関数は数値nとBSTを消費する。ツリーにssnフィールドがnであるノードが含まれる場合、この関数はそのノードのnameフィールドの値を生成します。そうでなければ、NONEを生成します。関数の構成は、BST不変性を利用して、必要最小限の比較しか行わないようにしなければなりません。

ソートされたリストでの検索については、練習問題189を参照してください。比べてみてください。■


二分木を作るのは簡単だが、二分探索木を作るのは複雑である。任意の2つのBT、数字、名前が与えられたら、これらの値に正しい順序でmake-nodeを適用するだけで、ほら、新しいBTができあがる。しかし、BSTの場合、結果は通常BSTではないので、同じ手順は失敗する。たとえば、1つのBSTがssnフィールド3と5を正しい順序で持つノードを含み、もう1つ（のBST)がssnフィールド2と6を含む場合、2つのツリーを別のssn(社会保障番号)と名前で単純に結合しても、BSTは生成されない。

残りの2つの課題は、数字と名前のリストからBSTを作成する方法である。具体的には、最初の課題では、与えられたssn0とname0をBSTに挿入する関数、つまり、与えられたBSTにssn0、name0、NONEサブツリーを含むノードを一つ追加挿入したようなBSTを生成する関数が求められている。第二の課題は、数字と名前の完全なリストを扱うことができる関数を要求するものである。


練習問題326
関数create-bstを設計せよ。この関数は、BSTのB、数値のN、symbolのSを受け取る。そして、Bの中のNONEサブツリーを以下のノード構造に置き換えたBSTを生成する。

    (make-node N S NONE NONE)

設計が完成したら、図119のツリーAで関数を使ってテストしてください。■


練習問題327
関数create-bst-from-listを設計しなさい。これは数字と名前のリストを消費し、create-bstを繰り返し適用してBSTを生成する。以下はそのシグネチャである。

     ; [List-of [List Number Symbol]] -> BST

完成した関数を使い、次のサンプル入力からBSTを作成してテストしてください。

    '((99 o)
      (77 l)
      (24 i)
      (10 h)
      (95 g)
      (15 d)
      (89 c)
      (29 b)
      (63 a))

構造設計のレシピに従えば、結果は図119のツリーAになります。既存の抽象化を利用しても、このツリーは得られますが、反転したツリーが得られるかもしれません。それはなぜでしょうか？■


=====

19.6 関数の簡略化

練習問題317では、絡み合った形のデータを扱う関数を、localを使って整理する方法を紹介しました。この構成は、データ定義が最終的なものであることが分かれば、関数を単純化するのにも役立つ。この点を示すために、演習問題319の解答を簡略化する方法を説明する。

---
  ; S-expr Symbol Atom -> S-expr
  ; sexp中のoldをnewに置き換える。
  
  (check-expect (substitute '(((world) bye) bye) 'bye '42)
                '(((world) 42) 42))
 
  (define (substitute sexp old new)
    (local (; S-expr -> S-expr
            (define (for-sexp sexp)
              (cond
                [(atom? sexp) (for-atom sexp)]
                [else (for-sl sexp)]))
            ; SL -> S-expr 
            (define (for-sl sl)
              (cond
                [(empty? sl) '()]
                [else (cons (for-sexp (first sl))
                            (for-sl (rest sl)))]))
            ; Atom -> S-expr
            (define (for-atom at)
              (cond
                [(number? at) at]
                [(string? at) at]
                [(symbol? at) (if (equal? at old) new at)])))
      (for-sexp sexp)))

    図 120:簡略化されるプログラム
---

図120は、substitute 関数の完全な定義を表示している。この定義では、データ定義で提案されたように、ローカル関数と3つの補助関数を使用しています。この図にはテストケースが含まれているので、以下で提案される修正の後に関数を再テストすることができます。ストップ!テストケースを追加で作成してください。

練習問題328
図120をコピーしてDrRacketに貼り付け、あなたのテストスイート(ソフトウェアテストの目的や対象ごとに複数のテストケースをまとめたもの)を追加してください。そしてテストスイートを検証してください。このセクションの残りを読み進めるとき、編集を行ってテストスイートを再実行し、議論の妥当性を確認してください。■

---
  (define (substitute sexp old new)
    (local (; S-expr -> S-expr
            (define (for-sexp sexp)
              (cond
                [(atom? sexp) (for-atom sexp)]
                [else (for-sl sexp)]))
            ; SL -> S-expr 
            (define (for-sl sl)
              (map for-sexp sl))
            ; Atom -> S-expr
            (define (for-atom at)
              (cond
                [(number? at) at]
                [(string? at) at]
                [(symbol? at) (if (equal? at old) new at)])))
      (for-sexp sexp)))

    図121：プログラムの簡略化、ステップ1
---

SLはS-exprのリストを記述することが分かっているので、mapを使ってfor-slを簡略化することができる。その結果は図121を参照してください。元のプログラムでは、for-sexpはsl上の全ての項目に適用されると言っているが、その修正された定義は、同じ考えをmapを使ってより簡潔に表現している。

2番目の簡略化のステップでは、2つの任意の値を比較するequal?を思い出す必要があります。このことを念頭に置くと、3番目のローカル関数はワンライナーで済むようになります。図122は、この2番目の簡略化を表示したものです。

---
  (define (substitute sexp old new)
    (local (; S-expr -> S-expr
            (define (for-sexp sexp)
              (cond
                [(atom? sexp) (for-atom sexp)]
                [else (for-sl sexp)]))
            ; SL -> S-expr 
            (define (for-sl sl) (map for-sexp sl))
            ; Atom -> S-expr
            (define (for-atom at)
              (if (equal? at old) new at)))
      (for-sexp sexp)))
 
  (define (substitute.v3 sexp old new)
    (local (; S-expr -> S-expr
            (define (for-sexp sexp)
              (cond
                [(atom? sexp)
                 (if (equal? sexp old) new sexp)]
                [else
                 (map for-sexp sexp)])))
      (for-sexp sexp)))

    図 122:プログラムの簡略化、ステップ2および3
---

この時点で、最後の2つのローカル定義は1行で構成されている。さらに、どちらの定義も再帰的ではありません。したがって、for-sexpの関数をインライン化することができる。インライン化とは、(for-atom sexp) を (if (equal? sexp old) new sexp) に置き換えることで、つまり、パラメータ at を実際の引数 sexp に置き換えます。同様に、(for-sl sexp)には(map for-sexp sexp)を入れる。図121の下半分を参照のこと。今残っているのは、定義が1つのローカル関数を導入し、それが同じ主要な引数で呼び出される関数だけである。もし、他の2つの引数を系統的に与えれば、ローカルに定義された関数が外側の関数の代わりに使えることがすぐにわかるだろう。

この最後の考えをコードに置き換えた結果がこちらです。

    (define (substitute sexp old new))
      (cond
        [(atom? sexp) (if (equal? sexp old) new sexp) ]。
        [else
         (map (lambda (s) (substitute s old new)) sexp)])

ストップ！なぜ最後の簡略化にlambdaを使わなければならなかったのか、説明してください。



20 反復改良

実世界のプログラムを開発していると、複雑な形の情報と、それをデータで表現する問題に直面することがある。このような場合、科学的なプロセスとしてよく知られている「反復改良(iterative refinement)」を行うのが最も良い方法である。科学者の問題意識は、現実世界の一部を数学で表現することである。その結果を「モデル」と呼ぶ。そして、そのモデルを様々な方法で検証する。特に、実験の結果を予測する。もし、予測と実測の間の食い違いが大きければ、予測結果を改善するためにモデルを改良する。このプロセスは、予測の精度が十分に高まるまで繰り返される。

物理学者がロケットの飛行経路を予測する場合を考えてみよう。ロケットを点描画で表現するのは簡単だが、空気摩擦を考慮できないなど、かなり不正確な表現になってしまう。そこで、物理学者は、ロケットの粗い輪郭を追加し、摩擦を表現するために必要な数学を導入することがあります。この2番目のモデルは、最初のモデルを改良したものである。一般に、科学者は、ロケットの飛行経路を予測するモデルが十分な精度を持つまで、このプロセスを繰り返す － もしくはプログラマーが言うように反復する－ ことになります。

コンピュータサイエンス学部で教育を受けたプログラマーは、この物理学者のように進めていくべきだ。重要なのは、実世界の情報を正確に表現したデータ表現と、それを適切に処理する関数を見つけることである。複雑な状況では、十分なデータ表現と適切な関数の組み合わせにたどり着くための洗練されたプロセスが必要になる。このプロセスでは、まず必要不可欠な情報から始め、必要に応じて他の情報を追加していく。また、プログラマーは、プログラムが完成した後に、ユーザーから追加機能の要求があったため、モデルを改良しなければならないこともある。

これまで、複雑な形式のデータに対して、反復改良を用いてきました。本章では、プログラム開発の原理として、コンピュータのファイルシステムの表現と処理（の一部）を例にとり、反復的洗練を説明します。まず、ファイルシステムについて簡単に説明し、その後、3つのデータ表現を繰り返し開発します。途中、いくつかのプログラミング演習を行い、設計レシピが既存のプログラムの修正にどのように役立つかを確認します。


=====
20.1 データ解析

DrRacketをオフにする前に、すべての作業を安全にどこかに保存しておくことを確認したいものです。そうしないと、次にDrRacketを起動するときはすべてを再入力しなければなりません。そのため、あなたはあなたのコンピュータにプログラムやデータをファイルに保存するように求めます。ファイルはおおよそ文字列です。

            画像のため省略

    図123 ディレクトリツリーの例ディレクトリツリーの例

ほとんどのコンピュータシステムでは、ファイルはディレクトリやフォルダーに整理されています。大雑把に言うと、ディレクトリにはいくつかのファイルと、さらにいくつかのディレクトリが含まれています。後者はサブディレクトリと呼ばれ、さらにサブディレクトリとファイルを含むことがあります。このような階層構造になっているため、ディレクトリツリーと呼ばれています。

図123は、小さなディレクトリツリーのグラフィカルなスケッチが含まれており、コンピュータ科学者がなぜツリーと呼ぶのか、この絵で説明されています。コンピュータサイエンスの慣例に反して、この図では、TSというルートディレクトリを中心にツリーが上に向かって伸びていく様子が描かれている。ルートディレクトリには、read! という1つのファイルと、それぞれTextとLibsという2つのサブディレクトリがあります。最初のサブディレクトリTextには3つのファイルしかなく、後者のサブディレクトリLibsには2つのサブディレクトリしかないが、それぞれ少なくとも1つのファイルを含んでいる。最後に、各ボックスには2つの注釈のうちどちらかが付いている。ディレクトリにはDIR、ファイルにはそのサイズである数字が注釈として付いている。

練習問題329
ディレクトリツリーTSにおいて、ファイル名read！は何回出現するか？ルートディレクトリから発生までの経路を説明できるか？ツリー内の全ファイルの合計サイズはいくらか？各ディレクトリノードがサイズ1の場合、ディレクトリの総サイズはいくらか？ディレクトリは何階層になりますか?


=====
20.2 データ定義の精緻化

練習問題329は、ユーザーがディレクトリについて日常的に尋ねる質問のいくつかをリストアップしています。このような質問に答えるために、コンピュータのオペレーティングシステムは、質問に答えるプログラムを提供しています。このようなプログラムを設計する場合、ディレクトリツリーのデータ表現を開発する必要がある。

本節では、反復改良を利用して、このような3つのデータ表現を開発する。各段階において、どの属性を含み、どの属性を無視するかを決定する必要がある。図123のディレクトリツリーを考え、それがどのように作成されるかを想像してみよう。ユーザが最初にディレクトリを作成したときは、ディレクトリは空である。時間が経つにつれて、ユーザーはファイルやディレクトリを追加していきます。一般に、ユーザーはファイルを名前で呼びますが、ディレクトリはコンテナとして考えることがほとんどです。

モデル1 この思考実験から、最初のモデルは、名前を持つアトミックな実体としてのファイルと、コンテナとしてのディレクトリに焦点を当てるべきであると考えられる。ここでは、ディレクトリをリストとして、ファイルを文字列、つまり名前として扱うデータ定義を示します。

    ; Dir.v1 (ディレクトリの略)は、次のうちの一つです。
    ; - '()
    ; - (cons File.v1 Dir.v1)
    ; - (cons Dir.v1 Dir.v1)
     
    ; A File.v1 は String です。

将来の改良版と区別するために、名称の末尾に.v1が付きます。

練習問題330
図123のディレクトリツリーを、モデル1に従ってデータ表現に変換せよ。■


練習問題331
与えられたDir.v1がいくつのファイルを含んでいるかを決定する関数how-manyを設計しなさい。設計レシピに従うことを忘れないでください。演習330ではデータの例を示しています。■


モデル2 練習問題331を解いた人なら、この最初のデータ定義がまだそれなりに単純であることがわかると思います。しかし、これではディレクトリの本質が見えません。この最初の表現では、あるディレクトリのサブディレクトリの名前をすべてリストアップすることはできない。コンテナよりも忠実にディレクトリをモデル化するためには、名前とコンテナを組み合わせた構造体を導入する必要があります。

        (define-struct dir [name content])

この新しい構造は、次のようにデータ定義の修正することを示唆している。

    ; Dir.v2 は構造体である。
    ; (make-dir String LOFD)
     
    ; LOFD（list of files and directoriesの略）とは、以下のいずれかを指します。
    ; - '()
    ; - (cons File.v2 LOFD)
    ; - (cons Dir.v2 LOFD)
     
    ; A File.v2 は String です。

Dir.v2のデータ定義がLOFDの定義を参照し、LOFDの定義がDir.v2の定義を参照することに注意してください。この2つの定義は相互に再帰的である。

練習問題332
図123のディレクトリツリーをモデル2に従ったデータ表現に変換せよ。■


練習問題333
与えられたDir.v2がいくつのファイルを含んでいるかを決定する関数how-manyを設計しなさい。練習問題332では、データの例を示しています。練習問題331の結果と比較してみてください。■


練習問題334
ディレクトリにさらに2つの属性、サイズと読みやすさを装備する方法を示しなさい。前者はディレクトリそのものが（その内容ではなく）どれだけのスペースを消費するかを測定し、後者はユーザ以外の人がディレクトリの内容を閲覧してよいかどうかを指定します。■


モデル3 ディレクトリと同様に、ファイルにも属性がある。これを導入するには、上記と同じように進める。まず、ファイルの構造を定義する。

    (define-struct file [name size content])

2つ目は、データの定義です。

    ; File.v3は構造体である。
    ; (make-file String N String)

フィールド名が示すように、文字列はファイル名、自然数はそのサイズ、文字列はその内容を表す。

最後に、ディレクトリのcontentフィールドをファイルのリストとサブディレクトリのリストの2つに分割しましょう。この変更には、構造体の定義の修正が必要です。

    (define-struct dir.v3 [name dirs files])

以下は、改良したデータ定義です。

    ; Dir.v3は構造体である。
    ; (make-dir.v3 String Dir* File*) ; (make-dir.v3 String Dir* File*)
     
    Dir* は以下のいずれかである。
    ; - '()
    ; - (cons Dir.v3 Dir*)
     
    ; ファイル*は次のいずれかです。
    ; - '()
    ; - (cons File.v3 File*)


コンピュータサイエンスの慣例に従い、名前の最後に*を付けると「万人受け」することになり、類似の名前と区別する目印になります。File.v3やDir.v3といった類似の名前と区別するための目印です。

練習問題335
図123のディレクトリツリーをモデル3に従ってデータ表現に変換せよ。ファイルの内容には""を使用せよ。■


練習問題336
与えられたDir.v3がいくつのファイルを含んでいるかを計算する関数how-manyを設計しなさい。練習問題335では、データの例を示しています。練習問題333の結果と比較しなさい。

データ定義が複雑な場合、誰がどのように正しい関数を設計できるかを考えてみてください。How-manyが正しい結果を生み出すとあなたが確信できるのはなぜか？■


練習問題337
List-of を使って、データ定義 Dir.v3 を簡略化してください。次に、図95と96のISL+のリスト処理関数を使って、演習問題336の解答の関数定義を簡略化しなさい。■


最初のモデルの単純な表現から始めて、それを段階的に改良することで、ディレクトリツリーのための合理的に正確なデータ表現が開発された。この3番目のデータ表現は、最初の2つのデータ表現よりもはるかに忠実にディレクトリツリーの性質を捉えている。このモデルに基づいて、ユーザがコンピュータのOSに期待する他の多くの機能を作成することができる。


=====
20.3 機能の洗練

以下の演習がある程度現実的になるように、DrRacketには本書の初版からdir.rkt ティーチパック(dir.rkt teachpack) が付属しています。このティーチパックは上述のモデル3の2つの構造型定義を導入していますが、.v3という接尾辞は付いていません。さらに、このティーチパックは、あなたのコンピュータ上にディレクトリツリーの表現を作成する機能を提供します (dir.rktを使うには (require htdp/dir) を定義エリアに追加します)。

    ; String -> Dir.v3
    ; a-path ディレクトリの表現を作成します。
    (define (create-dir a-path) ...)

例えば、DrRacketを開いて、定義エリアに以下の3行を入力した場合：

    (define O (create-dir "/Users/..."))  ; OS Xの場合
    (define L (create-dir "/var/log/"))   ; Linuxの場合
    (define W (create-dir "C:\Users...")) ; Windowsの場合

プログラムを保存してから実行すると、コンピュータ上のディレクトリのデータ表現が得られます。実際、create-dir を使って、コンピュータ上のファイルシステム全体を Dir.v3 のインスタンスにマップすることができます。

警告 (1) 大きなディレクトリツリーでは、DrRacketがディレクトリのデータ表現を構築するのにたくさんの時間が必要になるかもしれません。まず、小さなディレクトリツリーでcreate-dirを使用してください。(2) 独自にdir構造体を定義しないでください。ティーチパックではすでにdir構造体は定義されています。構造体を2度定義してはいけません。

create-dirはディレクトリツリーを表現しているだけですが、このレベルでプログラムを設計することの意味を知るには十分な現実的です。以下の演習問題はこの点を説明するものです。Dirはディレクトリツリーのデータ表現という一般的な概念を指す。Dirの最も簡単なデータ定義により、それぞれの演習問題を完了できます。演習337のデータ定義と図95、96の関数は自由に使ってください。

練習問題338
create-dirを使って、あなたのディレクトリのいくつかをISL+データ表現に変えてください。そして、演習336のhow-manyを使って、それらが含むファイルの数を数えてください。なぜあなたは、how-manyがこれらのディレクトリに対して正しい結果を生成すると確信できるのでしょうか？■


練習問題339
関数 find? を設計してください。この関数は、Dirとファイル名を消費し、そのファイル名をもつファイルがディレクトリツリーに存在するかどうか判定します。■


練習問題340
与えられたDirにあるすべてのファイルとディレクトリの名前をリストアップする関数lsを設計しなさい。■


練習問題341
Dir を消費してそのディレクトリツリー全体の全ファイルの総サイズを計算する関数 du を設計しなさい。ディレクトリをDir構造に保存する場合、ファイル保存単位が1かかると仮定する。現実の世界では、ディレクトリは基本的に特殊なファイルであり、その大きさは関連するディレクトリの大きさに依存する。■


残りの課題は、パスの概念に依存するもので、ここでは名前のリストである。

    ; パス(Path)は [文字列のリスト]である。
    ; 解釈：ディレクトリツリーにおける道順(direction)のリスト

図123をもう一度見てみましょう。その図では、TSからpart1へのパスは（リスト "TS" "Text" "part1"）である。同様に、TSからCodeへのパスは(list "TS" "Libs" "Code")である。

練習問題342
find を設計せよ。この関数はディレクトリ d とファイル名 f を消費し、 (find? d f) が #true ならばファイル名 f のファイルへのパスを生成し、そうでなければ #false を生成する。

ヒント ファイル名がディレクトリツリーの中にあるかどうかを最初に確認したいところですが、サブディレクトリの一つ一つについて確認しなければなりません。したがって、find?とfind.の機能を組み合わせるのがよいでしょう。

課題 find関数は図123のread！という名前の2つのファイルのうち1つだけを発見する。find-allはfindを一般化し、dの中のfにつながるすべてのパスのリストを生成する。このfind-allを設計してください。これはfindを設計するのと比較して本当に難しいか？■

練習問題343
与えられたDirに含まれるすべてのファイルのパスをリストアップする関数ls-Rを設計しなさい。■


練習問題344
問題343 の ls-R を使って 問題342 の find-all を再設計してください。これは合成による設計です。もしあなたが練習問題342の課題の部分を解決したなら、あなたの新しい関数はディレクトリを見つけることもできます。



21 インタープリタの改良

DrRacketはプログラムです。それは多くの異なる種類のデータを扱う、複雑なものです。多くの複雑なプログラムと同様に、DrRacketもまた、プログラマーがテキストを編集するための機能、インタラクションエリアのような機能、定義や式が「文法的」であるかどうかをチェックする機能など、多くの機能から構成されています。

この章では、インタラクション領域の心臓部を実装する機能を設計する方法を紹介します。当然ながら、この設計プロジェクトには反復的な改良を用います。実のところ、DrRacketのこの側面に注目するというアイデアそのものが、洗練のもう一つの例であり、つまり、1つの機能だけを実装するという当たり前の例なのです。

簡単に言うと、入力された式の値を決定する作業を行うのがインタラクションエリアです。RUNをクリックすると、インタラクションエリアはすべての定義について知ることができます。そして、これらの定義を参照する可能性のある式を受け入れ、その式の値を決定し、このサイクルを何度でも繰り返すことができるのです。このため、多くの人はインタラクションエリアをread-eval-printループと呼んでいます。

この本と同じように、私たちの洗練されたプロセスは、BSL数値表現から始まります。それらは単純で、定義の理解を前提とせず、小学5年生のお姉さんでもその値を決定することができます。この最初のステップを理解すれば、BSL表現とその表現の違いを知ることができます。次に、変数を使った表現に移ります。最後のステップは、定義を追加することです。


=====

21.1 式を解釈する

私たちの最初のタスクは、BSLプログラムのデータ表現に合意することです。つまり、BSL式をBSLデータの一部としてどのように表現するかを考えなければなりません。最初、これは奇妙で珍しいことのように聞こえますが、難しいことではありません。手始めに数字、足し算、掛け算を表現したいだけだとします。明らかに、数字は数字を表すことができます。しかし、加算式は2つの式を含むので複合データを必要とし、乗算式とは異なるので、これもデータ表現が必要です。

5章「構造体の追加」に続いて、加算と乗算を表現する簡単な方法は、それぞれ2つのフィールドを持つ2つの構造体タイプを定義することである。

    (define-struct add [left right])
    (define-struct mul [left right])

この場合、"left"フィールドには演算子の「左」にあるオペランド（被演算子）が、"right"フィールドにはもう一方のオペランドが格納されることになります。次の表は、3つの例を示しています。

    BSL表現                  BSL 表現
    ---------------------    ----------------------------
    3                        3
    (+ 1 1)                  (make-add 1 1)
    (* 300001 100000)        (make-mul 30001 100000)


次の質問は、部分式を持つ式に関するものです。

    (+ (* 3 3) (* 4 4))

意外と簡単な答えは、フィールドにはどんな値でも入れることができるということです。この場合、leftとrightは式の表現を含むことができ、これを好きなだけ深くネストすることができます。その他の例については、図124を参照してください。


---
BSL expression             representation of BSL expression
--------------------------------------------------------------------
(+ (* 1 1) 10)             (make-add (make-mul 1 1) 10)

(+ (* 3 3)                 (make-add (make-mul 3 3)
   (* 4 4))                          (make-mul 4 4))

(+ (* (+ 1 2) 3)           (make-add (make-mul (make-add 1 2) 3)
   (* (* (+ 1 1)                     (make-mul (make-mul
         2)                                      (make-add 1 1)
      4))                                        2)
                                               4))

    図124:BSL式を表現する
---

練習問題345
addとmulの構造型定義に基づいて、BSL式を表現するための データ定義を作成しなさい。新しいデータクラスには、S-exprのアナロジーとしてBSL-exprを使用するものとします。

以下の式をデータに変換してください。

    (+ 10 -10)

    (+ (* 20 3) 33)

    (+ (* 3.14 (* 2 3)) (* 3.14 (* -1 -9)))

次のデータを式として解釈してください。

    (make-add -1 2)

    (make-add (make-mul -2 -3) 33) 

    (make-mul (make-add 1 (make-mul 2 3)) 3.14)

注 ここで、"解釈" は「データから情報へ変換する」という意味である。 これに対して、本章のタイトルにある「インタープリタ」は、プログラムの表現を 消費してその値を生成するプログラムのことである。この2つの考え方は関連していますが、同じではありません。■


さて、BSLプログラムのデータ表現ができたので、次は評価器を設計しましょう。この関数はBSL式の表現を消費し、その値を生成します。この関数はあなたが今まで設計したきたものとは異なるので、いくつかの例で実験することが得策です。そのためには、式の値が何であるかを知るために算術の規則を使うか、DrRacketのインタラクションエリアで「遊ぶ」ことができます。次の表で私たちの例を見てみてください。


BSL式             その表現                        その値
--------------------------------------------------------
3                 3                                    3
(+ 1 1)           (make-add 1 1)                       2
(* 3 10)          (make-mul 3 10)                     30
(+ (* 1 1) 10)	  (make-add (make-mul 1 1) 10)        11


練習問題346
BSL式の表現が評価できる値のクラスについて、データ定義を決定しなさい。■


練習問題347
eval-expressionを設計せよ。この関数はBSL式の表現を消費し、その値を計算する。■


練習問題348
#true, #false, and, or, notから構成されるBSL論理式のデータ表現を開発しなさい。そして、BSL論理式の（表現を）消費してその値を計算する eval-bool-expressionを設計しなさい。これらのブール式はどのような値を生成するのでしょうか？■


利便性と構文解析
 S式はBSL表現を我々のプログラミング言語で表現するための便利な方法を提供します。

    > (+ 1 1)
    2
    > '(+ 1 1)
    (list '+ 1 1)

    > (+ (* 3 3) (* 4 4))
    25

    > '(+ (* 3 3) (* 4 4))
    (list '+ (list '* 3 3) (list '* 4 4)))

式の前に引用符を付けるだけで、ISL+のデータを得ることができる。

S式表現の解釈するのは不器用なものですが、それはだいたい、すべてのS式がBSL-exprを表現しているわけではないからです。たとえば、#true, "hello", そして '(+ x 1) はBSL式の表現ではありません。その結果、S式はインタプリタの設計者にとってかなり不便なものとなっています。

プログラマーは、使用上の利便性と実装の間のギャップを埋めるためにパーサーを発明しました。パーサーは、あるデータがデータ定義に適合しているかどうかを調べると同時に、適合していれば、選択されたデータのクラスから適合する要素を構築します。後者はパースツリーと呼ばれる。与えられたデータが適合しない場合、パーサーは"6.3 Input Errors"のチェック関数と同じようにエラーを通知します。

図125は、S式のためのBSLパーサーを示します。具体的には、parseはS-exprを消費し、BSL-exprを生成します－与えられたS式がBSL-exprの表現をもつBSL式の引用の結果であり、逆も正しい場合にのみ。???


練習問題349
DrRacket がテスト実行中に定義領域のすべての要素がカバーされていることを教えてくれるまで、parse のテストを作成してください。■


練習問題350
このプログラムの定義は、デザインレシピに関して何か変わった点があるか。■


練習問題351
interpreter-exprを設計せよ。この関数はS式を受け付ける。もしparseがそれらをBSL-exprとして認識すれば、その値を生成します。そうでなければ、parseと同じエラーを通知します。■

---
  ; S-expr -> BSL-expr
  (define (parse s)
    (cond
      [(atom? s) (parse-atom s)]
      [else (parse-sl s)]))
  
  ; SL -> BSL-expr 
  (define (parse-sl s)
    (cond
      [(and (consists-of-3 s) (symbol? (first s)))
        (cond
          [(symbol=? (first s) '+)
           (make-add (parse (second s)) (parse (third s)))]
          [(symbol=? (first s) '*)
           (make-mul (parse (second s)) (parse (third s)))]
          [else (error WRONG)])]
      [else (error WRONG)]))
  
  ; Atom -> BSL-expr 
  (define (parse-atom s)
    (cond
      [(number? s) s]
      [(string? s) (error WRONG)]
      [(symbol? s) (error WRONG)]))
  
  ; SL -> Boolean
  (define (consists-of-3 s)
    (and (cons? s) (cons? (rest s)) (cons? (rest (rest s)))
         (empty? (rest (rest (rest s))))))

    図125:S-exprからBSL-exprへ
---


=====

21.2 変数の解釈

最初の節では定数の定義を無視しているので、式に変数が含まれていても値を持たない。実際、xが何を表しているかが分からない限り、(+ 3 x)を評価することは意味がない。したがって、評価器に対する最初の改良は、評価したい式に変数を追加することである。(DrRacketの)定義領域には、次のような定義が含まれていることが前提である。

    (define x 5)

そして、プログラマはインタラクション領域でxを含む式を評価する：

    > x
    5

    > (+ x 3)
    8

    > (* 1/2 (* x 3))
    7.5

実際、2つ目の定義、例えば（define y 3）と、2つの変数を含む相互作用を想像することができるだろう。

    > (+ (* x x))
         (* y y))

    34

前節では、変数の表現としてsymbolを暗黙的に提示した。結局のところ、変数を持つ式を表現するために引用符をつけられたS式を選ぶとしたら、symbolは自然に現れる：

    > 'x
    'x

    > '(* 1/2 (* x 3))
    (list '* 0.5 (list '* 'x 3)))

明らかな代替策は文字列を使うことでその場合 "x"はxを意味しますが、本書はインタープリターを設計するための本ではないので、symbolにこだわります。この決定から、練習問題345のデータ定義をどのように修正すればよいかがわかります。

    ; BSL-var-exprは以下のいずれかである。
    ; - Number
    ; - Symbol 
    ; - (make-add BSL-var-expr BSL-var-expr)
    ; - (make-mul BSL-var-expr BSL-var-expr)

これまでのデータ定義に1つの節を追加するだけです。

データの例として、次の表は、変数を含むいくつかのBSL式とそのBSL-var-expr表現を示しています。

    BSL表現                BSL表現の表現
-----------------------    -----------------------------------
    x                      'x

    (+ x 3)                (make-add 'x 3)

    (* 1/2 (* x 3))        (make-mul 1/2 (make-mul 'x 3))

    (+ (* x x))            (make-add (make-mul 'x 'x)
       (* y y))                      (make-mul 'y 'y))
    	

      
    	
    (make-add (make-mul 'x 'x))
              (make-mul 'y 'y))

これらはすべて上記の相互作用から得られたもので、つまりxが5でyが3のときの結果を知っていることになります。

変数式の値を決定する方法の1つは、すべての変数を、それらが表す値に置き換えることです。これは学校の数学の授業で習った方法で、全く問題ない方法です。

練習問題352
substを設計してください。この関数は、BSL-var-exprの ex, symbol x, 数 v を消費し、x の出現をすべて v で置き換えた BSL-var-expr の ex を生成します。■


練習問題353
numeric?関数を設計しなさい。これは、BSL-var-exprがBSL-exprでもあるかどうかを判断するものです。ここでは、演習問題345に対するあなたの解答が、symbolなしのBSL-var-exprの定義であると仮定します。■


練習問題354
eval-variableを設計しなさい。チェックされた関数はBSL-var-exprを消費し、入力に対してnumeric? が真を返した場合にその値を決定します。そうでなければ、エラーを通知します。■


一般に、プログラムでは定義領域に多くの定数が定義され、式には複数の変数が含まれる。このような式を評価するためには、定義領域が一連の定数定義を含んでいるときの表現が必要である。この演習では、連想リストを使用する。

    ; AL(連想リスト(association list)の略)は[List-of Association]である。
    ; Associationは2つの項目からなるリストである。
    ; (cons Symbol (cons Number '())).

ALの要素を構成しましょう。

eval-variable*を設計します。この関数は、BSL-var-exprの exと連想リスト daを消費します。exから始めて、daのすべてのassociationにsubstを繰り返し適用します。もしその結果に対して numeric? が真になればその値を決定し、そうでなければ eval-variableと同じエラーを通知します。
ヒント：与えられたBSL-var-exprをatom値として考え、与えられた連想リストを代わりに走査してください。このヒントは、この関数の作成に同時処理によるちょっとした設計知識が必要なためです。

環境モデル：演習問題 354 は、定数定義の数学的理解に依存している。もしある名前がある値を表すと定義されているならば、その名前のすべての出現をその値に置き換えることができる。置換は、評価プロセスが始まる前に、この置き換えを一度に実行する。

環境モデルと呼ばれる別のアプローチは、必要なときに変数の値を調べることである。評価器は式の処理をすぐに始めるが、定義域の表現も一緒に持ち運ぶ。評価者が変数に出会うたびに、定義域からその値を探し、使用する。

練習問題355
eval-var-lookup を設計せよ。この関数はeval-variable*と同じシグネチャを持つ。

    ; BSL-var-expr AL -> Number
    (define (eval-var-lookup e da) ...)

置換を使う代わりに、この関数はBSL-var-expr用のデザインレシピが提案する方法で式を走査します。式を降りて（走査して）いくとき、それはALリストのdaを持ち運びます。symbolxに出会うと、assqを使って連想リスト中のxの値を探します。もし値がなければ、eval-var-lookup はエラーを通知します。■


=====

21.3 関数の解釈

この時点で、あなたは定数定義と変数式からなるBSLプログラムを評価する方法を理解しています。当然、関数定義を追加して、－少なくとも原理的には－ BSLのすべてをどのように扱うか知っておきたいものです。

本節の目的は、「21.2 変数の解釈」の評価器を改良して、関数に対応できるようにすることです。関数定義は定義領域に表示されるため、洗練された評価器は、定義領域に多くの関数定義があり、プログラマがこれらの関数の使用を含む式を相互作用領域に入力したときに、DrRacketをシミュレートするという言い方もできる。

簡単のために、定義領域にあるすべての関数は引数を1つだけ消費し、そのような定義は1つだけであると仮定しましょう。必要な知識は、f(x) = eが関数fの定義を表し、f(a)がfのaへの適用を表し、後者を評価するにはeのxにaを代入すると学校で習った時期にまでさかのぼることができます。

以下の問題に取り組む前に、intermezzo 1で紹介した関数に関する用語の知識を再確認しておくとよいでしょう。代数学の授業では、このような数学的な側面はほとんど扱われないが、これらの問題を解くためには、用語を正確に使い、理解することが必要である。

練習問題356
「21.2 変数の解釈」のデータ表現を拡張して、プログラマが定義した関数のアプリケーションを含むようにしなさい。関数アプリケーションは名前と式の2つの部分からなることを思い出してください。前者は適用される関数の名前であり、後者は引数である。

(k (+ 1 1)), (* 5 (k (+ 1 1))), (* (i 5) (k (+ 1 1))) のような式を表現します。この新しく定義されたデータのクラスをBSL-fun-exprと呼ぶことにします。


練習問題357
eval-definition1 を設計する。この関数は4つの引数を消費する。

    1. BSL-fun-exprの ex ;

    2. 関数名を表すsymbolの f ;

    3. 関数のパラメーターを表すsymbolの x ; 

    4. 関数fの本体を表す BSL-fun-expr の b。

eval-definition1はexの値を決定します。eval-definition1 は、ある引数への f の適用に出会うと、その引数に対して

    1. 引数を評価する。

    2. bにおけるxに、引数の値を代入する。

    3. 最後に eval-definition1 で結果の式を評価する。

ここでは、argを関数適用の引数と仮定して、その手順をコードとして表現する方法を説明します。

  (local ((define value (eval-definition1 arg f x b))
          (define plugd (subst b x value)))
    (eval-definition1 plugd f x b))

この行は、これまで取り上げられなかった再帰の形式を使用していることに注意されたい。このような関数の適切な設計については、5章の生成再帰(Generative Recursion)で説明します。

eval-definition1 が変数に遭遇した場合、練習問題354の eval-variable と同じエラーを通知します。また、f 以外の関数名を参照する関数適用に対してもエラーを通知します。

警告 このように、再帰性を利用すると、非終了という新しい要素が計算の中に入ってくる。つまり、プログラムは結果を出したり、エラーを通知したりすることなく、永遠に実行される可能性があるのです。最初の4つのパートの設計に従えば、そのようなプログラムは書けません。楽しみのために、eval-definition1 に永久に実行されるような入力を作ってみましょう。プログラムを終了させるには STOP を使ってください。■


インタラクション領域を模倣する評価器には、定義領域の表現が必要である。ここでは、定義のリストを想定している。

練習問題358
関数定義のための構造型とデータ定義を提供しなさい。このような定義には3つの本質的な属性があることを思い出してください。

    1. symbolで表現される関数の名前。

    2. 関数のパラメータ（名前でもある）。

    3. 変数式である関数の本体。

このクラスのデータを指すのにBSL-fun-defを使用します。

これらのBSL関数定義を表現するために、データ定義を使用します。

    1. (define (f x) (+ 3 x))

    2. (define (g y) (f (* 2 y)))

    3. (define (h v) (+ (f v) (g v)))

次に、多数の1引数関数の定義からなる定義領域を表すクラスBSL-fun-def*を定義します。f, g, hを定義する定義領域をあなたのデータ表現に変換し、da-fghと名付けましょう。

最後に、次のようなウィッシュの元でプログラミングしてください。

    ; BSL-fun-def* Symbol -> BSL-fun-def
    ; daにおけるfの定義を取得します。
    ; 存在しない場合はエラーを通知する
    (check-expect (lookup-def da-fgh 'g) g)
    (define (lookup-def da f) ...)

定義を調べることは、関数適用の評価には必要です。


練習問題359
eval-function*を設計せよ。この関数はBSL-fun-exprの exとda (BSL-fun-def*による定義領域の表現)を消費します。この関数は、定義領域がdaを含むと仮定して、インタラクション領域で ex を評価した場合に、DrRacketが示す結果を生成します。

この関数は、練習問題357の eval-definition1 と同じような働きをします。ある関数fの適用に対して、それは

    1. 引数を評価する。

    2. daのBSL-fun-def表現にあるfの定義を調べます。 daは、パラメータと本体を伴っています。

    3. 関数本体の関数パラメータに引数の値を代入する

    4. 再帰的に新しい式を評価する。

DrRacketと同様、eval-function*は定義領域で定義されていない変数や関数名に出会うと、エラーを通知します。■



21.4 全てを解釈する

次のBSLプログラムをみてください。

    (define close-to-pi 3.14)
     
    (define (area-of-circle r))
      (* close-to-pi (* r r)))
     
    (define (volume-of-10-cylinder r))
      (* 10 (area-of-circle r))

これらの定義は、DrRacket の定義エリアと同じだと考えてください。RUNをクリックすると、インタラクションエリアでclose-to-pi, area-of-circle, volume-of-10-cylinder を含む式を評価することができるようになります。

  > (area-of-circle 1)
  #i3.14

  > (volume-of-10-cylinder 1)
  #i31.400000000000002

  > (* 3 close-to-pi)
  #i9.42

このセクションの目標は、あなたの評価器を再度改良して、DrRacketをこれだけ模倣できるようにすることです。


練習問題360
DrRacketの定義領域を表現するためのデータ定義を作成しなさい。具体的には、定数定義と1引数関数定義が自由に混在するシーケンスに対して、データ表現が機能する必要があります。この節の冒頭の3つの定義からなる定義領域を表現できることを確認する。このようなデータのクラスをBSL-da-allと名づける。

関数lookup-con-defを設計しなさい。この関数は、BSL-da-allの daとsymbolの xを消費します。それは、daにそのようなデータが存在すれば、 xという名前を持つ定数定義の表現を生成します。そうでなければ、そのような定数定義が見つからないというエラーを通知します。

関数lookup-fun-defを設計しなさい。この関数は、BSL-da-allの daとsymbolの fを消費し、fを名前とする関数定義が daに存在すればその表現を生成します。そうでなければ、そのような関数定義が見つからないというエラーを通知します。■


練習問題361
eval-allを設計せよ。練習問題359のeval-function*と同様に、この関数は式の表現と定義領域を消費する。式がインタラクション領域のプロンプトに入力され、定義領域が適切な定義を含んでいる場合、DrRacketが表示するのと同じ値を生成します。ヒント eval-all関数は、練習問題355のeval-var-lookupのように、与えられた式の中の変数を処理する必要があります。■


練習問題362
BSLの式の構造ベースのデータ表現と定義域を入力するのは面倒です。式の解釈の終わりが示すように、式と（定義の）リストを引用するのはずっと簡単です。

関数インタプリタを設計せよ。これはS-exprとSlを消費する。前者は式を表し、後者は定義のリストを表します。この関数は適切な解析関数で両者を解析し、練習問題361の eval-all を使って式を評価します。ヒント 定義や定義のリストのパーサーを作成するには、練習問題350のアイデアを適用する必要があります。■


この時点で、あなたはBSL通訳について多くのことを知っています。ここで、欠けている部分をいくつか挙げてみましょう。文字列と文字列長や文字列追加などの操作、リストと '(), empty?, cons, cons?これらの関数に対応できるようになれば、基本的に完成です。なぜなら、評価者はすでに再帰的な関数を解釈する方法を知っているからです。なぜなら、評価者はすでに再帰関数をどのように解釈すればよいかを知っているからです。




22 プロジェクトXMLの商取引

XMLは広く使われているデータ言語である。その用途のひとつは、異なるコンピュータ上で動作するプログラム間のメッセージ交換に関わるものです。例えば、WebブラウザーでWebサイトを表示すると、自分のコンピュータにあるプログラムと他のコンピュータにあるプログラムが接続され、後者がXMLデータを前者に送信することになります。ブラウザーはXMLデータを受け取ると、それをコンピュータのモニター上に画像として表示する。

この考えを具体的な例で説明すると、次のような比較になります。


　（画像が含まれるため省略)


左側は、ウェブサイトがウェブブラウザーに送信するXMLデータの一部です。右側は、ある一般的なブラウザーがこのデータをどのように表示するかを示しています。

本章では、絡み合ったデータ定義と反復的な改良に関するもう一つの設計演習として、XMLの処理の基本を説明します。次の章では、S式とXMLデータの非公式な比較から始めて、それを使って本格的なデータ定義を行います。XMLは2022年には古すぎると思う方は、JSONや他の最新のデータ交換フォーマットでこの演習をやり直してもかまいません。設計の原則は変わりません。残りのセクションでは、XMLデータのS式をどのように処理するか、例を挙げて説明します。


=====

22.1 S式としてのXML

XMLデータの最も基本的な部分は次のようなものです。

    <machine> </machine>


これは要素と呼ばれ、"machine"は要素の名前です。要素の2つの部分は、要素の内容を区切る括弧のようなものです。2つの部分の間に空白以外の内容がない場合、XMLでは以下のようなショートハンドが許されます：

    <machine />


しかし、ここで我々懸念する限り、このショートハンドは、明示的に括弧で囲まれたバージョンと同等である。

(メモ　RacketのxmlライブラリはXMLをS式だけでなく構造体でも表現します）

S式のパースペクティブからみるとXMLの要素はあるデータを囲む名前付きの括弧です。そして実際、S式で上記を表現することは非常に自然なことです

   '(machine)

このデータには開き括弧、閉じ括弧があり、内容を埋め込むためのスペースが付属しています。

ここに、データを持つXMLデータがあります。

    <machine><action /></machine>


<action />の部分はショートハンドであり、私たちが本当にこのデータの一部を見ていることを意味することを忘れないでください。

    <machine><action></action></machine>。


一般に、XML要素の内容は、一連のXML要素である。

    <machine><action /><action /><action /></machine>



ストップ！ 続ける前に <action />のショートハンドを展開してみてください。

S式での表現の方がシンプルに見えるのが続きます。以下は1個目(のXMLをS式にしたもの）です。

    '(machine (action))

そして、これが2個目のための表現です。

    '(machine (action) (action) (action))

3つの<action />要素が連続するXMLデータを見たとき、このような要素を互いに区別したい場合があることに気づきます。その目的のためには、XMLの要素には属性が付与されています。例えば

   <machine initial="red"></machine>

は "machine" 要素で、名前は "initial"、値は "red" という文字列引用符で囲まれた属性をもっています。以下は、そのネストした要素が属性をもつという複雑なXML要素です。

  <machine initial="red">
    <action state="red"    next="green" />
    <action state="green"  next="yellow" />
    <action state="yellow" next="red" />
  </machine>

要素を読みやすくするために空白、インデント、改行を使っていますが、この空白はここでのXMLデータには何の意味も持ちません。

上記のような"machine"の要素に対するS式は、XMLの親戚のように見えます。

    '(machine ((initial "red")))

(XMLはS-expressionより40年も若い)


要素に属性を追加するには、リストのリストを使用します。リストのそれぞれには、symbolと文字列の2つの項目を含めます。symbolは属性の名前を表し、文字列はその値を表します。この考え方は、複雑な形式のXMLデータにも当然適用されます。

   '(machine ((initial "red"))
     (action ((state "red") (next "green")))
     (action ((state "green") (next "yellow")))
     (action ((state "yellow") (next "red"))))


今のところ、属性が2つの開き括弧でマークされ、残りのXML要素の（表現の）リストが1つの開き括弧を持つことに注意してください。

このアイデアは、「インターメッツォ2: 引用、引用解除（Intermezzo 2: Quote, Unquote)」 で、XMLの特殊な方言であるXHTMLをS式で表現したことを思い出すかもしれません。特に、そのインターメッツォ2では、バッククオートとアンクォートを使うことで、プログラマが非自明なXMLデータやXML表現のテンプレートさえも簡単に書き下すことができることを示しました。もちろん、「21.1 式の解釈」では、与えられたS式がXMLデータの表現であるかどうかを判断するパーサが必要であること、そして、パーサは複雑で特殊な種類の関数であることが指摘されています。

しかし、この古くて詩的なアイデアの有用性を実用的に示すために、我々は、S式に基づくXMLの表現を選択したのです。データ定義に反復的な改良を加えながら、徐々に進めていきます。以下はその最初の試みである。

    ; Xexpr.v0 (XexprはX-expressionの略)は1項目のリストである。
    ;   (cons Symbol '())

これが冒頭の "名前付きの括弧（named parentheses)"のアイデアです。この要素表現にデータを付けるのは簡単です。

    ; Xexpr.v1はリストである。
    ;   (cons Symbol [List-of Xexpr.v1])


symbolの名は、XML要素の表示からなるリストの最初の項目となる。

最後の改良は、属性の追加です。XML要素の属性はオプションであるため、改訂されたデータ定義には2つの節があります。

   ; Xexpr.v2はリストです。
   ; - (cons Symbol Body)
   ; - (cons Symbol (cons [List-of Attribute] Body))
   ; ここで、Bodyは[List-of Xexpr.v2]の略称である。
   ; Attribute は2つの要素のリストです:
   ;   (cons Symbol (cons String '()))


練習問題363
Xexpr.v2のすべての要素はSymbolで始まるが、あるものは属性のリストが続き、そしてあるものはXexpr.v2のリストだけが続く。Xexpr.v2の定義を再定義して、共通の開始を分離し、異なる種類の終了を強調しなさい。

Xexpr.v2からList-ofの使用をなくしてください。■


練習問題364
このXMLデータをXexpr.v2の要素で表現せよ。

    <transition from="seen-e" to="seen-f" />。

    <ul><li><word /></li><li><word /></li></ul>。

Xexpr.v0とXexpr.v1ではどちらが表現できるのでしょうか？■


練習問題365
Xexpr.v2の以下の要素をXMLデータとして解釈せよ。

'(server ((name "example.org")))

'(carcas (board (grass)) (player ((name "sam"))))

'(start)

Xexpr.v0やXexpr.v1の要素はどれですか？■


大雑把に言えば、X式はリストによって構造をシミュレートしている。このシミュレーションはプログラマにとって便利なもので、キーボード入力の量を最小限にすることができます。例えば、X式に属性リストがない場合、それは単に省略される。このデータ表現の選択は、このような式を手動で作成することと、自動的に処理することの間のトレードオフを意味する。後者の問題に対処する最良の方法は、X式を構造体のように見せる関数、特に準フィールドにアクセスする関数を提供することである。

   ・ 要素表現のタグを抽出する xexpr-name

   ・ 属性のリストを抽出する xexpr-attr

   ・ 内容(content)の要素のリストを抽出する xexpr-content

これらの関数があれば、リストを使って、あたかも構造型のインスタンスであるかのように振る舞うXMLを表現することができます。

これらの関数はS式を解析するものですが、パーサーは設計するのが難しいものです。そこで、いくつかのデータの例から、注意深く設計してみましょう。

(define a0 '((initial "X")))
 
(define e0 '(machine))
(define e1 `(machine ,a0))
(define e2 '(machine (action)))
(define e3 '(machine () (action)))
(define e4 `(machine ,a0 (action) (action)))


最初の定義は属性のリストを導入します。これはX式の構築で2回再利用されます。e0の定義は、X式が属性と内容のどちらかを持っていない可能性があることを思い出させる。e2とe3が基本的に等価である理由を読者は説明できるはずです。

次に、署名、目的文、ヘッダーを策定します。

    ; Xexpr.v2 -> [List-of Attribute]
    ; xeから、属性のリストを取得する。
    (define (xexpr-attr xe) '())

ここでは、xexpr-attrに焦点を当て、他の2つは練習問題として残すことにする。

関数の例を構成するには、属性のないX式から属性を抽出することに関する決定が必要です。我々の選んだ表現では、欠落した属性は完全に除去されるが、XMLの構造ベースの表現では'()を供給しなければならない。したがって、この関数はそのようなX式に対して'()を生成する。

(check-expect (xexpr-attr e0) '())
(check-expect (xexpr-attr e1) '((initial "X")))
(check-expect (xexpr-attr e2) '())
(check-expect (xexpr-attr e3) '())
(check-expect (xexpr-attr e4) '((initial "X")))


いよいよテンプレートの開発です。Xexpr.v2のデータ定義は複雑なので、我々はゆっくり一歩一歩進めます。まず、データ定義では2種類のX式を区別しているが、どちらの節もsymbolをリストにconsすることで構築されるデータを記述している。次に、この2つの節を区別するのは、リストの残りの部分であり、特に属性のリストがオプションで存在することである。これらの2つの洞察をテンプレートに変換してみよう。

(define (xexpr-attr xe)
  (local ((define optional-loa+content (rest xe)))
    (cond
      [(empty? optional-loa+content) ...]
      [else ...])))
         

上のローカル定義では、X式の名前が切り落とされ、残りのリストが残されます。このリストは、属性のリストで始まることもあれば、そうでないこともあります。重要なのは、それが単なるリストであり、2つのcond句がそれを示していることである。第三に、このリストは自己参照によって定義されるのではなく、X式の空かもしれないリストにいくつかの属性をオプショナルにconsすることで定義されます。言い換えれば、我々はまだ2つの通常のケースを区別し、通常の部分を抽出する必要がある。

 (define (xexpr-attr xe)
  (local ((define optional-loa+content (rest xe)))
    (cond
      [(empty? optional-loa+content) ...]
      [else (... (first optional-loa+content)
             ... (rest optional-loa+content) ...)])))


この時点で、すでに再帰は必要ないことがわかります。そこで、設計レシピの5番目のステップに切り替わります。明らかに、与えられたX式に名前以外何も付いていなければ、属性は存在しません。2番目の節では、リストの最初の項目が属性のリストなのか、それとも単なるXexpr.v2なのかが問題になる。これは複雑に思えるので、我々はウィッシュを作ります。

    ; [List-of Attribute] または Xexpr.v2 -> ?？
    ; xが[List-of Attribute]の要素であるかどうかを判定する。
    ; そうでない場合は#false
    (define (list-of-attributes? x)
       #false)

この関数で、xexpr-attrを完成させるのは簡単である；図126を参照。最初の項目が属性のリストであれば、この関数はそれを生成し、そうでなければ属性は存在しない。

---
(define (xexpr-attr xe)
  (local ((define optional-loa+content (rest xe)))
    (cond
      [(empty? optional-loa+content) '()]
      [else
       (local ((define loa-or-x
                 (first optional-loa+content)))
         (if (list-of-attributes? loa-or-x)
             loa-or-x
             '()))])))

    図126:xexpr-attrの完全な定義
---

List-of-Attributes?の設計についても、同じように進めると、次のような定義が得られる。

    ; [List-of Attribute] or Xexpr.v2 -> Boolean
    ;  x は属性のリストか？
    (define (list-of-attributes? x)
      (cond
        [(empty? x) #true]
        [else
         (local ((define possible-attribute (first x)))
           (cons? possible-attribute))]))

設計プロセスの詳細は、さして取り立てるほどのこともないので省略します。注目すべきは、この関数のシグネチャです。一つのデータ定義を可能な入力として指定する代わりに、シグネチャーは、"または"で分割された2つのデータ定義を結びつけています。 ISL+では、このような非公式で明確な意味を持つシグネチャが許容される場合がある。


練習問題366
xexpr-nameとxexpr-contentを設計せよ。■


練習問題367
設計レシピは xexpr-attr のテンプレートに自己言及を要求している。この自己参照をテンプレートに追加し、完成した解析関数がそれを含んでいない理由を説明せよ。■


練習問題368
list-of-attributes? 関数の定義について、非公式な "or"を使ったシグネチャを置き換えるデータ定義を策定しなさい。■


練習問題369
find-attrを設計せよ。この関数は、属性のリストとsymbolを受け取ります。属性リストがsymbolと文字列を関連付けている場合、関数はこの文字列を取得し、そうでない場合は #false を返します。assq を調べ、それを使って関数を定義しなさい。■


この章の残りの部分では、XexprはXexpr.v2を指す。また、xexpr-name、xexpr-attr、xexpr-contentが定義されているものとします。最後に、演習369のfind-attrを使用して属性値を取得する。



22.2 XML列挙のレンダリング

XMLは、実は言語の家族です。人々は、特定の通信経路のための方言を定義します。例えば、XHTMLはXML形式のウェブコンテンツを送信するための言語である。このセクションでは、XHTML の小さな断片、特にこの章の冒頭にある列挙のためのレンダリング関数を設計する方法を説明します。

ulタグは、いわゆる順序がないHTMLリストを囲むものです。このリストの各項目はliでタグ付けされており、そのliタグは言葉だけでなく、他の要素、さらには列挙体も含む傾向があります。"順序がないHTML"が意味するのは、各項目が数字の代わりに先頭のビュレット(bullet)で表示されることです。

Xexprにはプレーンな文字列が付属していないので、XHTMLの列挙をサブセットでどのように表現するかはすぐにはわからない。一つの選択肢はデータ表現をもう一回洗練させて、XexprがStringになるようにすることである。もう一つの選択肢は、テキストの表現を導入することである。

    ; XWord は '(word ((text String))' である。

ここでは、この2番目の選択肢を使います。Racketには、XexprにStringを含むライブラリが用意されています。


練習問題370
XWords の例を 3 つ作りなさい。ある ISL+ 値が XWord にあるかどうかをチェックする word? と、 XWord のインスタンスの 唯一の? 属性の値を抽出する word-text を設計しなさい。■


練習問題371
Xexprの定義を改良して、列挙の項目を含むXML要素をプレーンな文字列で表現できるようにしなさい。■


単語の表現があれば、XHTML形式の単語の列挙を表現するのは簡単である。

; An XEnum.v1 is one of: 
; - (cons 'ul [List-of XItem.v1])
; - (cons 'ul (cons Attributes [List-of XItem.v1]))
; An XItem.v1 is one of:
; - (cons 'li (cons XWord '()))
; - (cons 'li (cons Attributes (cons XWord '())))


データ定義の完全性のために、属性リストが含まれる(属性リストは表示には影響しないが)。

ストップ! XEnum.v1 のすべての要素が XExpr にもあることを論証してください。

XEnum.v1のサンプルエレメントを示します。

(define e0
  '(ul
    (li (word ((text "one"))))
    (li (word ((text "two"))))))


これは、この章の冒頭にある例の内側の列挙に対応するものです。これを2htdp/imageライブラリの助けを借りてレンダリングすると、次のような画像になります。

    （画像のため省略）

ビュレットの半径やビュレットと文字の距離は美学の問題であり、ここではアイデアが重要なのです。

このようなイメージを作るには、このISL+のプログラムを使うといいかもしれません：

（我々はこれらの表現を(DrRacketの)インタラクション領域で開発しました。あなたならどうしますか？）

(define e0-rendered
  (above/align
   'left
   (beside/align 'center BT (text "one" 12 'black))
   (beside/align 'center BT (text "two" 12 'black))))

ここで、BTがビュレットのレンダリングであると仮定しています。

それでは、この関数を注意深く設計してみましょう。データ表現には2つのデータ定義が必要なので、設計レシピでは2つの関数を並行して設計しなければならないことになっています。しかし、もう一度見てみると、この場合、2つ目のデータ定義は1つ目のデータ定義から切り離されており、別々に扱うことができることがわかります。

さらに、XItem.v1の定義は二つの節から構成されている。つまり、この関数自体は二つの節を持つcondから構成されているはずである。しかし、XItem.v1をXexprのサブ言語と見なすポイントは、この2つの節をXexprのセレクタ関数、特にxexpr-contentで考えることである。この関数を使うと、属性があるかないかに関係なく、アイテムのテキスト部分を抽出することができます。

    ; XItem.v1 -> Image
    ;アイテムを、ビュレットを先頭にした「単語」として表示(render)する。
    (define (render-item1 i))
      (... (xexpr-content i) ...))

一般に、xexpr-contentはXexprのリストを抽出する。この特定のケースでは、リストはちょうど1つのXWordを含み、この単語は1つのテキストを含む。

(define (render-item1 i)
  (local ((define content (xexpr-content i))
          (define element (first content))
          (define a-word (word-text element)))
    (... a-word ...)))

ここからは容易です。

(define (render-item1 i)
  (local ((define content (xexpr-content i))
          (define element (first content))
          (define a-word (word-text element))
          (define item (text a-word 12 'black)))
    (beside/align 'center BT item)))


アイテムに表示するテキストを抽出したら、それをテキストとしてレンダリングし、先頭のビュレットを付けるだけです。この最後のステップについては、上記の例を参照してください。


練習問題372

この先を読む前に、render-item1 の定義にテストを追加してください。これらのテストは、BT定数に依存しないように定式化することを確認してください。次に、この関数がどのように動作するかを説明してください。この関数が何を行うかについて目的の声明で説明されていることに留意してください。■



ここで、列挙を表示する関数の設計に焦点を当てることができる。先ほどの例を使えば、最初の2つの設計ステップは簡単です。

    ; XEnum.v1 -> Image
    ; 単純な列挙を画像として表示する。
    (check-expect (render-enum1 e0) e0-rendered)
    (define (render-enum1 xe) empty-image)

重要なステップは、テンプレートの開発です。データ定義によれば、XEnum.v1の要素には1つの興味深いデータ、すなわち（XML要素の）表現が含まれています。最初の項目は常に 'ul なので抽出する必要はなく、2番目のオプションの項目は属性のリストであるが、これは無視します。このことを念頭に置くと、最初のテンプレート案はrender-item1用のものと同じように見える。

    (define (render-enum1 xe))
      (... (xexpr-content xe) ...)) ; [List-of XItem.v1].

データ指向の設計レシピでは、複雑な形式のデータに遭遇したときはいつでも別の関数を設計するように指示しますが、抽象化に基づく設計レシピでは、既存の抽象化、たとえば図95と96のリスト処理関数を可能な限り再利用するように指示します。render-enum1がリストを処理し、そこから1枚の画像を作成することになっているとすると、そのシグネチャーに合うリスト処理抽象化関数はfoldrとfoldlの2つだけである。それらの目的の声明を調べてみると、特にfoldrについては、上記のe0-renderedの例と同じようなパターンが見えてきます。再利用設計のレシピにしたがって、それを使ってみましょう。

(define (render-enum1 xe)
   (local ((define content (xexpr-content xe))
           ; XItem.v1 Image -> Image 
           (define (deal-with-one item so-far)
              ...))
     (foldr deal-with-one empty-image content)))


タイプマッチングから、そのこともわかっているはずです。

    1. foldrの第1引数は2引数の関数でなければならない。

    2. 第2引数は画像でなければならない。

    3. 最後の引数はXMLコンテンツを表すリストである。

当然ながら、empty-imageが正しい出発点です。

この「再利用による設計」は、リストの上に「折り畳まれる」関数に注目します。これは、1つのアイテムとfoldrがこれまで作ってきた画像を別の画像に変えるのです。deal-with-oneのシグネチャーはこの洞察を明確にしています。最初の引数はXItem.v1なので、render-item1がそれをレンダリングする関数です。これは、最初のアイテムの画像と残りのアイテムの画像という、組み合わせなければならない2つの画像を生成します。それらを積み重ねるために、関数 above/align を使用します。

(define (render-enum1 xe)
  (local ((define content (xexpr-content xe))
          ; XItem.v1 Image -> Image 
          (define (deal-with-one item so-far)
            (above/align 'left
                          (render-item1 item)
                          so-far)))
    (foldr deal-with-one empty-image content)))


--
   XItem.v2 は以下のいずれかである。
   ; - (cons 'li (cons XWord '()))
   ; - (cons 'li (cons [List-of Attribute] (list XWord)))
   ; - (cons 'li (cons XEnum.v2 '()))
   ; - (cons 'li (cons [List-of Attribute] (list XEnum.v2)))

   ; XEnum.v2は以下のいずれかである。
   ; - (cons 'ul [List-of XItem.v2]) 
   ; - (cons 'ul (cons [List-of Attribute] [List-of XItem.v2]]))

    図127：XML列挙型の現実的なデータ表現
--

フラットな列挙は一般的ですが、本格的なケースの単純な近似でもあります。現実の世界では、ウェブブラウザーはウェブ上で届く任意に入れ子された列挙に対処しなければならない。XMLとそのWebブラウザーの方言であるXHTMLでは、入れ子は簡単です。どの要素も他の要素のデータ(content)として表示される可能性があります。我々の限定されたXHTML表現でこの関係を表現するには、項目は単語か別の列挙であると言います。図127は、データ定義の2回目の改訂を表示する。これは、最初の定義が正しい形式の項目を参照するように、列挙のためのデータ定義の改訂を含む。
　(この問題を解決するために、「任意の入れ子」という考え方が正しいかどうか、疑問をお持ちではありませんか？もしそうなら、3レベルの入れ子しか許さないデータ定義を開発し、それを使ってください)


--
(define SIZE 12) ; font size 
(define COLOR "black") ; font color 
(define BT ; a graphical constant 
  (beside (circle 1 'solid BLACK) (text " " SIZE COLOR)))
 
; Image -> Image
; marks item with bullet  
(define (bulletize item)
  (beside/align 'center BT item))
 
; XEnum.v2 -> Image
; renders an XEnum.v2 as an image 
(define (render-enum xe)
  (local ((define content (xexpr-content xe))
          ; XItem.v2 Image -> Image 
          (define (deal-with-one item so-far)
            (above/align 'left (render-item item) so-far)))
    (foldr deal-with-one empty-image content)))
 
; XItem.v2 -> Image
; renders one XItem.v2 as an image 
(define (render-item an-item)
  (local ((define content (first (xexpr-content an-item))))
    (bulletize
      (cond
        [(word? content)
         (text (word-text content) SIZE BLACK)]
        [else (render-enum content)]))))

    図 128:データ定義の精緻化に合わせた関数の精緻化
--


次の問いは、このデータ定義の変更がレンダリング関数にどのような影響を与えるかである。言い換えれば、render-enum1 と render-item1 をそれぞれ XEnum.v2 と XItem.v2 に対応するように修正する必要がある。ソフトウェアエンジニアは、常にこのような問題に直面しており、このような状況でもデザインレシピが威力を発揮する。

図128に完全な答えを示します。変更は XItem.v2 のデータ定義に限定されているので、レンダリング プログラムへの変更がアイテムをレンダリングする関数に現れることは驚くことではありません。render-item1はXItem.v1の異なる形式を区別する必要がないが、XItem.v2は2種類のアイテムをリストしているので、render-itemはcondを使用せざるを得なくなった。このデータ定義が実世界のものに近いことを考えると、区別する特徴は「'() vs cons」のような単純なものではなく、与えられたアイテムの特定の部分であることがわかる。項目の内容がXWordであれば、レンダリング機能は前と同じように進行する。XItem.v2 のデータ定義がまさにこの時点で XEnum.v2 を参照しているからである。


練習問題373
図128はテストケースが不足しています。すべての機能のテストケースを作成しなさい。■


練習問題374
図127のデータ定義はlistを使用しています。それらを cons を使用するように書き換えてください。そして、このレシピを使って XEnum.v2 と XItem.v2 のレンダリング関数をゼロから設計してください。図128と同じ定義ができるはずである。■


練習問題375
演習でのcondの折り返しは

        (beside/align 'center BT ...)

はあなたを驚かせるかもしれません。関数定義を編集して、回り込み(wrap-around)が各節に一度ずつ現れるようにします。なぜ、その変更がうまくいくと確信が持てるのですか？あなたはどちらのバージョンを好みますか？■


練習問題376
XEnum.v2 のインスタンスに含まれるすべての "hello" をカウントするプログラムを設計しなさい。■


練習問題377
列挙されたすべての "hello "を "bye "に置き換えるプログラムを設計しなさい。■


=====

22.3 ドメイン特化型言語

エンジニアは日常的に大規模なソフトウェアシステムを構築しており、それらを実行する前に特定のコンテキストに応じたコンフィギュレーションを必要とします。この設定作業は、多くの異なるソフトウェアシステムを扱わなければならないシステム管理者に任される傾向がある。「設定」という言葉は、プログラムがコマンドラインやジェスチャー（マウスのクリックやスワイプ）によって起動されたときに、メイン関数が必要とするデータのことを指します。ある意味、設定とは単なる追加引数ですが、通常は非常に複雑なので、プログラム設計者はファイル経由で渡すことを好みます。

ソフトウェア技術者は、システム管理者があらゆるプログラミング言語を知っていると想定できないため、シンプルで特殊な目的の設定言語を考案する傾向にある。このような特殊な言語はDSL（domain-specific language）とも呼ばれる。

(構成はさまざまなデータに対してプログラムを抽象化するため、Paul Hudakは1990年代にDSLは究極の抽象化、つまり抽象化の考えを完璧に一般化したものであると主張した)

このようなDSLを共通のコア、たとえばよく知られたXML構文で開発することで、システム管理者の生活は簡素化される。彼らは小さなXMLプログラムを書くことができ、それによって起動しなければならないシステムを構成することができる。

DSLの構築は上級プログラマの仕事と思われがちですが、実はあなたは既にそれなりに複雑なDSLを理解し、評価(appreciate)し、実装できる立場にあります。この節では、それがどのように機能するかを説明します。まず、有限状態マシン(FSM)を再認識してください。そして、任意のFSMをシミュレートするシステムを構成するための DSLを設計し、実装し、プログラミングする方法を示す。

有限状態機械の復習 有限状態機械は計算機における重要なテーマであり、本書でも何度か紹介してきた。ここでは、有限状態マシンの例を、設定DSLを設計・実装したいコンポーネントとして再利用する。

--
 ; FSMは[List-of-1Transition]である。
 ; 1Transitionは2つの項目からなるリストである。
 ; (cons FSM-State (cons FSM-State '())) ; (cons FSM-State '()))
 ; FSM-Stateは色を指定するStringである。
             
 ;データ例
 (define fsm-traffic
  '(("red" "green") ("green" "yellow") ("yellow" "red"))
             
 ; FSM-State FSM -> FSM-State
 ; プレイヤーによって押されたキーと与えられたFSMをマッチングする。
 (define (simulate state0 transitions)
  (big-bang state0 ; FSM-State
    [to-draw
      (lambda (current)
        (square 100 "solid" current))]
    [on-key
      (lambda (current key-event)
        (find transitions current))]))
             
 ; [X Y] [List-of [List X Y]] X -> Y
 ; alistの中の与えられたXにマッチするYを見つける。
 (define (find alist x)
   (local ((define fm (assoc x alist)))
     (if (cons? fm) (second fm) (error "not found")))

    図129:有限状態マシン、再訪
--


図129は、便宜上、リストだけを用いてISL+の能力をフルに発揮できるように再構成したものであるが、コード全体を再び示している。このプログラムは2つのデータ定義と1つのデータ例、そして2つの関数定義（simulateとfind）で構成されている。前の章の関連プログラムとは異なり、このプログラムは遷移を現在の状態と次の状態の2つの項目のリストとして表現している。

メイン関数であるsimulateは遷移表と初期状態を消費し、次にビッグバン式を評価し、各キーイベントに状態遷移で対応する。状態は色のついた四角形で表示される。to-draw 節と on-key 節はラムダ式で指定され、現在の状態と実際のキーイベントを消費し、それぞれ画像または次の状態を生成する。

そのシグネチャーが示すように、補助するfind関数はFSMアプリケーションから完全に独立している。この関数は2項目からなるリストと項目を消費しますが、項目の実際の性質はパラメータで指定されます。このプログラムでは、XとYはFSM状態を表し、findは状態と共に遷移表を消費し、状態を生成することを意味します。関数本体では、組み込みの assoc 関数を使って、ほとんどの処理を行います。assoc のドキュメントを調べて、local の本体がなぜ if 式を使うのかを理解してください。


練習問題378
レンダリング関数を変更して、色のついた四角の上に状態の名前を重ねるようにしなさい。■


練習問題379
findのテストケースを作成しなさい。■


練習問題380
1Transitionのデータ定義を変更し、特定のキー操作に遷移を限定できるようにしなさい。findが変更されずに動作し続けるように、変更を定式化してみてください。プログラム全体を動作させるために、他に何を変更する必要がありますか？設計レシピのどの部分がその答えになりますか？オリジナルの練習問題については、練習問題229を参照してください。■


コンフィギュレーション
 FSMシミュレーション機能は2つの引数を用いて、共同でマシンを記述します。潜在的な「顧客」にDrRacketでISL+プログラムを開いて2つの引数の関数を起動する方法を教えるよりも、simulateの「販売者」はこの製品に設定コンポーネントを追加することを希望するだろう。

コンフィギュレーションコンポーネントは2つの部分から構成されています。1つは、顧客がコンポーネントの主関数の初期引数を設定するために使用する、広く使われている簡単な言語です。もう一つは、顧客が言うことを主関数の関数呼び出しに変換する機能です。FSMシミュレータでは、有限状態機械をXMLでどのように表現するかについて合意する必要があります。賢明な計画により、"22.1 S式としてのXML"は、このタスクにちょうど良さそうな一連のマシンの例を提示する。このセクションの最後のマシンの例を思い出してください。

    <machine initial="red">
      <action state="red" next="green" />
      <action state="green" next="yellow" />
      <action state="yellow" next="red" />
    </machine>

図129の遷移表fsm-trafficと比較してみてください。また、この例で合意されたXexpr表現を思い出してください。

(define xm0
  '(machine ((initial "red"))
     (action ((state "red") (next "green")))
     (action ((state "green") (next "yellow")))
     (action ((state "yellow") (next "red")))))


まだ、FSMの可能なXexpr表現をすべて記述する一般的なデータ定義が不足しているのです。

    ; XMachineはこのような形状のネストしたリストである。
    ; (cons 'machine (cons `((initial ,FSM-State))  [List-of X1T]))

    ; X1Tはこの形状のネストされたリストである。
    ;  `(action ((state ,FSM-State) (next ,FSM-State)))

XEnum.v2のように、XMachineはすべてのXexprのサブセットを記述している。したがって、この新しい形式のデータを処理する関数を設計するとき、断片にアクセスするために一般的なXexpr関数を使用し続けることができる。


練習問題381
XMachine と X1T の定義には quote が使われているが、これは初心者のプログラム設計者には非常に不適切である。まず list を使い、次に cons を使うように書き換えてください。■


練習問題382
キーイベントごとに白から黒に切り替わるBWマシンのXML構成を作成しなさい。XMLの設定をXMachineの表現に変換してください。プログラムとしてのマシンの実装は、演習227を参照。■


コンフィギュレーション問題の翻訳の部分に踏み込む前に、その内容を整理しておこう。

    サンプル問題 XMachineの設定を使ってsimulateを実行するプログラムを設計してください。

この問題は我々の場合に特有のものであるが、同様のシステムに対して一般化することを考えることは容易なので、そうすることを勧めます。

問題の声明は、完全なアウトラインを示唆するものである。

    ; XMachine -> FSM-State
    ; 与えられた設定によりFSMをシミュレートする。
    (define (simulate-xmachine xm)
      (simulate ... ...))

問題の声明に続き、私たちの関数は、2つの決定すべき引数で simulate を呼び出す。この定義を完成させるために必要なのは、初期状態と遷移表の2つです。この2つはxmの一部であり、適切な関数をウィッシュ(wish)するのが最善です。

    xm-state0 は、与えられたXMachineから初期状態を抽出する。

      (check-expect (xm-state0 xm0) "red")

    xm->transitionsは埋め込まれているX1Tのリストを1Transitionsのリストに変換する。

      (check-expect (xm->transitions xm0) fsm-traffic)

--
    ; XMachine -> FSM-State
    ; 与えられた設定をステートマシンとして解釈する
    (define (simulate-xmachine xm)
      (simulate (xm-state0 xm) (xm->transitions xm)))
    
    ;XMachine -> FSM-State
    ;xm0から遷移表を抽出し、翻訳する。 <-???
    
    (check-expect (xm-state0 xm0) "red")
    
    (define (xm-state0 xm0))
      (find-attr (xexpr-attr xm0) 'initial))
    
    ; XMachine -> [List-of 1Transition] とする。
    ; xmからトランジションテーブルを抽出する。
    
    (check-expect (xm->transitions xm0) fsm-traffic)
    
    (define (xm->transitions xm)
      (local (; X1T -> 1Transition)
              (define (xaction->action xa)
                (list (find-attr (xexpr-attr xa) 'state))
                      (find-attr (xexpr-attr xa) 'next)))
        (map xaction->action (xexpr-content xm)))

    図130：DSLプログラムの解釈
--


XMachineはXexprのサブセットであるから、xm-state0を定義するのは簡単である。初期状態が属性として指定されると、xm-state0はxexpr-attrを使用して属性のリストを抽出し、次に 'initial 属性の値を取得する。

次にxm->transitionsで、XMachineのコンフィギュレーション内の遷移を遷移表に変換します。

    ; XMachine -> [List-of 1Transition] 
    ; xmから抽出＆翻訳して遷移表を作る。
    (define (xm->transitions xm)
     '())

関数名はシグネチャーを規定し、目的の声明を提案します。この目的の声明では、2段階の処理を記述しています。(1)遷移のXexpr表現を抽出し、(2)それらを[List-of 1Transition]のインスタンスに変換する。

抽出部分は当然xexpr-contentを使ってリストを取得するが、遷移の部分はもう少し分析が必要です。XMachineのデータ定義に戻ると、XexprのデータはX1Tのリストであることがわかる。シグネチャーから遷移表が1Transitionsのリストであることがわかる。実際、前者のリストの各項目が後者の1項目に変換されることは極めて明白であり、mapの使用を示唆している。

    (define (xm->transitions xm))
      (local (; X1T -> 1Transition)
              (define (xaction->action xa)
                 ...))
        (map xaction->action (xexpr-content xm)))

見ての通り、"16.5 例による抽象化の利用" の設計思想に従って、関数はmapを使用するローカルな関数として定式化されています。xaction->actionを定義するのも、Xexprから適切な値を取り出すだけである。

図130に完全な解決策を示す。ここでは、DSLから適切な関数呼び出しへの変換が、元のコンポーネントと同じ大きさになっています。これは現実のシステムには当てはまらない。DSLコンポーネントは製品全体のごく一部であることが多いので、このアプローチは非常に人気があるのだ。


練習問題383
図130のコードを演習382のBW Machine構成で実行しなさい。■


--
                    machine-configuration.xml
                         
                          <machine initial="red">
                           <action state="red" next="green" />
                           <action state="green" next="yellow" />
                           <action state="yellow" next="red" />
                          </machine>。
                         
    図 131：マシンコンフィギュレーションを含むファイル
--


=====

22.4 XMLの読み込み

システム管理者は、洗練されたアプリケーションが設定プログラムを読み込むことを期待しています。ISL+では、あなたのプログラムは（いくつかの）XML情報を取得することができます。図132はティーチパックから関連する部分を抜粋したものです。一貫性を保つために、この図は、バージョン2が存在しないデータ定義を含むXML表現に.v3という接尾辞を使用している。

（このセクションでは、2htdp/batch-io 2htdp/universe と 2htdp/image ライブラリを使用しています)


    ; Xexpr.v3は、以下のいずれかである。
    ;  - Symbol
    ;  - String
    ;  - Number
    ;  - (cons Symbol (cons Attribute*.v3 [List-of Xexpr.v3]))
    ;  - (cons Symbol [List-of Xexpr.v3])
    ;
    ; Attribute*.v3 は [List-of Attribute.v3] である。
    ;
    ; Attribute.v3は2つの項目からなるリストである。
    ; (list Symbol String)

--
    ; Any -> Boolean
    ; x は Xexpr.v3 か？
    ; 効果： x が Xexpr.v3 でない場合、#false を返す。
    (define (xexpr? x) ...)
    
    ; String -> Xexpr.v3
    ; ファイル f の最初のXML要素を生成する。
    (define (read-xexpr f) ...)
    
    ; String -> Boolean
    ; このURLが'404'を返したら#false; そうでなければ#true
    (define (url-exists? u) ...)
    
    ; String -> [Maybe Xexpr.v3].
    ; URL uから最初のXML(HTML)要素を取得する。
    ; #false if (not (url-exists? u))
    (define (read-plain-xexpr/web u) ...)
    
    ; String -> [Maybe Xexpr.v3].
    ; URL uから最初のXML(HTML)要素を取得する。
    ; もし (not (url-exists? u)) が真なら、#falseを返す
    (define (read-xexpr/web u) ...)

    図 132:X-expressionsの読み込み
--

図131のようなファイルがあるとする。2htdp/batch-ioライブラリが必要な場合、プログラムはread-plain-xexprで要素を読み込むことができます。この関数は、XMachineのデータ定義に合致した形式でXML要素を取得します。WebからXML要素を取得する関数もティーチパックで提供されています。DrRacketで試してみてください。

> (read-plain-xexpr/web
    (string-append
       "Https://Felleisen.org/"
       "matthias/"
       "HtDP2e/Files/machine-configuration.xml"))


あなたのコンピューターがウェブに接続されている場合、この式は私たちの標準的なマシン構成を取得します。

ファイルやウェブページを読むことは、私たちの計算モデルにまったく新しいアイデアを導入することになります。Intermezzo 1: Beginning Student Language が説明するように、BSLプログラムは代数学で変数式を評価するのと同じ方法で評価されます。関数定義も代数学と同じように扱われます。実際、ほとんどの代数学のコースでは条件付き関数の定義が導入されているので、condも特に問題はない。最後に、ISL+では関数を値として導入しているが、評価モデルは基本的に同じである。

この計算モデルの本質的な特性は、ある引数aに対して関数fを何度呼び出しても ...

    (f a ...）

答えは同じである。しかし、read-fileやread-xexpr、およびの親族（の関数）が導入されると、この性質が破壊されます。問題は、ファイルやウェブサイトが時間とともに変化し、プログラムがファイルやウェブサイトを読み込むたびに新しい結果を得る可能性があることです。

ある企業の株価を調べることを考えてみよう。ブラウザーでgoogle.com/financeなどの金融サイトにアクセスし、好きな会社、例えばフォードの名前を入力する。すると、その企業の現在の株価や、前回掲載時からどれだけ価格が変動したか、現在の時刻など、さまざまな情報が表示される。重要なのは、1日、1週間と時間をかけてこのページを読み込むと、掲載されている情報の一部が変化していくことです。

このような会社情報を手動で調べる代わりに、そのような情報を定期的に、例えば15秒ごとに取得する小さなプログラムを書くことができます。ISLを使えば、このタスクを実行するワールドプログラムを書くことができます。このようなプログラムを起動します。

    > (stock-alert "Ford")


をクリックすると、以下のような画像が表示されるワールドウィンドウが表示されます

    17.09 +.06


このようなプログラムを開発するには、通常のプログラム設計以上のスキルが必要です。まず、そのWebサイトがどのような情報構造になっているかを調べる必要がある。Googleの金融サービスのページの場合、ソースコードを見てみると、トップページに次のようなパターンがあることがわかる。

      <meta content="17.09" itemprop="price" />
      <meta content="+0.07" itemprop="priceChange" />
      <meta content="0.41" itemprop="priceChangePercent"/>
      <meta content="2013-08-12T16:59:06Z" itemprop="quoteTime"/>
      <meta content="NYSE real-time data" itemprop="dataSource" />


Xexpr.v3を検索して、属性値「price」と「priceChange」を持つmeta要素（XMLの表現）を抽出する機能があれば、残りのstock-alertは簡単にできる。

--
(define PREFIX "Https://www.google.com/finance?q=")
(define SIZE 22) ;フォントサイズ
             
(define-struct data [価格差])
; StockWorld は構造体である。(make-data String String)
             
; String -> StockWorld
; 15秒ごとにcoの株価とその変化を取得する
(define (stock-alert co)
  (local ((define url (string-append PREFIX co))
          ; [StockWorld -> StockWorld]
          (define (retrieve-stock-data __w)
            (local ((define x (read-xexpr/web url)))
              (make-data (get x "price")
                         (get x "priceChange"))))
          ; StockWorld -> Image 
          (define (render-stock-data w)
            (local (; [StockWorld String -> String] -> Image
                    (define (word sel col)
                      (text (sel w) SIZE col)))
              (overlay (beside (word data-price 'black)
                               (text "  " SIZE 'white)
                               (word data-delta 'red))
                       (rectangle 300 35 'solid 'white)))))
    (big-bang (retrieve-stock-data 'no-use)
      [on-tick retrieve-stock-data 15]
      [to-draw render-stock-data])))

    図133:イベントとしてのウェブデータ
--

(ウェブサービスが株価を配信しなくなったため、この演習を完了することはできなくなりました。)

図133は、プログラムの核となる部分を表示したものです。getの仕組みは、データの絡み合いが全てなので、設計は演習に任せる。

図に示すように、main関数は、クロックティックハンドラとレンダリング関数の2つのローカルなものを定義している。ビッグバンの仕様では、クロックは15秒ごとに刻むことが要求されている。ISL+は時計が鳴ると、現在の世界に対してretrieve-stock-dataを適用するが、これは無視される。その代わり、この関数はread-xexpr/webでWebサイトを訪問し、getで適切な情報を抽出する。このように、新しい世界はローカルなデータではなく、ウェブ上の新しく利用可能になった情報から作られる。


練習問題384
図133はread-xexpr/webについて触れています。そのシグネチャーと目的の声明については図132を参照し、そのドキュメントを読んで相対するplainとの違いを判断してください。

図133には、いくつかの重要なピース、特にデータの解釈とローカルに定義されたすべての関数の目的の声明も欠けています。プログラムを理解するために、欠けている部分を定式化してください。■


練習問題385
Googleの金融サービスのページで、自分の好きな会社の現在の株価を調べてみよう。もし、好きな会社がなければ、フォードを選んでください。そして、そのページのソースコードを作業ディレクトリにファイルとして保存してください。DrRacket の read-xexpr を使って、ソースを Xexpr.v3 として表示してください。■


練習問題386
以下はget関数です。

 ; Xexpr.v3 String -> String
 ; 属性 "itemprop" が値 s を持つmeta要素から "content "属性の値を取得する。
 (check-expect
   (get '(meta ((content "+1") (itemprop "F"))) "F")
   "+1")
 
 (define (get x s)
   (local ((define result (get-xexpr x s)))
     (if (string? result)
         result
         (error "not found"))))


任意のXexpr.v3から目的の属性を検索し、[Maybe String]を生成する関数、get-xexprの存在を仮定しています。

"F"以外の値を探し、強制的にエラーを知らせるようなテストケースを作成せよ。

get-xexprを設計する。この関数の関数例をgetの関数例から導出する。これらの例を一般化して、get-xexpr が任意の Xexpr.v3 をトラバースできると確信できるようにしなさい。最後に、練習問題385で保存したWebデータを使ったテストを作成しなさい。■



23 同時処理

ある種の関数は、自明ではないデータ定義を持つクラスに属する2つの引数を消費しなければなりません。このような関数をどのように設計するかは、引数間の関係によって決まります。まず、どちらかの引数はアトミックであるかのように扱われなければならないかもしれません。次に、関数が2つの引数を同時に処理しなければならない可能性がある。最後に、関数は、与えられたデータをすべての可能なケースに対応させて処理することができます。本章では、この3つのケースを例として説明し、拡張設計のレシピを提供します。最後に、複合データの等価性について説明します。


=====

23.1 2つのリストを同時に処理する：ケース1

次のような署名、目的文、ヘッダーを考えてみましょう。

    ; [List-of Number] [List-of Number] -> [List-of Number]
    ; frontの最後の'()をendに置き換える
    (define (replace-eol-with front end)
      front)

シグネチャーは、この関数が2つのリストを消費することを示しています。この場合、設計レシピがどのように機能するかを見てみましょう。

まず、例題を通して作業します。第一引数が '() であれば、replace-eol-with は第二引数が何であろうとそれを（そのまま）生成しなければなりません。

    (check-expect (replace-eol-with '() '(a b)) '(a b))

一方、第1引数が'()でない場合、目的の声明ではfrontの末尾の'()をendに置き換えることが要求されています。

(check-expect (replace-eol-with (cons 1 '()) '(a))
              (cons 1 '(a)))
(check-expect (replace-eol-with
                (cons 2 (cons 1 '())) '(a))
              (cons 2 (cons 1 '(a))))

目的の声明と例題は、第2引数がリストである限り、この関数はそれについて何も知る必要がないことを示唆しています。暗に、そのテンプレートは最初の引数に関してリストを処理する関数のものであるべきだと言っているのです。

    (define (replace-eol-with front end))
      (cond
        [(empty? front)・・・]。
        [else
         (... (first front) ...
          ... (replace-eol-with (rest front) end) ...)])

デザインレシピの5番目のステップにしたがって、テンプレートにおけるギャップを埋めるようにします。frontが'()であれば、replace-eol-withはendを生成する。frontが'()でない場合、テンプレート式が何を計算するのかを思い出す必要がある。

  ・  (first front) はリストの最初の項目と評価されます。

  ・  (replace-eol-with (rest front) end) は (rest front) の最後の '() を end で置き換えます。

ストップ! 表で表す方法を使って、これらの箇条書きの意味を実行例で理解してください。


次は、完全な定義への小さな一歩です。

    (define (replace-eol-with front end))
      (cond
        [(empty? front) end] 
        [else
         (cons (first front)
               (replace-eol-with (rest front) end)])

演習 387.
Crosを設計してください。この関数は記号のリストと数値のリストを消費し、記号と数値の可能な限り順序付けられたペアを生成する。つまり、'(a b c) と '(1 2) が与えられたとき、期待される結果は '((a 1) (a 2) (b 1) (b 2) (c 1) (c 2))) となる。■


=====

23.2 2つのリストを同時に処理する：ケース2

「10.1 リストを生成する関数」で出てきた関数 wages* は、ある労働者の労働時間が与えられたときの週給を計算する関数です。この関数は、1週間の労働時間を表す数値のリストを消費し、それに対応する週給を表す数値のリストを生成する。この問題では、すべての従業員が同じ賃金を受け取っていると仮定しているが、小さな会社であっても、労働者には差別化された賃金が支払われています。

ここでは、もう少し現実的なバージョンを見てみましょう。この関数は2つのリストを消費します：働いた時間のリストとそれに対応する時間給のリストです。この修正された問題を修正されたヘッダに変換する。

    ; [List-of Number] [List-of Number] -> [List-of Number]
    ; 時間 と (賃金/時間)に対応する項目を掛け合わせる。
    ; 2つのリストが同じ長さであると仮定する
    (define (wages*.v2 hours wages/h))
      '())

例を作るのは簡単です。

    (check-expect (wages*.v2 '() '()) '())
    (check-expect (wages*.v2 (list 5.65) (list 40)))
                  (list 226.0))
    (check-expect (wages*.v2 '(5.65 8.75) '(40.0 30.0))
                  '(226.0 262.5))

必要にされることとして、3つの例ではすべて同じ長さのリストが使われています。

また、入力に関する仮定もテンプレートの開発に利用することができる。より具体的には、(empty? hours) は (empty? wages/h) が真であるときに真であり、さらに (cons? hours) は (cons? wages/h) が真であるときに真である、という条件である。したがって、2つのリストのうちどちらか一方にテンプレートを使ってもよいことになります。

(define (wages*.v2 hours wages/h)
  (cond
    [(empty? hours) ...]
    [else
     (... (first hours)
      ... (first wages/h) ...
      ... (wages*.v2 (rest hours) (rest wages/h)))]))


最初のcond節では、hoursとwages/hの両方が'()になっています。したがって、セレクタ式は必要ありません。2番目のcond節では、hoursとwages/hの両方がリストとして構成されているので、4つのセレクタ式が必要であることを意味する。最後に、最後の2つは同じ長さのリストなので、wages*.v2の自然再帰の候補を構成している。

このテンプレートの唯一の変わった点は、再帰的適用が2つの式からなり、両方とも2つの引数のセレクタ式であることです。しかし、この考え方は前提から直接的に導かれるものです。

ここから先は、完全な関数定義への短いステップとなる。

(define (wages*.v2 hours wages/h)
  (cond
    [(empty? hours) '()]
    [else
     (cons
       (weekly-wage (first hours) (first wages/h))
       (wages*.v2 (rest hours) (rest wages/h)))]))


最初の例では、最初のcond句の答えが'()であることを意味しています。2つ目の例では、3つの値が利用可能です。

    1. (first hours)で、週単位の最初の時間数を表します。

    2. (first wages/h)は、時間給の（リストの）最初の要素です。

    3. (wages*.v2 (rest hours) (rest wages/h)) は、目的のによれば、2つのリストの最初の要素を除いた残りの部分(rest)について週給のリストを計算することになります。

あとは、これらの値を組み合わせて、最終的な答えを出すだけです。例題にあるように、最初の従業員の週給を計算し、その賃金と残りの賃金からリストを作成する必要があります。

(cons (weekly-wage (first hours) (first wages/h))
      (wages*.v2 (rest hours) (rest wages/h)))

補助関数weekly-wageは、労働時間数と時間給から、一人の労働者の週給を計算するものである。

  ; Number Number -> Number
  ; computes the weekly wage from pay-rate and hours
  (define (weekly-wage pay-rate hours)
    (* pay-rate hours))

ストップ! 一人の労働者の賃金を計算したい場合、どの関数を使用する必要がありますか？所得税を処理する場合、どの関数を変更する必要がありますか？


練習問題388
現実の世界では、wages*.v2は従業員構造体のリストとworkレコードのリストを消費します。従業員構造体は、従業員の名前、社会保障番号、賃金率などを含んでいる。workレコードは、従業員の名前と1週間の労働時間数を含んでいる。結果は、従業員の名前と週給を含む構造体のリストである。

これらの現実的なバージョンのデータで動作するように、このセクションのプログラムを修正します。必要な構造型定義とデータ定義を提供する。設計レシピを使用して、修正プロセスを進めてください。■


練習問題389
文字列として表される名前のリストと、同じく文字列である電話番号のリストを消費する関数 zip を設計しなさい。この関数はこれらの同じ長さのリストを組み合わせて、以下のphone-recordのリストにします。

(define-struct phone-record [name number])
; A PhoneRecord is a structure:
;   (make-phone-record String String)

対応するリスト項目は同一の人物に属すると仮定してください。■



23.3 2つのリストを同時に処理する。ケース3

ここで、3つ目のタイプの問題を紹介します。

    サンプル問題 Symbolのリストlosと自然数nが与えられたとき、関数list-pickはlosからn番目の記号を抽出する。該当するようなSymbolがない場合、この関数はエラーを知らせる。

問題は、設計レシピがlist-pickの設計にどれだけ有効かです。

記号のリストのデータ定義はもうすっかりおなじみだが、「9.3 自然数」の自然数のクラスを思い出してほしい。

    ; Nは以下のいずれかである。
    ; - 0
    ; - (add1 N)

これで第2段階に進むことができます。

    ; [List-of Symbol] N -> Symbol
    ; lからn番目のsymbolを取り出す。
    ; そのようなsymbolがない場合はエラーを知らせる
    (define (list-pick l n)
      'a)

記号のリストも自然数も、複雑なデータ定義を持つクラスです。この組み合わせは問題を非標準的なものにします。つまり、設計レシピのすべてのステップで細部にまで注意を払わなければならないのです。

この時点で、通常、いくつかの入力例を選び、望ましい出力が何であるかを考える。まず、関数が完璧に動作しなければならない入力として、'(a b c)と2があります。3つのsymbolからなるリストとインデックス2に対して、list-pickはsymbolを返さなければなりません。問題は、それが'b'なのか'c'なのかである。小学生の頃なら、1、2と数えて、迷わずbを選んだだろう。しかし、これはコンピュータサイエンスであって、小学校ではない。0から数えるとcも同じように適切な選択である。そしてこの本では後者を使う。

    (check-expect (list-pick '(a b c) 2) 'c)

さて、このlist-pickの細かいポイントを排除した上で、実際の問題である入力の選択について見てみよう。例のステップの目標は、入力空間をできるだけカバーすることである。複雑な形式のデータの記述では、1つの節につき1つの入力を選ぶことでそれを実現する。ここでは、各データ定義には2つの節があるため、各クラスから少なくとも2つの要素を選ぶことをこの手順は示唆している。最初の引数には '() と (cons 'a '()) を選び、後者には 0 と 3 を選びます。結局のところ、2つの引数の間にはすぐにわかるような関係はなく、シグネチャにも制限はないのです。

結局、正しい結果が得られるのは1つだけで、残りの組み合わせは、リストに十分な数の記号がないため、存在しない位置を選んでしまうのです。

    (check-error (list-pick '() 0) "list too short")
    (check-expect (list-pick (cons 'a '()) 0) 'a)
    (check-error (list-pick '() 3) "list too short")


この関数はエラーを通知することが期待されており、ここで好きなメッセージを選びます。

ストップ! これらの断片をDrRacketの定義域に入れ、部分プログラムを実行してください。

例題に関する議論から、関数の設計のために検査しなければならない独立した4つのケースが実際に存在することがわかります。これらのケースを発見する一つの方法は、各項に対する条件を2次元の表に並べることである。

        |(empty? l)        (cons? l)
---------------------------------------
(= n 0) |
        |
(> n 0) |

表の横軸は list-pick がリストについて問わなければならない問題、縦軸は自然数について問わなければならない問題である。このように並べると、自然に4つの正方形ができ、それぞれが横軸と縦軸の両方の条件が成立する場合を表している。

この表から、関数テンプレートのcondには4つの節があることがわかる。表中の各ボックスに対して、水平方向と垂直方向の条件の論理積をとることで、各項に適切な条件を把握することができる。

        |(empty? l)        (cons? l)
---------------------------------------
(= n 0) |(and (empty? l)   (and (cons? l)
        |      (= n 0))         (= n 0))
  
(> n 0) |(and (empty? l)   (and (cons? l)
        |      (> n 0))         (> n 0))

テンプレートのcondのアウトラインは、この表を条件に変換したものに過ぎない。

(define (list-pick l n)
  (cond
    [(and (= n 0) (empty? l)) ...]
    [(and (> n 0) (empty? l)) ...]
    [(and (= n 0) (cons? l)) ...]
    [(and (> n 0) (cons? l)) ...]))


いつものようにcond式で4つの可能性を区別し、それぞれのcond句にセレクタ式を追加することで、それぞれに焦点を当てることができます。

(define (list-pick l n)
  (cond
    [(and (= n 0) (empty? l))
     ...]
    [(and (> n 0) (empty? l))
     (... (sub1 n) ...)]
    [(and (= n 0) (cons? l))
     (... (first l) ... (rest l)...)]
    [(and (> n 0) (cons? l))
     (... (sub1 n) ... (first l) ... (rest l) ...)]))


第一引数lはリストであり、空でないリストに対するtemplateのcond句は二つのセレクタ式を含む。第二引数nは(上記の)Nに属し、0でない数に対するテンプレートの cond句は一つのセレクタ式を必要とするだけである。(empty? l)または(= n 0)が成立する場合、それぞれの引数はアトミックであり、対応するセレクタ式は必要ない。

テンプレート構築の最後のステップでは、セレクタ式の結果が入力と同じクラスに属するような再帰をテンプレートに注釈することが要求されます。この最初の例では、両引数のセレクタ式を含む最後のcond節に注目する。しかし、どのように自然な再帰を形成するかは不明である。もし、この関数の目的を無視すれば、3つの再帰が可能である。

1. (list-pick (rest l) (sub1 n))

2. (list-pick l (sub1 n))

3. (list-pick (rest l) n)

それぞれ、使える表現の中から実現可能な組み合わせを表しています。どれが重要なのか、3つとも重要なのかは分からないので、次の開発段階へ進むことになる。

--
; [List-of Symbol] N -> Symbol
; lからn番目のsymbolを取り出す。
; そのようなsymbolがない場合はエラーを知らせる
(define (list-pick l n)
  (cond
    [(and (= n 0) (empty? l))
     (error 'list-pick "list too short")]
    [(and (> n 0) (empty? l))
     (error 'list-pick "list too short")]
    [(and (= n 0) (cons? l)) (first l)]
    [(and (> n 0) (cons? l)) (list-pick (rest l) (sub1 n))]))

    図 134：リストへのインデキシング (indexing into a list)
--

第5段階の設計レシピに従って、テンプレートの各cond節を分析し、適切な答えを決めましょう。

    1. もし (and (= n 0) (empty? l)) が成り立つなら、list-pickは空のリストから最初のsymbolを選ばなければならず、これは不可能です。答えはエラーシグナルでなければならない。

    2. もし (and (> n 0) (empty? l)) が成立する場合、list-pickは再び空のリストからsymbolを選ぶように要求されます。

    3. もし、(and (= n 0) (cons? l)) が成立する場合、list-pickはlから最初のsymbolを生成することになっており、セレクタ式 (first l) がその答となる。

    4. もし、(and (> n 0) (cons? l)) が成立する場合、利用可能な式が何を計算するのか分析しなければならない。今まで見てきたように、このステップでは、既存の例題を通して作業するのがよいでしょう。ここでは、最初の例題を短くしたものを選びます。

       (check-expect (list-pick '(a b) 1) 'b)

    これらの値を使って、3つの自然再帰計算がどのように計算されるかを説明する。

        a. (list-pick '(b) 0) は 'b. を生成します。

        b. (list-pick '(a b) 0) は、 誤った答 'a と評価されます。

        c. (list-pick '(b) 1)はエラーを通知する。

    これより、(list-pick (rest l) (sub1 n)) は最後のcond節で望みの答を計算する、と結論づけられる。

練習問題390
関数 tree-pick を設計しなさい。この関数はsymbolのツリーとDirectionのリストを消費する。

    (define-struct branch [left right])
     
    ; TOSは以下のいずれかである。
    ; - Symbol
    ; - (make-branch TOS TOS)
     
    ; Direction は、以下のいずれかを指します。
    ; - 'left
    ; - 'right
     
    ; Directionのリストをpathと呼ぶこともある。

明らかにDirectionは、非記号化ツリーの左側と右側のどちらの枝を選ぶかを関数に指示します。tree-pick 関数の結果はどうなるでしょうか？完全なシグネチャを作成することを忘れないでください。この関数は、symbolと空でないパスが与えられるとエラーを通知します。■



23.4 関数の簡略化

図134のlist-pick関数は、必要以上に複雑です。最初の2つのcond句はエラーを通知する。つまり、もし

    (and (= n 0) (empty? alos))

または

    (and (> n 0) (empty? alos))

のどちらかを実行すると、答えはエラーになります。この観察結果をコードに置き換えることができます。

  (define (list-pick alos n)
    (cond
      [(or (and (= n 0) (empty? alos))
           (and (> n 0) (empty? alos)))
       (error 'list-pick "list too short")]
      [(and (= n 0) (cons? alos)) (first alos)]
      [(and (> n 0) (cons? alos))
       (list-pick (rest alos) (sub1 n))]))

この関数をさらに単純化するために、ブール演算に関する代数的な法則を知る必要がある。

    (or (and bexp1 a-bexp))   ==   (and（or bexp1 bexp2)
        (and bexp2 a-bexp))             a-bexp)
 

and(論理積)の部分式が入れ替わったときにも同様の法則が適用される。これらの法則をlist-pickに適用すると、次のようになる。

(define (list-pick n alos)
  (cond
    [(and (or (= n 0) (> n 0)) (empty? alos))
     (error 'list-pick "list too short")]
    [(and (= n 0) (cons? alos)) (first alos)]
    [(and (> n 0) (cons? alos))
     (list-pick (rest alos) (sub1 n))]))

ここで、(or (= n 0) (> n 0))を考えてみよう。nはNに属するので常に#trueである。(and #true (empty? alos)) は (empty? alos)と等価なので、この関数を再び書き直すことができる。

(define (list-pick alos n)
  (cond
    [(empty? alos) (error 'list-pick "list too short")]
    [(and (= n 0) (cons? alos)) (first alos)]
    [(and (> n 0) (cons? alos))
     (list-pick (rest alos) (sub1 n))]))

この最後の定義は、すでに図134の定義よりかなり単純になっているが、これよりもっといいものができる。最新版のlist-pickの最初の条件と、2番目と3番目の条件を比べてみてください。最初のcond句はalosが空の場合をすべてフィルタリングしているので、最後の2つの句の(cons? alos)は常に#trueと評価されることになる。条件を#trueに置き換えてand式を再び簡略化すると、3行のlist-pickが得られます。

--
  ; list-pick:[List-of Symbol] N[>= 0] -> Symbol
  ; 0から数えてn番目のsymbolを決定する。
  ; n番目のsymbolがない場合はエラーとなる。
  (define (list-pick alos n)
    (cond
      [(empty? alos) (error 'list-pick "list too short")]
      [(= n 0) (first alos)]
      [(> n 0) (list-pick (rest alos) (sub1 n))]))

    図135：リストへのインデックス付け、簡略化されたバージョン
--


図135は、このリストピックの簡略版を表示したものである。これはオリジナルよりはるかに単純ですが、オリジナルを体系的に設計し、確立された代数的法則で1を2に変換することができたことを理解することが重要です。したがって、この単純なバージョンを信頼することができる。もし、関数の単純版を直接見つけようとすると、遅かれ早かれ、解析の際に場合分けの処理に失敗し、欠陥のあるプログラムが出来上がることが保証される。

練習問題391
"23.3 2つのリストを同時に処理する: ケース3"を用いて、replace-eol-with を設計せよ。テストから始めなさい。結果を系統的に簡略化せよ。■

練習問題392
練習問題390の関数tree-pickを簡略化せよ。■



23.5 二つの複雑な入力を消費する関数を設計する

2つ（またはそれ以上）の複雑な引数を持つ関数を設計するための適切なアプローチは、一般的なレシピに従うことです。データ分析を行い、関連するデータのクラスを定義する必要があります。List-ofのようなパラメトリック定義や'(1 b &)のような短絡的な例の使用で混乱するなら、コンストラクタが明示的になるようにそれらを拡張する。次に、関数のシグネチャと目的が必要です。この時点で、次の3つのうちどの状況にあるのか、先を読んで判断することができます。

    1. もし、どちらかのパラメータが支配的な役割を果たすのであれば、関数に関する限り、もう一方のパラメータはアトミックなデータだと考えてください。

    2. 場合によっては、パラメータは同じクラスの値にまたがり、同じ大きさでなければなりません。例えば、2 つのリストの長さが同じであったり、2 つの Web ページの長さが同じで、片方にページが埋め込まれていれば、もう片方も埋め込まれていなければなりません。このように2つのパラメータが等価であり、かつ同期して処理することが目的である場合、一方のパラメータを選択し、それを中心に関数を構成し、もう一方のパラメータを並列に処理することになります。

    3. 2つのパラメータの間に明らかな関連性がない場合は、例を挙げて考えられるすべてのケースを分析する必要があります。そして、この分析を使って、テンプレート、特に再帰的な部分を開発する。

3番目のカテゴリーに属すると判断したら、2次元の表を作成し、抜けがないようにする。ここで、自明でないデータ定義の組を使って、この考え方をもう一度説明しよう。

; An LOD is one of: 
; - '()
; - (cons Direction LOD)
 
; A TID is one of: 
; - Symbol
; - (make-binary TID TID)
; - (make-with TID Symbol TID)


左のデータ定義は通常のリスト定義で、右のデータ定義はTOSの3節変形である。これは2つの構造体型の定義を使用しています。

    (define-struct with [lft info rght])
    (define-struct binary [lft rght])

この関数がLODとTIDを消費すると仮定すると、出てくるべき表はこのような形をしています。

    	表。

横方向には、第1パラメータであるLODについて、サブクラスを認識する条件を列挙し、縦方向には、第2パラメータであるTIDについて、条件を列挙している。

この表は、関数例と関数テンプレートの両方を作成する際のガイドとなる。説明したように、例題はすべての可能なケースをカバーしなければならない。つまり、表の各セルに対して少なくとも一つの例題がなければならない。同様に、テンプレートには、セルごとに1つのcond節が必要である。その条件は、and式の水平方向と垂直方向の条件を組み合わせたものである。それぞれのcond節は、順番に、両方のパラメータに対するすべての実行可能なセレクタ式を含まなければなりません。もし、どちらかのパラメータがアトミックであれば、セレクタ式は必要ない。最後に、実現可能な自然再帰を意識する必要があります。一般に、セレクタ式（およびオプションでアトミック引数）のすべての可能な組み合わせは、自然回帰の候補となります。どれが必要でどれが必要でないかは分からないので、コーディングのステップでそれらを念頭に置いておく。

要約すると、マルチパラメーター関数の設計は、古い設計レシピのテーマのバリエーションに過ぎない。重要なアイデアは、データ定義を、実現可能で興味深い組み合わせをすべて示す表に変換することである。関数例の開発とテンプレートは、可能な限りテーブルを利用します。



23.6 指の練習問題: 2つの入力

練習問題393
図62は、有限集合の2つのデータ定義を示したものである。あなたが選んだ有限集合の表現のための和集合関数を設計しなさい。これは2つの集合を消費し、両方の要素を含む集合を生成する。

同じ集合表現でintersectを設計しなさい。これは2つの集合を消費し、両方に出現する要素だけの集合を生成する。■


演習394
mergeをデザインせよ。この関数は昇順でソートされた2つの数値リストを消費します。この関数は、両方の入力リストにあるすべての数値を含む、単一のソートされた数値のリストを生成します。1つの数値は、2つの入力リストに含まれる回数と同じだけ出力に含まれる。■


演習395
takeをデザインせよ。これはリスト l と自然数 n を消費し、l から最初の n 個の項目、または l が短すぎる場合にはそのすべてを生成する。

drop をデザインせよ。その結果は、l から最初の n 個の項目を取り除いたもの、または l が短かすぎる場合は '() だけとなります。

--
; HM-Wordは[List-of Letter or "_"] です。
; 解釈 "_" は推測される文字を表す
             
; HM-Word N -> String
; は単純なハングマンゲームを実行し、現在の状態を生成する。
(define (play the-pick time-limit)
  (local ((define the-word  (explode the-pick))
          (define the-guess (make-list (length the-word) "_"))
          ; HM-Word -> HM-Word
          (define (do-nothing s) s)
          ; HM-Word KeyEvent -> HM-Word 
          (define (checked-compare current-status ke)
            (if (member? ke LETTERS)
                (compare-word the-word current-status ke)
                current-status)))
    (implode
     (big-bang the-guess ; HM-Word
       [to-draw render-word]
       [on-tick do-nothing 1 time-limit]
       [on-key  checked-compare]))))
 
; HM-Word -> Image
(define (render-word w)
  (text (implode w) 22 "black"))

    図136。簡単なハングマンゲーム
--


練習問題396
ハングマンは、よく知られた推理ゲームです。一方のプレイヤーは単語を選び、もう一方のプレイヤーはその単語に何文字が含まれているかを知らされる。後者は1つの文字を選び、その文字が選ばれた単語のどこに含まれるかを最初のプレーヤーに尋ねます。ゲームは、決められた時間またはラウンド数の後に終了します。

図136は、時間制限のあるエッセンスを紹介している。checked-compareがローカルに定義される理由については、Local Definitions Add Expressive Powerを参照のこと。

この演習の目標は、中心関数である compare-word を設計することである。この関数は、推測される単語、推測プレーヤーがどれだけ／ほとんど発見したかを表す単語 s、および現在の推測を消費する。この関数は、推測が文字を明らかにした場合、すべての"_"を含むsを生成する。

関数を設計したら、このようにプログラムを実行します。

    (define LOCATION "/usr/share/dict/words") ; OS Xの場合
    (define AS-LIST (read-lines LOCATION))
    (define SIZE (length AS-LIST))
    (play (list-ref AS-LIST (random SIZE)) 10)

説明は図74をご覧ください。楽しみながら、お好みで改良してください。■


練習問題397
ある工場では、従業員が朝出社し、夕方退社するときにタイムカードを押しています。電子タイムカードには、従業員番号が記載され、1週間の労働時間が記録される。従業員の記録には、常に従業員の名前、従業員番号、および時間あたりの給与が含まれています。

wage*.v3 をデザインしなさい。この関数は、従業員レコードのリストとタイムカードレコードのリストを消費します。そして、従業員の名前と週給を含む賃金レコードのリストを生成します。この関数は、タイムカードに対応する従業員レコードが見つからない場合、あるいはその逆の場合、エラーを通知します。

前提 1つの社員番号につき、最大1つのタイムカードが存在する。■


練習問題398
線形結合とは、多数の線形項、つまり変数と数値の積の和である。後者はこの文脈では係数と呼ばれる。以下はその例である。
 
  5・x   5・x+17・y   5・x+17・y+3・z

すべての例で、xの係数は5、yの係数は17、zの係数は3である。

変数の値が与えられれば、多項式の値を決定することができる。例えば、x=10ならイメージの値は50、x=10かつy=1ならイメージの値は67、x=10かつy=1かつz=2ならイメージの値は73となる。

線形結合にはさまざまな表現があります。例えば、関数で表現することもできる。別の表現としては、その係数のリストがある。上記の組み合わせは次のように表現される。

    (list 5)
    (list 5 17)
    (list 5 17 3)

この表現方法は、変数の順序が固定されていることを前提としています。

valueを設計せよ。この関数は、線形結合と変数値のリストという、同じように長い2つのリストを消費します。そして、これらの値に対する組合せの値を生成します。■


練習問題399
ルイーズ、ジェーン、ローラ、ダナ、メアリーは、プレゼントを受け取る人を一人ずつ割り当てる抽選を行うことにした。ジェーンは開発者なので、このタスクを公平に実行するプログラムを書くように依頼した。もちろん、このプログラムは、姉妹の誰も自分に割り当ててはならない。

これが、Janeのプログラムの核心です。

    ; [List-of String] -> [List-of String] 
    ;ランダムで非同一な名前の並びを選ぶ
    (define (gift-pick names)
      (random-pick
        (non-same names (arrangements names))))
 
    ; [List-of String] -> [List-of [List-of String]]
    ; 名前の並べ換えをすべて返す
    ; 練習問題213参照
    (define (arrangements names)
     ...)

名前のリストを消費して、元のリストと一致しない順列の中からランダムに1つを選びます。

あなたの仕事は、2つの補助関数を設計することです。

    ; [NEList-of X] -> X
    ; リストからランダムな項目を返す
    (define (random-pick l)
      (first l))
     
    ; [List-of String] [List-of [List-of String]] 
    ; -> 
    ; [List-of [List-of String]]
    ; llに含まれるリストのうち、どの位置でもnamesの要素と一致しないリストを生成します。
    (define (non-same names ll)
      ll)

random は乱数を選ぶことを思い出してください；練習問題99を参照してください。■


練習問題400
関数DNAprefixを設計せよ。この関数は2つの引数を取るが、どちらも DNA の記述に現れる記号である 'a, 'c, 'g, 't のリストである。最初のリストは検索パターンと呼ばれ、2番目のリストは検索対象文字列と呼ばれる。この関数は、パターンが対象文字列の最初の部分と同一であれば#trueを返し、そうでなければ#falseを返す。

また、DNAdeltaを設計します。この関数は DNAprefix と似ていますが、検索対象文字列の中でパターンを越えた最初の項目を返します。もしリストが同一で、パターンの先にDNA文字がない場合、この関数はエラーを通知します。パターンが対象文字列の先頭と一致しない場合、#false を返します。この関数は、どちらのリストも2回以上走査してはいけません。

DNAprefixやDNAdeltaは簡略化できるのですか？■


練習問題401
2つのS式が等しいかどうかを判定する関数、sexp=?を設計せよ。以下は便宜上、データ定義を要約したものである。

    ; S-expr(S-expression)は以下のいずれかである。
    ; - Atom
    ; - [List-of S-expr]
    
    ; Atomは以下のいずれかである。
    ; - Number
    ; - String
    ; - 記号

check-expectを使うときはいつも、sexp=? のような関数を使って、任意の2つの値が等しいかどうかをチェックします。等しくない場合、チェックは失敗し、check-expectはそのように報告します。■


練習問題402
練習問題354を再読してください。与えられた式を最初は原子値として考えるというヒントの根拠を説明しなさい。■




23.7 プロジェクトデータベース

多くのソフトウェアアプリケーションは、データを記録するためにデータベースを使用します。大雑把に言えば、データベースとは、明示された構成ルールが付属するテーブルのことです。前者はコンテンツで、後者はスキーマと呼ばれるものです。図137に2つの例を示す。各テーブルは、線の上のスキーマと線の下のコンテンツの2つの部分から構成されています。

左の表に注目してみましょう。この表は3列と4行で構成されています。それぞれの列には、2つのルールがあります。

1. 一番左の列のラベルが「Name」で、この列のデータはすべて「String」であることを意味します。

2. 中央の列は「Age」とラベル付けされ、整数を含んでいます。

3. 右端のラベルはPresentであり、その値はブール値である。

ストップ！右のテーブルも同じように説明してください。


    図 137:テーブルとしてのデータベース

コンピュータ科学者は、これらのテーブルを関係として考えている。スキーマでは、関係の列や行の個々のセルを参照するための用語を導入している。各行は固定された数の値を関連付け、すべての行の集合が関係全体を構成する。この用語では、図137の左の表の最初の行は、"Alice "と35および#trueを関係付ける。さらに、行の最初のセルを「Name」セル、2番目のセルを「Age」セル、 3番目のセルを「Present」セルと呼ぶ。

ここでは、データベースを構造体とリストで表現する。

    (define-struct db [schema content]).
    ; DBは構造体である。(make-db Schema Content)
   
    ; Schema は [List-of-Spec]である。
    ; Spec は [List Label Predicate]である。
    ; Label は String
    ; Predicate (術語) は[Any -> Boolean]である。
     
    ; Content は [List-of-Row]である。
    ; Row は [Lisf-of Cell]である。
    ; Cellは任意のもの
    ; constraint cell は関数を含まない
     
    ; 完全性制約 (make-db sch con)において。
    ; con の各行に対して
    ; (I1) その行の長さが sch と同じで、かつ
    ; (I2) その i番目のCellがschのi番目のPredicate(述語)を満足する。

ストップ！図137のデータベースを選択したデータ表現に変換してください。テーブルの内容はすでにISL+データを使用していることに注意してください。

                (define school-schema
                  `(("Name"    ,string?))
                    ("Age"     ,integer?)
                    ("Present" ,boolean?)))

                (define school-content
                  `(("Alice" 35 #true)
                    ("Bob"   25 #false)
                    ("Carol" 30 #true)
                    ("Dave"  32 #false)))

                (define school-db
                  (make-db school-schema
                           school-content))


                (define presence-schema
                  `(("Present"     ,boolean?))
                    ("Description" ,string?)))

                (define presence-content
                  `((#true  "presence")
                    (#false "absence"))
                	
                (define presence-db
                  (make-db presence-schema
                           presence-content))

 
            図138：ISL+データとしてのデータベース


図138は、図137の2つのテーブルをDBとして表現する方法である。その左側は図137の左側のテーブルのスキーマ、内容、データベースを表し、その右側は右側のテーブルに対応する。簡潔さのために、例ではquasiquoteとunquoteの表記を使用している。これは、引用符で囲まれたリストの中にboolean?のような値を含めることができることを思い出してください。もしこの表記に違和感を覚えたら、これらの例をlistで再表現してください。


練習問題403
Spec は、Label と Predicate を組み合わせてリストにしたものです。しかし、この方法は、「決まった数の情報には構造体を使う」という指針に反しています。

ここでは、別のデータ表現を紹介する。

    (define-struct spec [label predicate])
    ; Spec は構造体である。(make-spec label Predicate)

この代替定義を使用して、図137のデータベースを表現してください。■


完全性チェック データベースの利用は、その完全性に決定的に依存している。ここで、「完全性」とは、データ定義にある制約 (I1) と (I2) を指します。データベースの完全性をチェックすることは、明らかに関数のタスクである。

    ; DB -> Boolean
    ; DBの全ての行が(I1)と(I2)を満たすか？
     
    (check-expect (integrity-check school-db) #true)
    (check-expect (integrity-check presence-db) #true)
     
    (define (integrity-check db))
      #false)

2つの制約の文言は、ある関数が与えられたデータベースのコンテンツ内のすべての行に対して#trueを生成しなければならないことを示唆しています。この考えをコードで表現すると、dbのコンテンツに対してandmapを使用することが求められます。

(define (integrity-check db)
  (local (; Row -> Boolean
          (define (row-integrity-check row)
            ...))
    (andmap row-integrity-check (db-content db))))

既存の抽象化機能を利用するための設計レシピに従い、テンプレートはローカル定義によって補助関数を導入しています。

行整合性チェックの設計は、次の定義から始まる:
    ; Row -> Boolean 
    ; 行が(I1)と(I2)を満たすかどうか
    (define (row-integrity-check row))
      #false)

いつものように、目的の声明を定式化することのゴールは問題を理解することです。ここでは、関数が2つの条件をチェックすることを述べています。2つのタスクが関係する場合、私たちの設計指針では、関数とその結果の組み合わせを求めます。

  (and (length-of-row-check row)
       (check-every-cell row))

これらの機能をウィッシュリストに追加することで、名前からその目的を知ることができます。

このような関数を設計する前に、既存の基本演算を組み合わせて目的の値を計算できないか考えておく必要があります。例えば、(length row)は行の中にいくつのセルがあるかをカウントする。この方向でもう少し推し進めると、明らかに以下の文が必要でしょう：
     (= (length row) (length (db-schema db)))

この条件は、行の長さがdbfsスキーマの長さと同じであることを確認するものである。

同様に、check-every-cellは、ある関数が行のすべてのセルに対して#trueを生成することをチェックするために呼び出されます。もう一度言うと、andmapが呼ばれる可能性があるようです。

    (andmap cell-integrity-check row)

Cell-integrity-checkの目的は、当然、制約条件（I2）を確認することです。つまり、

    dbのschemaの中で、i番目のCellがi番目の述語を満たすかどうか。

そして今、私たちは行き詰っている。なぜなら、この目的の声明は、行の中の与えられたセルの相対的な位置を参照しているからである。しかし、andmapのポイントは、すべてのセルに対して一様にセル整合性チェックを適用することである。

行き詰まったときは、例題で解決するしかありません。補助関数やローカル関数の場合は、主関数の例から派生させるのがよいでしょう。integrity-checkの最初の例は、school-contentが整合性制約を満たしていることを表明しています。明らかに、school-contentのすべての行はschool-schemaと同じ長さを持っています。問題は、以下のような行

    (list "Alice" 35 #true)

がなぜ対応するスキーマの述語を満足するかです。

    (list (list "Name"    string?)
          (list "Age"     integer?)
          (list "Present" boolean?))

答えは、3つの述語をそれぞれのセルに適用すると、3つとも真となることです。

  > (string? "Alice")
  #true
  > (integer? 35)
  #true
  > (boolean? #true)
  #true

ここから、この関数はこれら2つのリスト（dbのスキーマと与えられた行）を並行して処理しなければならないことがわかるのは、ほんの少しのステップだけです。

練習問題404
関数 andmap2 を設計しなさい。この関数は2つの値からブール値に変換する関数fと、同じ長さの2つのリストを消費する。その結果もまたブール値である。具体的には、fを2つのリストの対応する値のペアに適用し、fが常に#trueを生成する場合、andmap2も#trueを生成する。そうでなければ、andmap2は#falseを生成する。要するに、andmap2はandmapのようなものであるが、二つのリストに対するものである。■


ストップ！練習問題404を解いてから次を読んでください。

ISL+にandmap2があれば、rowの2番目の条件のチェックは簡単です。

    (andmap2 (lambda (s c) [(second s) c)])
             (db-schema db)
             行)

与えられた関数は、dbfsスキーマからSpec sを消費し、2番目の位置から述語を取り出し、与えられたCell cに適用します。

ストップ!  [(second s) c] をもう一度説明してください。


結論から言うと、ISL+のandmapはすでにandmap2のようなものです。

 (define (integrity-check db)
   (local (; Row -> Boolean)	
           ; 行が(I1)と(I2)を満たすかどうか
           (define (row-integrity-check row)
             (and (= (length row)
                     (length (db-schema db)))
                  (andmap (lambda (s c) [(second s) c])
                          (db-schema db)
                          row))))
     (andmap row-integrity-check (db-content db))))

ストップ! integrity-checkが必ず失敗するテストを開発してください。

式のホイスティングに関する注意   私たちの完全性チェックの定義には、いくつかの問題があり、目に見えるものもあれば、見えないものもあります。明らかに、この関数はdbのschemaを2回抽出します。既存のローカルな定義で、定義を導入し、この重複を避けることは可能です。

(define (integrity-check.v2 db)
  (local ((define schema (db-schema db))
          ; Row -> Boolean 
          ; 行が(I1)と(I2)を満たすかどうか
          (define (row-integrity-check row)
            (and (= (length row) (length schema))
                 (andmap (lambda (s c) [(second s) c])
                         schema
                         row))))
    (andmap row-integrity-check (db-content db))))

ローカル定義から、このような式を持ち上げると、integrity checkの実行に必要な時間が短縮されることが分かっています。図100のinfの定義のように、integrity-checkの元のバージョンは、明らかに同じままであるにもかかわらず、1行ごとにdbからスキーマを抽出する。

--
(define (integrity-check.v3 db)
  (local ((define schema  (db-schema db))
          (define content (db-content db))
          (define width   (length schema))
          ; Row -> Boolean 
          ; does row satisfy (I1) and (I2) 
          (define (row-integrity-check row)
            (and (= (length row) width)
                 (andmap (lambda (s c) [(second s) c])
                         schema
                         row))))
    (andmap row-integrity-check content)))

    図139：システマティックに表現された吊り上げの結果
--

ターミノロジー
同じように、行整合性チェック関数は、呼び出されるたびにdbのスキーマの長さを決定します。その結果はいつも同じです。したがって、この関数のパフォーマンスを向上させることに興味があるのなら、ローカル定義を使用して、データベースの内容の幅に一度だけ名前を付けることができます。図139は、row-integrity-checkから(length schema)を吊り上げた結果を表示したものである。読みやすくするために、この最終的な定義では、dbのcontentフィールドにも名前を付けています。


プロジェクションと選択 プログラムはデータベースからデータを抽出する必要がある。抽出の一つはコンテンツの選択で、これは実世界のデータ：iTunesで説明されている。もう一つの抽出方法は、データベースを縮小して作成するもので、これは プロジェクション (projection) と呼ばれる。具体的には、あるデータベースから特定の列だけを残してデータベースを構築するのがプロジェクションである。


プロジェクションの説明では、以下のように示唆されています。

    ; DB [List-of Label] -> DB
    ; ラベルがlabelsにある場合、DBからカラムを保持する
    (define (project db labels) (make-db '() '()))

プロジェクションの複雑さを考えると、まずは例題をこなすのが一番でしょう。例えば、図137の左側のデータベースから年齢列を削除したいとします。この変換をテーブルで表すと、以下のようになります。


the original database                ... eliminating the “Age” column
------------------------------------------------------------------------
Name       Age       Present               Name      Present
String     Integer   Boolean               String    Boolean
------------------------------------------------------------------------
"Alice"    35        #true                 "Alice"   #true
...


テストとして例を明確にする自然な方法は、図138を再利用します。

(define projected-content
  `(("Alice" #true)
    ("Bob"   #false)
    ("Carol" #true)
    ("Dave"  #false)))
 
(define projected-schema
  `(("Name" ,string?) ("Present" ,boolean?)))
 
(define projected-db
  (make-db projected-schema projected-content))
  ; ストップ! このテストをよく読んでみてください。何が問題なのでしょうか？
  (check-expect (project school-db '("Name" "Present")))
                  projected-db)

--
(define (project db labels)
  (local ((define schema  (db-schema db))
          (define content (db-content db))
          ; Spec -> Boolean
          ; このspecが新しいスキーマに属するかどうか
          (define (keep? c) ...)
    
          ; Row -> Row
          ; ラベルに名前があるカラムを保持する。
          (define (row-project row) ...))

    (make-db (filter keep? schema)
             (map row-project content))))

    図 140:プロジェクトのテンプレート
--


上記のテンプレートに記入して、DrRacketでコードを実行すると、エラーメッセージが表示されます。

    等号の第一引数は関数であってはならない

がテストに成功したかどうかを判断する前に、関数が無限に大きなオブジェクトであることを思い出してください。Functions Are Values で、関数は無限に大きなオブジェクトであり、2つの関数が同じ引数に適用されたときに常に同じ結果を生成することを保証することは不可能であることを思い出してください。そこで、テストケースを弱くします。

(check-expect
  (db-content (project school-db '("Name" "Present")))
  projected-content)

テンプレートについても、既存の抽象的な表現を再利用している（図140参照）。一つは与えられたデータベースのスキーマを絞り込むためのfilterと一緒に使う関数、もう一つはコンテンツを間引くためのmapと一緒に使う関数である。さらに、この関数は、与えられたデータベースからスキーマとコンテンツを再び抽出し、名前を付ける。

ウィッシュリストを見る前に、一歩下がって、既存の抽象化を2回再利用するという決定について勉強してみましょう。シグネチャは、この関数が構造体を消費して DB の要素を生成することを示しています。

    (local ((define schema (db-schema db))
            (define content (db-content db))
      (make-db ... schema ...
               ... contents ...))

が明らかに求められている。また、古いスキーマから新しいスキーマが作られ、古いコンテンツから新しいコンテンツが作られることもわかりやすい。さらに、プロジェクトの目的文では、第二引数で言及されたラベルのみを保持することが求められている。したがって、フィルタ機能は与えられたスキーマを正しく絞り込む。一方、行は、それぞれのセルが失われることを除けば、それ自体は残ります。このように、mapはコンテンツを処理する適切な方法である。

さて、次に2つの補助関数の設計について説明する。keep?の設計は簡単である。以下はその完全な定義である。

    ; Spec -> Boolean
    ; このスペックが新しいスキーマに属しているかどうか
    (define (keep? c)
      (member? (first c) labels)

この関数は、LabelとPredicateをリストで結合したSpecに適用されます。前者がラベルに属する場合、与えられたSpecは保持されます。

行プロジェクトの設計では、各行のコンテンツで、名前が与えられたラベルのメンバーであるセルを保持することが目標です。上の例を見てみよう。4つの行があります。

(list "Alice" 35 #true)
(list "Bob"   25 #false)
(list "Carol" 30 #true)
(list "Dave"  32 #false)

これらの行は、それぞれschool-schemaと同じ長さである。

(list "Name" "Age" "Present")

スキーマにある名前は、与えられた行のセルの名前を決定する。したがって、row-projectは、各行の1番目と3番目のセルを保持しなければならない。なぜなら、与えられたラベルにあるのは、それらの名前だからである。

Row は再帰的に定義されるので、このセルの内容と名前のマッチング処理には、 row-project がセルの内容とラベルに適用できる再帰的なヘルパー関数が必要です。願望として、それを指定してみよう。

    ; Row [List-of Label] -> Row
    ;名前に対応する要素がラベルにもあるセルを保持する
    (define (row-filter row names) '())

このwishを使って、row-projectはワンライナーで。

(define (row-project row)
  (row-filter row (map first schema)))


map式でセル名を抽出し、そのセル名をrow-filterに渡してマッチするセルを抽出する。

練習問題405
関数row-filterを設計しなさい。プロジェクトの例題からrow-filterの例題を作成しなさい。

前提 与えられたデータベースは整合性チェックを通過し、各行がスキーマと同じ長さであり、したがってその名前のリストも同じ長さであることを意味します。■


図141は、すべてのピースをまとめたものです。この関数プロジェクトは、いくつかの改善を求めているため、接尾辞が .v1 になっています。次の演習では、そのうちのいくつかを実装するよう求められます。

--
   (define (project.v1 db labels))
      (local ((define schema (db-schema db))
              (define content (db-content db))
             
         ; Spec -> Boolean
         ; このカラムは新しいスキーマに属するか？
         (define (keep? c)
            (member? (first c) labels))
             
         ; Row -> Row
         ; labelsに名前がある列を保持する。
         (define (row-project row)
           (row-filter row (map first schema)))
             
         ; Row [List-of Label] -> Row
         ; ラベルに名前があるセルを保持する
          (define (row-filter row names)
            (cond
              [(empty? names) '()]
              [else
               (if (member? (first names) labels)
                   (cons (first row)
                     (row-filter (rest row) (rest names)))
                   (row-filter (rest row) (rest names)))])))
    (make-db (filter keep? schema)
             (map row-project content))))

    図141:データベースの投影
--

練習問題406
row-project 関数は、データベースの内容のすべての行のラベルを再計算します。結果は関数呼び出しごとに異なるか？そうでなければ、式を吊り上げる。■


練習問題407
row-filterをfoldrで再設計せよ。そうすれば、row-projectとrow-filterを一つの関数に統合することができる。ヒント ISL+ の foldr 関数は、2つのリストを消費し、それらを並行して処理することができる。■


最後の観察は、行プロジェクトはラベルのメンバーシップをセルごとにチェックすることである。異なる行の同じ列のセルに対して、結果は同じになります。したがって、この計算を関数から切り離すことは理にかなっています。

この形式は、平易な表現による吊り上げよりもやや困難である。次を全ての行に対して行い、その結果をラベルのリストではなく関数に渡すということの結果をあらかじめ計算しておきたいのです。

        (member? label labels)

つまり、ラベルのリストを、対応する位置のセルを保持するかどうかを示すブール値のリストと置き換えるのです。幸いなことに、これらのブール値の計算は、スキーマに対するkeep?の別の適用に過ぎません。

       (map keep? schema)

与えられたスキーマからいくつかのSpecを残して他を捨てるのではなく、この式は決定を集めるだけである。

            (define (project db labels)
              (local ((define schema (db-schema db))
                      (define content (db-content db))
             
                      ; Spec -> Boolean
                      ; このカラムは新しいスキーマに属するか？
                      (define (keep? c)
                        (member? (first c) labels))
             
                      ; Row -> Row
                      ; labelsにnameがある列を保持する。
                      (define (row-project row)
                        (foldr (lambda (cell m c) (if m (cons cell c) c))
                               '()
                               row
                               mask))
                      (define mask (map keep? schema)))
                (make-db (filter keep? schema))
                         (map row-project content))))

                図142:データベースの投影


図142はプロジェクトの最終バージョンで、これまでの演習の解答を統合したものです。また、スキーマとコンテンツの抽出と名前付けにlocalを使用し、さらにいくつかのSpecのラベルが保持する価値があるかどうかをチェックするためにkeep?を使用しています。残りの2つの定義は、前述のブール値のリストを表すmaskと、改訂版のrow-projectを紹介しています。後者は、与えられた行とマスクを並列に処理するためにfoldrを使用しています。

この改訂されたプロジェクトの定義を、図141のproject.v1と比較してみてください。最終的な定義は、元のバージョンよりもシンプルで高速になっています。体系的な設計と慎重な修正が功を奏し、テスト・スイートは修正によってプログラムの機能が損なわれないことを保証してくれます。

練習問題408
関数 select を設計しなさい。この関数は、データベース、ラベルのリスト、および行に対する述語を消費します。結果は、与えられた述語を満たす行のリストで、与えられたラベルのセットに投影されます。■


練習問題409
reorderを設計しなさい。この関数は、データベースdbとラベルのリストlolを消費します。この関数は、dbのようなデータベースを生成しますが、その列はlolに従って並べ替えられています。ヒント list-ref について読んでください。■

最初は、lolがdbfsのカラムのラベルから正確に構成されていると仮定する。設計が完了したら、lolが列の数より少ないラベルと、dbの列のラベルでない文字列を含む場合、何を変更しなければならないかを検討します。


練習問題410
全く同じスキーマを持つ2つのデータベースを消費し、このスキーマと両者の結合内容を持つ新しいデータベースを生成する関数db-unionを設計しなさい。この関数は、全く同じ内容を持つ行を削除しなければならない。■

各カラムの述語についてスキーマが一致していると仮定する。

練習問題411
db-1とdb-2という2つのデータベースを消費する関数、joinを設計してください。db-2のスキーマは、db-1のスキーマが終了するのと全く同じSpecから始まります。この関数は、各行の最後のセルをdb-2のセルの翻訳に置き換えて、db-1からデータベースを作成します。

以下はその例である。図137のデータベースを例にとろう。この2つはこの演習の前提を満たしている。つまり、1つ目のスキーマの最後のSpecは2つ目のスキーマの最初のSpecと同じである。したがって、これらを結合することは可能である。

  Name       Age        Description
  String     Integer    String
  -------------------------------------
  "Alice"    35         "presence"
  "Bob"      25         "absence"
  "Carol"    30         "presence"
  "Dave"     32         "absence"


この翻訳では、#trueは「存在」、#falseは「不在」に対応する。

ヒント (1) 一般に、2つ目のデータベースでは、1つのセルを1つの値だけでなく、複数の値の行に「翻訳」することができる。"presence "と "absence "の行に用語を追加して例を修正せよ。

(2) セルを複数の行に「翻訳」する場合もあり、その場合は新しいデータベースに複数の行が追加される。次に、図137とは少し異なるデータベースの組の例を示す。

  Name      Age        Present      || Present    Description  
  String    Integer    Boolean      || Boolean    String
  ---------------------------------------------------------------
  "Alice"   35         #true        || #true      "presence"
  "Bob"     25         #false       || #true      "here"
  "Carol"   30         #true        || #false     "absence"
  "Dave"    32         #false       || #false     "there"

左のデータベースと右のデータベースを結合すると、8行のデータベースができあがります。

  Name       Age        Description
  String     Integer    String
  -------------------------------------
  "Alice"　　35         "presence"
  "Alice"    35         "here"
  "Bob"      25         "absence"
  "Bob"      25         "there"
  "Carol"    30         "presence"
  "Carol"    30         "here"
  "Dave"     32         "absence"
  "Dave      32         "there"

(3)反復精密化を用いて問題を解く。最初の反復では、「翻訳」はセルあたり1行しか見つからないと仮定する。2回目以降は、この仮定を外す。

仮定に関する注意 この演習とセクション全体は、ほとんどが与えられたデータベースに関する非公式な仮定に依存しています。ここでは、「db-2のスキーマはdb-1のスキーマが終了するのと全く同じSpecで始まる」という仮定でjoinを設計しています。しかし、checked-joinを設計することは不可能であろう。db-1のスキーマの最後のSpecとdb-2の最初のSpecを比較すると、関数の比較を要求される。実用的な解決策については、データベースに関するテキストを参照されたい。■



24 まとめ

本書の第4部では、多くの定義が絡み合った記述を必要とするデータを処理する関数の設計について説明します。このようなデータは、コンピュータのローカルファイルシステムから、ワールドワイドウェブ、アニメーション映画に使われる幾何学図形まで、実世界のあらゆるところに出現します。本書のこの部分を注意深く読んでいくと、設計のレシピがこれらの形式のデータにも適用できることがわかるでしょう。

    プログラムデータの記述で、相互に参照し合う複数のデータ定義が必要な場合、設計レシピでは、データ定義ごとに1つのテンプレートを同時に開発することを求めている。データ定義Aがデータ定義Bを参照する場合、テンプレート function-for-A は function-for-B を全く同じ場所、同じ方法で参照する。それ以外の設計レシピは、従来通り、機能に対して機能で動作します。

    ある関数が2種類の複雑なデータを処理しなければならないとき、3つのケースを区別する必要があります。まず、関数は片方の引数を原子であるかのように処理することができます。2つ目は、2つの引数が全く同じ構造であることが予想され、関数が完全に並列にそれらを走査する場合です。第三に、関数はすべての可能な組み合わせを別々に処理しなければならない場合があります。この場合、2次元の表を作成し、一方の次元で1つのデータ定義からすべての種類のデータを列挙し、もう一方の次元で2番目の種類のデータを処理することになります。最後に、表のセルを使って、さまざまなケースの条件と答えを設定する。

    このパートでは、2つの複雑な引数に対する関数を扱います。もし、関数が3つの複雑なデータを受け取るという稀なケースに遭遇したら、3次元のテーブルが必要である（と想像する）ことがわかるでしょう。

ここまでで、細部は違えど、キャリアを通じて出会う可能性のあるあらゆる形式の構造データを見てきました。もし行き詰まったら、この設計レシピを思い出してください。

