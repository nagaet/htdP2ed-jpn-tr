How to Design Programs, Second Edition.
Matthias Felleisen, Robert Bruce Findler, Matthew Flatt, Shriram Krishnamurthi 著.

---﻿

VI アキュムレーター

    31 知識の喪失

      31.1 構造的処理の問題点

      31.2 Generative Recursionの問題点

    32 アキュムレーター・スタイルの関数を設計する

      32.1 アキュムレーターの必要性を認識する

      32.2 アキュムレーターの追加

      32.3 関数のアキュムレーター・スタイルへの変換

      32.4 マウスを使ったグラフィカルなエディター

    33 その他のアキュムレーション（蓄積）の使い方

      33.1 アキュムレーターとツリー

      33.2 アキュムレーターを用いたデータ表現

      33.3 結果としてのアキュムレーター

    34 まとめ



=====

ISL+にある引数aに関数fを適用するよう依頼すると、通常は何らかの値vが得られます。実際、何度(f a)の評価を依頼してもvは得られます (関数適用が永久にループしたり、エラーを通知することもありますが、これらの可能性は無視します。また、このルールの真の例外であるランダムも無視します)。関数が初めて適用されるか100回適用されるか、アプリケーションがDrRacketのインタラクションエリアにあるか関数自体の中にあるかは関係ありません。この関数は、その目的の声明に従って動作する、それだけです。

この文脈非依存の原則は、再帰的関数の設計において重要な役割を果たす。設計の際には、目的の声明が約束するものを関数が計算すると仮定する ― たとえ関数がまだ定義されていなくても ― 自由があります。特に、再帰呼び出しの結果を使用して、関数のコードを（たいていは通常cond句の1つにおいて）作成することは自由です。構造的再帰関数と生成的再帰関数の設計レシピのテンプレートとコーディングのステップは、この考え方に依存しています。

文脈非依存は関数の設計を容易にする一方で、2つの問題を引き起こします。一般に、文脈非依存は再帰的評価の際に知識の喪失を引き起こす。関数は、完全なリストに対して呼ばれたのか、リストの一部に対して呼ばれたのか「知りません」。構造的に再帰的なプログラムでは、この知識の喪失は、データを2回以上走査する必要があることを意味し、それはパフォーマンスのコストを引き起こします。また、生成的再帰を用いる関数では、この損失は関数が結果を全く計算できないことを意味します。前節では、グラフ探索関数が循環グラフの2ノード間の経路を見つけることができない問題を説明しました。

このパートでは、この「コンテキストの喪失」の問題に対処するための設計レシピの変種を紹介します。(f a) は何度でも、どこで評価されても同じ結果を返すという原則を維持したいので、唯一の解決策は関数呼び出しのコンテキストを表す引数を追加することです。この追加引数をアキュムレーターと呼ぶことにします。データの探索中、再帰的呼び出しは通常の引数を受け取り続けるが、アキュムレーターはそれらとコンテキストの関係で変化する。

アキュムレーターを使った関数を正しく設計することは、以前の章のどの設計アプローチよりも明らかに複雑です。重要なのは、本来の引数とアキュムレーターの関係を理解することです。以降の章では、アキュムレーターを使用した関数の設計方法と、アキュムレーターがどのように機能するかを説明します。


=====

31 知識の喪失

構造的なレシピに従って設計された関数、そして生成的なレシピに従って設計された関数は、仕組みは異なりますが、知識の喪失に悩まされます。本章では、コンテキストの喪失が関数のパフォーマンスにどのような影響を及ぼすか、2つの例（各カテゴリから1つずつ）を挙げて説明する。最初のセクションでは構造的再帰性、次のセクションでは生成的再帰性での懸念事項を取り上げます。

=====

31.1 構造的な処理に関する問題

まず、一見わかりやすい例から見てみましょう：

サンプル問題： あなたは、道路セグメントの長さを測定するジオメトリ・チームで働いています。このチームはあなたに、一連の道路点間の相対距離を、ある出発点からの絶対距離に変換するプログラムを設計するよう依頼しました。

例えば、以下のような線が与えられるかもしれません：

    -----●----●-------●---●---●---
      50    40      70     30   30

各数値は、2つの点の間の距離を指定します。必要なのは次の図のようなもので、各点は左端までの距離で注釈されている。

    -----●----●-------●---●---●---
         50    90      160  190  220

この計算を行うプログラムを設計することは、単なる構造再帰関数の設計の練習問題です。図177はその完全なプログラムです。与えられたリストが'()でないとき、自然再帰は(rest l)の最初の点に対する残りの点の絶対距離を計算します。1つ目の数は実際の最初の点ではなく、最初の点までの距離が(first l)であるため、自然再帰の結果上の各数値に(first l)を追加しなければなりません。この2番目のステップ、すなわち、数のリスト上の各要素に数を追加するためには、補助関数が必要である。

; [List-of Number] -> [List-of Number]
; 相対距離のリストを絶対距離に変換する。
; 最初の数値は最初の点までの距離を表す。

(check-expect (relative->absolute '(50 40 70 30 30))
             '(50 90 160 190 220))

(define (relative->absolute l)
  (cond
    [(empty? l) '()]
    [else (local ((define rest-of-l
                    (relative->absolute (rest l)))
                  (define adjusted
                    (add-to-each (first l) rest-of-l)))
            (cons (first l) adjusted))]))

; Number [List-of Number] -> [List-of Number]
; l の各数値に n を加える。

(check-expect (cons 50 (add-to-each 50 '(40 110 140 170)))
              '(50 90 160 190 220))

(define (add-to-each n l)
  (cond
    [(empty? l) '()]
    [else (cons (+ (first l) n) (add-to-each n (rest l)))]))

    図177:相対距離から絶対距離への変換


このプログラムの設計は比較的簡単であるが、より大きなリストで使用すると、問題が明らかになる。次のような式の評価を考えてみよう。

    (relative->absolute (build-list size add1))

上記のsizeに入れる数を大きくすればするほど、必要な時間はさらに長くなります。

    size    1000    2000    3000    4000    5000    6000    7000
    時間	    25     109     234     429     689     978    1365


1000個から2000個になると、時間は2倍になるのではなく、4倍になるのです。2000個から4000個になる場合なども、おおよそこのような関係になります(コンピュータや年によって、時間は異なります。今回の測定はOS X 10.11を搭載したMac Miniで2017年に行われました。前回(第1版のとき)の測定は1998年に行われましたが、時間は上記の値の100倍以上になっていました)。"インターメッツォ 5: 計算のコスト" の用語を用いると、関数の性能はO(n^2)となります(nは与えられたリストの長さです)。


練習問題489
map と lambda を使って add-to-each を再定式化しなさい。■


練習問題490
relative->absolute の抽象的な実行時間を表す式を作成しなさい。ヒント 次の式

    (relative->absolute (build-list size add1))

を手で評価してみましょう。まず、サイズを1,2,3と置き換えてみてください。relative->absolute と add-to-each の再帰は毎回何回必要でしょうか？■


問題の単純さを考えると、このプログラムの作業量には驚かされます。もし、同じリストを手作業で変換するとしたら、その点までの総距離を集計し、それを相対距離に足しながら一歩一歩進んでいくだけでしょう。なぜ、プログラムはそうすることができないのでしょうか。

ここで、我々の手による評価に近い関数を設計することを試みる。やはりリスト処理のテンプレートから始めます。

(define (relative->absolute/a l)
  (cond
    [(empty? l) ...]
    [else
     (... (first l) ...
      ... (relative->absolute/a (rest l)) ...)]))

では、手で評価するのを実際にシミュレートしてみましょう。

    (relative->absolute/a (list 3 2 7))
    == (cons ...3 ... (relative->absolute/a (list 2 7))
    == (cons ...3 ...
         (cons ... 2 ...
           (relative->absolute/a (list 7)))
    == (cons ...3 ...
         (cons ... 2 ...
           (cons ... 7 ...
             (relative->absolute/a '())))

結果のリストの最初の要素は明らかに3であるべきで、このリストを作成するのは簡単です。しかし、2番目の要素は (+ 3 2) であるべきですが、relative->absolute/a の2番目のインスタンスは元のリストの最初の要素が3であることを「知る」術がないため、「知識」は失われています。

ここでも問題なのは、再帰的な関数はそのコンテキストと独立することです。ある関数は(cons N L)のLを(cons K L)と同じように処理します。実際、Lを単体で与えられても、そのようにリストを処理することになります。

この「知識」の喪失を補うために、この関数に accu-dist という追加パラメーターを与えます。これは、相対距離のリストを絶対距離のリストに変換する際に保持する集計値です。その初期値は0でなければならず、関数がリストを走査するとき、その数を集計に加えなければなりません。

以下は、改訂後の定義です。

(define (relative->absolute/a l accu-dist)
  (cond
    [(empty? l) '()]
    [else
     (local ((define tally (+ (first l) accu-dist)))
       (cons tally
         (relative->absolute/a (rest l) tally)))]))

再帰的アプリケーションはリストの残りと原点に対する現在の点の新しい絶対距離を消費します。両方の引数は呼び出すたびに変化しますが、2番目の引数の変化は厳密に1番目の引数に依存します。この関数は、まだ単純なリスト処理手続きです。

ここで、もう一度、実行例の評価をしてみましょう。

(relative->absolute/a (list 3 2 7))
== (relative->absolute/a (list 3 2 7) 0)
== (cons 3 (relative->absolute/a (list 2 7) 3))
== (cons 3 (cons 5 (relative->absolute/a (list 7) 5)))
== (cons 3 (cons 5 (cons 12 ???)))
== (cons 3 (cons 5 (cons 12 '())))

ストップ! 4行目のクエスチョンマークを埋めてください。

手による評価では、アキュムレーターの使用により、変換処理がどれほど簡素化されるかを示しています。リスト中の各要素は一度だけ処理されます。relative->absolute/a が引数リストの最後に到達したとき、結果は完全に決定され、それ以上の処理は必要ありません。一般に、この関数はN個の要素を持つリストに対して、N個の自然回帰ステップのオーダーで実行される。

1つの問題は、relative->absoluteと違って、この新しい関数は1つだけでなく2つの引数を消費することです。さらに悪いことに、誰かが誤ってrelative->absolute/aを数値のリストと0でない数値に適用して誤用するかもしれません。ローカル定義を使用してrelative->absolute/aをカプセル化する関数定義により、両方の問題を解決できます。これで、relative->absoluteは入出力に関してrelative->absolute.v2と区別がつかなくなりました。

; [List-of Number] -> [List-of Number]
; 相対距離のリストを絶対距離に変換する。
; 最初の数値は原点までの距離を表す

(check-expect (relative->absolute.v2 '(50 40 70 30 30))
              '(50 90 160 190 220))

(define (relative->absolute.v2 l0)
  (local (
    ; [List-of Number] Number -> [List-of Number]
    (define (relative->absolute/a l accu-dist)
      (cond
        [(empty? l) '()]
        [else
          (local ((define accu (+ (first l) accu-dist)))
            (cons accu
                 (relative->absolute/a (rest l) accu)))])))
    (relative->absolute/a l0 0)))

    図178 アキュムレーターによる相対距離の変換

では、このバージョンのプログラムがどのように動作するのかを見てみましょう。そのために

    (relative->absolute.v2 (build-list size add1))

を評価し、いくつかの size の値について結果を表にします。

    size	   1000    2000    3000    4000    5000    6000    7000
    時間        0       0       0       0       0       1       1

驚くべきことに、relative->absolute.v2はこのようなリストの処理に、7000個の数字のリストであっても1秒以上かかることはないのです。この性能とrelative->absoluteの性能を比較すると、アキュムレーターがすべての低速プログラムの特効薬であるかのように思えるかもしれません。残念ながらそうではありませんが、構造的に再帰的な関数が自然回帰の結果を再処理しなければならない場合、アキュムレーターの使用を検討する必要があります。この特別なケースでは、パフォーマンスは O(n^2) から O(n) に改善されました - 定常的な大きな減少とともに。


練習問題491
ちょっとした設計とちょっとした工夫で、あなたの友人がサンプル問題に対して次のような解答を出しました (Adrian German と Mardin Yadegar がこの演習を提案しました)。

(define (relative->absolute l)
 (reverse
   (foldr (lambda (f l) (cons (+ f (first l)) l))
          (list (first l))
          (reverse (rest l)))))

この単純な解決策は、よく知られたISL+の関数であるreverseとfoldrを使うだけです。lambdaを使うのは、ご存知のように、単なる便宜的なものです。また、この本の最初の2つのパートで紹介された設計レシピでfoldrが設計可能であることは、「抽象化」で思い出したかもしれません。

あなたの友人の解答は、この動機付けのセクションにおける私たちの複雑な設計は必要ないということを意味しますか？その答は、「32.1 アキュムレーターの必要性を認識する」を参照してください。ヒント 自分で reverse 関数 (https://docs.racket-lang.org/htdp-langs/intermediate-lam.html#%28def._htdp-intermediate-lambda._%28%28lib._lang%2Fhtdp-intermediate-lambda..rkt%29._reverse%29%29) の設計してみましょう。■


=====

31.2 生成的再帰の問題点

ここで、グラフにおける経路に沿って「移動する」という問題をもう一度考えてみよう。

サンプル問題 単純グラフにおいて2つのノードが接続されているかどうかをチェックするアルゴリズムを設計しなさい。このようなグラフでは、各ノードは他のノード、そして場合によってはそれ自身と、ちょうど1つの方向性のある接続を持つ。

「29 バックトラックするアルゴリズム」では、経路を発見しなければならないアルゴリズムの変種をカバーしています。このセクションでは、アルゴリズムのアキュムレーターバージョンの設計に焦点を当てているため、このサンプル問題はそれよりも簡単です。

図179のサンプルグラフを考えてみよう。AからFまでの6つのノードと、6つの接続があります。AからEへの経路にはBとCが含まれなければならない。しかし、AからFへの経路や自分以外のノードからの経路は存在しない。

  a-sgを示すグラフ     (define a-sg
                         '((A B)
                           (B C)
                           (C E)
                           (D E)
                           (λ B)
                           (F F)))

    図179: 単純グラフ

図179の右部分 (訳注 a-sg) は、このグラフをネストされたリストで表現する方法を示しています。各ノードは2つのシンボルからなるリストで表現されます。最初のシンボルはノードのラベルであり、2番目のシンボルは最初のノードから到達可能な1つのノードです。以下は関連するデータの定義です：

    ; SimpleGraph は [List-of Connection] である。
    ; Connection は2つの要素からなるリストである。
    ; (list Node Node)
    ; Node は Symbol である。

これらは、私たちが非形式的に記述したものをそのまま翻訳したものです。

この問題が生成的再帰を求めることは既に分かっているので、(関数の)ヘッダーの素材を作るのは簡単です。

    ; Node Node SimpleGraph -> Boolean
    ; 単純グラフ sg において、始点から終点までの経路は存在するか？

    (check-expect (path-exists? 'A 'E a-sg) #true)
    (check-expect (path-exists? 'A 'F a-sg) #false)

    (define (path-exists? origin destination sg))
      #false)

必要なのは、生成的再帰のレシピの4つの基本的な質問に対する答です。

 ・この問題は、origin と destination 同じであれば自明です。

 ・自明な答は #true です。

 ・origin と destination が異なる場合は、直結した隣接ノードまで移動し、そこから destination を探すしかありません。

 ・新しい問題の解が見つかれば、何もする必要はありません。origin に隣接するノードが destination に接続されていれば、origin も destination に接続されている。そうでなければ、接続はありません。

ここからは、これらの答をISL+で表現すれば、機能の揃ったプログラムが完成します。

; Node Node SimpleGraph -> Boolean
; sgにおいて、始点から終点までの経路が存在するか？

(check-expect (path-exists? 'A 'E a-sg) #true)
(check-expect (path-exists? 'A 'F a-sg) #false)

(define (path-exists? origin destination sg)
  (cond
    [(symbol=? origin destination) #t]
    [else (path-exists? (neighbor origin sg)
                        destination
                        sg)]))

; Node SimpleGraph -> Node
; sgのa-nodeに接続するノードを決定する。
(check-expect (neighbor 'A a-sg) 'B)
(check-error (neighbor 'G a-sg) "neighbor: not a node")
(define (neighbor a-node sg)
  (cond
    [(empty? sg) (error "neighbor: not a node")]
    [else (if (symbol=? (first (first sg)) a-node)
              (second (first sg))
              (neighbor a-node (rest sg)))]))

    図 180。単純グラフの中の経路を見つける

図180は、単純なグラフのあるノードに隣接するノードを見つける関数 ― これは構造的再帰の簡単な練習です ― と、両方の可能な結果に対するテストケースを含む、完全なプログラムです。しかし、このプログラムは実行しないでください。もし実行したら、マウスを使って暴走を止められるようにしておいてください。実際、この関数を何気なく見ただけでも、問題があることがわかります。この関数は、origin から destination までの経路がなければ #false を返すことになっているが、プログラムにはどこにも #false が含まれていないのです。逆に、2つのノード間にパスがないとき、この関数は実際に何をするのか、考えてみる必要があります。

図179をもう一度見てみよう。この単純グラフには、CからDへの道はない。Cから出た接続はDのすぐそばを通り、代わりにEに行く。手での評価をみてみましょう：

    (path-exists? 'C 'D '((A B) ... (F F)))
    == (path-exists? 'E 'D '((A B) ... (F F)))
    == (path-exists? 'B 'D '((A B) ... (F F)))
    == (path-exists? 'C 'D '((A B) ... (F F)))

これは、関数が再帰するとき、全く同じ引数で何度も自分自身を呼び出すことを確認する。つまり、評価は決して止まりません。

path-exists? の問題は、上記の relative->absolute の問題と同様、「知識」の喪失です。relative->absolute と同様に、path-exists? の設計はレシピを使用し、再帰的な呼び出しはコンテキストから独立していると仮定しています。path-exists? の場合、これは特に、関数が、現在の再帰の連鎖の中で前のアプリケーションが全く同じ引数を受け取ったかどうかを知らないということを意味します。

この設計上の問題に対する解決策は、前のセクションのパターンに従います。元の適用から始まる、関数が遭遇したスターターノードの累積リストを表すパラメーターを追加します。これを seen とします。このパラメーターの初期値は'()でなければならない。関数が特定の origin をチェックし、その隣接ノードに移動すると、 origin はseenに追加されます。

ここでは、path-exists? の最初の改訂版を path-exists?/a と名づけました。

; Node Node SimpleGraph [List-of Node] -> Boolean
; 原点から目的地までの経路が存在するか？
; seen の中には、ノードのパスが存在しないと仮定する。
(define (path-exists?/a origin destination sg seen)
  (cond
    [(symbol=? origin destination) #true]
    [else (path-exists?/a (neighbor origin sg)
                          destination
                          sg
                          (cons origin seen))]))

新しいパラメーターの追加だけでは問題は解決しませんが、手で評価したように

    (path-exists?/a 'C 'D '((A B) ... (F F)) '())

は、1つの土台を提供するものです。

    == (path-exists?/a 'E 'D '((A B) ... (F F)) '(C))
    == (path-exists?/a 'B 'D '((A B) ... (F F)) '(λ C))
    == (path-exists?/a 'C 'D '((A B) ... (F F)) '(B E C))

元の関数とは対照的に、改訂された関数はもはや全く同じ引数で自分自身を呼び出すことはありません。最初の再帰的適用の3つの引数は、それから3番目の適用と3つの引数は再び同じですが、アキュムレーターの引数は最初のアプリケーションのそれとは異なっています。'() ではなく、'(B E C) になっています。この新しい値から、'Cから'Dへの経路を探索する間に、関数が'B, 'E, 'Cを開始点として検査したことが分かります。

あとは、蓄積された(accumulated) 知識をアルゴリズムに利用させるだけです。具体的には、与えられた origin がすでに seen の中の要素であるかどうかをアルゴリズムが判断することができる。もしそうなら、この問題は自明に解決可能であり、解として#falseが得られます。図181は、path-exists? の改訂版である path-exists.v2? の定義です。この定義では、ISL+関数である member? 関数を参照しています。

; Node Node SimpleGraph -> Boolean
; sg において origin から destination までの経路が存在するか？

(check-expect (path-exists.v2? 'A 'E a-sg) #true)
(check-expect (path-exists.v2? 'A 'F a-sg) #false)

(define (path-exists.v2? origin destination sg)
  (local (; Node Node SimpleGraph [List-of Node] -> Boolean
          (define (path-exists?/a origin seen)
            (cond
              [(symbol=? origin destination) #t]
              [(member? origin seen) #f]
              [else (path-exists?/a (neighbor origin sg)
                                    (cons origin seen))])))
    (path-exists?/a origin '())))

    図181:アキュムレーターを使用して単純なグラフのパスを検索する

また、path-exists.v2? の定義により、最初の改訂版での2つの小さな問題も解消されました。アキュムレーターを使う関数の定義を局所化することで、最初の呼び出しでは常に '() を seen の初期値として使用するようにすることができます。また、path-exists.v2? は path-exists? 関数と全く同じシグネチャと目的文を満たしています。

それでも、path-exists.v2? と relative-to-absolute2 の間には大きな違いがある。後者が元の関数と同値であったのに対し、path-exists.v2? は path-exists? より改善しています。後者がある入力に対して答を見つけられないのに対して、path-exists.v2? はどんな単純なグラフに対しても解を見つけます。


練習問題 492
図 169 の定義を変更し、同じ始点ノードに 2 回遭遇したとしても #false を返すようにしてください。■



=====

32 アキュムレーター・スタイルの関数を設計する

前章では、追加の知識を蓄積（アキュムレート）することの必要性を2つの例で説明しました。1つは、蓄積することで関数の理解が容易になり、元のバージョンよりもはるかに高速な関数が得られるケースです。もう1つは、蓄積は、関数が正しく動作するのに必要であるケースです。しかし、どちらの場合も、適切に設計された関数が存在して初めて、蓄積の必要性が明らかになります。

前章を一般化すると、アキュムレーター関数の設計には大きく2つの側面があることがわかります。

1. 関数がアキュムレーターから恩恵を受けるという認識。

2. アキュムレーターが何を表しているのかを理解していること。

最初の2つの節は、この2つの疑問を解決するものです。2番目の問題は難しいので、3番目の節では、正規関数をアキュムレーターを使用する関数に変換する一連の例で説明します。

-----
; [List-of X] -> [List-of X]
; aloxの逆を構成する

(check-expect (invert '(a b c)) '(c b a))

(define (invert alox)
  (cond
    [(empty? alox) '()]
    [else
     (add-as-last (first alox) (invert (rest alox)))]))

; X [List-of X] -> [List-of X]
; alox の末尾に an-x を追加する。

(check-expect (add-as-last 'a '(c b)) '(c b a))

(define (add-as-last an-x alox)
  (cond
    [(empty? alox) (list an-x)]
    [else
     (cons (first alox) (add-as-last an-x (rest alox)))]))

    図182:アキュムレーターを用いた設計、構造の例
-----

=====

32.1 アキュムレーターの必要性を認識する

アキュムレーターの必要性を認識することは、簡単な仕事ではありません。私たちは2つの理由を見てきましたが、それらは最も一般に広まったものです。いずれの場合も、まず従来の設計レシピに基づく完全な関数を構築することが肝要です。そして、その機能を研究し、次のように進めていきます：

1. 構造的に再帰的な関数が、その自然回帰の結果を補助的な再帰的な関数で走査する場合、アキュムレーター・パラメーターの使用を検討します。

  図182のinvertの定義を見てみましょう。再帰的な適用(application)の結果は、リストの残りの要素を反転したものを生成します。この反転されたリストに add-as-lastを使用して最初の要素を追加します。その結果、リストの全要素を逆にしたものが作成されます。この2番目の補助関数も再帰的です。このようにして、アキュムレーターの候補を特定することができました。

  ここで、「31.1 構造的処理の問題」のように、手による評価を幾つか調査し、アキュムレーターが役に立つかどうかを確認する必要があります。次のようなものを考えてみましょう：

  (invert '(a b c))
  == (add-as-last 'a (invert '(b c)))
  == (add-as-last 'a (add-as-last 'b (invert '(c))))
  == ...
  == (add-as-last 'a (add-as-last 'b '(c)))
  == (add-as-last 'a '(c b))
  == '(c b a)

  ここで止まってください! 上記の"..."の部分を足りない2つのステップに置き換えてください。このように、invert は ― add-as-last と同じように― 与えられたリストの最後に最終的には到達することがわかります。そして、どの要素をそこに置くかわかっていれば補助関数は必要ありません。

2. もし、生成的再帰に基づく関数を扱うのであれば、もっと難しい問題に直面することになります。我々の目標は、結果を期待する入力に対してアルゴリズムが結果を生成できないことがあるかどうかということを理解することでなければなりません。そうであれば、知識を蓄積するパラメーターを追加することが助けになるかもしれません。このような状況は複雑であるため、例題の議論は「33.1 蓄積のその他の使用法」に譲る。

練習問題493
Intermezzo 5: The Cost of Computation の用語で、与えられたリストが n 個の要素からなるとき、invert は O(n^2) 時間を消費することを論ぜよ。■


練習問題494
「11.3 再帰する補助関数 (Auxiliary Functions that Recur)」 の 挿入 sort> 関数はアキュムレーターを必要とするでしょうか。
もし必要とするなら、それはなぜですか？ 必要としない場合、その理由はなんでしょうか？ ■


=====

32.2 アキュムレーターを追加する

既存の関数にアキュムレーターを追加すべきだということが決めたら、次の2つのステップを踏んでください。

・アキュムレーターが表現する知識、どのような種類のデータを使うか、知識はどのようにデータとして取得されるかを決定する。

  例えば、相対距離から絶対距離への変換は、それまでに遭遇した総距離を合計することで十分です。この関数は相対距離のリストを処理するとき、見つかった新しい相対距離をそれぞれアキュムレーターの現在値に追加します。経路探索問題では、アキュムレーターは遭遇したすべてのノードを記憶しています。経路チェック関数がグラフをトラバースするとき、それぞれの新しいノードをアキュムレーターに cons します。

  一般的には、以下のような手順で進めるとよいでしょう。

  1. アキュムレーターのテンプレートを作成します。

   ; Domain -> Range
   (define (function d0)
     (local (; Domain AccuDomain -> Range
             ; アキュムレーター ...
             (define (function/a d a)
               ...))
       (function/a d0 a0)))

   アキュムレーターの性質を理解するために、関数の適用の手動での評価の略図を描きます。

  2. アキュムレーターが追跡するデータの種類を決定します。

   補助関数 function/a の引数 d と元の引数 d0 との関係としてアキュムレーターを説明する文を書きます。

   注意 評価の間、関係は一定です。この関係は不変量 (invariant) とも呼ばれます。この性質から、アキュムレーターの文はしばしば invariant と呼ばれます。

  3. この不変量を用いて a の初期値 a0 を決定します。

  4. また、この不変量を利用して、function/a の定義内で再帰的な関数呼び出しに対しアキュムレーターを計算する方法を決定します。

・アキュムレーターの知識を利用して function/a を設計します。

  構造的再帰関数の場合、アキュムレーターの値は通常、基本ケース、つまり、再帰しないcond節で使用されます。生成的再帰関数を使用する関数では、蓄積（アキュムレート）された知識は、既存の基本ケース、新しい基本ケース、または生成的再帰を扱うcond節で使用されるかもしれません。

このように、アキュムレーターの役割を正確に記述することがポイントです。したがって、この技術を練習することが重要です。

invert の例を見てみましょう。

(define (invert.v2 alox0)
  (local (; [List-of X] ??? -> [List-of X]
            ; aloxの逆を構成する
            ; アキュムレーター ...
            (define (invert/a alox a)
            (cond
              [(empty? alox) ...]
              [else
               (invert/a (rest alox) ... a ...)])))
    (invert/a alox0 ...)))

前節で説明したように、このテンプレートは、次のように例の手動評価をスケッチするのに十分です：

    (invert '(a b c))

次のようなアイデアです：

    == (invert/a '(a b c) a0)
    == (invert/a '(b c) ... 'a ... a0)
    == (invert/a '(c) ... 'b ... 'a ... a0)
    == (invert/a '() ... 'c ... 'b ... 'a ... a0)


このスケッチは、alox0 と a の差を逆順に追跡するリストで見たことのあるすべての要素を、invert/a が 追跡できることを示唆しています。初期値は明らかに '() です； invert/a の内部のアキュムレーターを cons で更新すると、invert/a が '() に到達したときに望ましい値がちょうど生成されます。

これらの洞察を盛り込んだ洗練されたテンプレートが次のものになります。

(define (invert.v2 alox0)
  (local (; [List-of X] [List-of X] -> [List-of X]
          ; alox の逆を構成する。
          ; アキュムレーター a は、alox0 にあるすべての要素を逆順にならべたリストになります。← 訳が変？
          ; alox0 は alox より前に invert/a に渡される引数です。← 訳が変？
          (define (invert/a alox a)
            (cond
              [(empty? alox) a]
              [else
               (invert/a (rest alox)
                         (cons (first alox) a))])))
    (invert/a alox0 '())))

ローカルでの定義の本体が'()でアキュムレーターを '() で初期化するのに対して、再帰呼び出しでは cons を使って alox の現在の先頭をアキュムレーターに追加しています。基本ケースでは、invert/a はアキュムレーター内の知識、つまり反転したリストを使用します。

ここでもまた、invert.v2 は単にリストを走査していることに注意してください。これに対して、invert は add-as-last で自然再帰の結果をすべて再処理します。ストップ! invert.v2 が invert.v2 よりどれだけ速く動くかを測定してください。

用語: プログラマは、アキュムレーター・パラメーターを使用する関数について、アキュムレーター・スタイルの関数 (accumulator-style function)というフレーズを使用します。アキュムレーター・スタイルの関数の例としては、relative->absolute/a、invert/a、path-exists?/aがあります。


=====

32.3 関数をアキュムレーター式に変換する

アキュムレーター文の定式化は難しいですが、良い不変量を定式化しなければ、アキュムレーター・スタイルの関数を理解することは不可能です。プログラマーの目的は、後続の人がコードを理解しやすいようにすることですから、このスキルを練習することは非常に重要です。そして、不変量の定式化はたくさんの量の練習に値します。

本節の目的は、アキュムレーター文の定式化を、和算関数、階乗関数、木-探索関数の3つのケーススタディで学ぶことです。それぞれのケースは、構造的再帰関数をアキュムレータースタイルに変換するものです。実際にアキュムレーターのパラメーターを使用するものはありません。しかし、これらは容易に理解でき、他のすべての雑念を排除し、このような例を使用することで、アキュムレーターの不変量の表現に集中することができます。

最初の例として、以下の sum 関数の定義を考えてみましょう。

(define (sum.v1 alon)
  (cond
    [(empty? alon) 0]
    [else (+ (first alon) (sum.v1 (rest alon)))]))

次は、アキュムレーター版への第一歩です。

(define (sum.v2 alon0)
  (local (; [List-of Number] ??? -> Number
          ; alonにある数の合計を計算します
          ; アキュムレーター ...
          (define (sum/a alon a)
            (cond
              [(empty? alon) ...]
              [else (... (sum/a (rest alon)
                     ... ... a ...) ...)])))
    (sum/a alon0 ...)))

ここで止まってください！ 両方に対応した署名とテストケースを用意してください。

最初のステップで提案したように、sum/a のテンプレートをローカル定義に入れ、アキュムレーターパラメーターを追加し、sum のパラメーターをリネームしました。

            (sum.v1 '(10 4))
            == (+ 10 (sum.v1 '(4)))
            == (+ 10 (+ 4 (sum.v1 '())) == (+ 10 (+ 4 ()))
            == (+ 10 (+ 4 (+ 0)))
            ...
            == 14

            (sum.v2 '(10 4))
            == (sum/a '(10 4) a0)
            == (sum/a '(4) ...10 ... a0)
            == (sum/a '() ...4 ... 10 ... a0)
            ...
            == 14

    図183 アキュムレーター・スタイルのテンプレートで計算する

図183は、手での評価のスケッチを2つ並べたものである。比較すると、すぐに中心的なアイデア、すなわち、sum/aはアキュムレーターを使用して、遭遇した数を加算できることが示唆されます。アキュムレーターの不変量に関して、計算は a がこれまでに遭遇した数の合計を表すことを示唆して。

    aは、alon0にあってalonにない数字の合計である。

例えば、この不変量は次のような関係を強制的に成立させます。

  alon0 = '(10 4 6)
  alon  = '(4 6)
   の場合 a = 10 です。

  alon0 = '(10 4 6)
  alon  = '(6)
   の場合 a = 14 です。

  alon0 = '(10 4 6)
  alon  = '()
   の場合 a = 20 です。

この正確な不変量があれば、残りの設計は簡単です:

(define (sum.v2 alon0)
  (local (; [List-of Number] Number -> Number
          ; alon上の数値の和を計算する。
          ; アキュムレーター aはalon0にあってalonにない数の和です。
          (define (sum/a alon a)
            (cond
              [(empty? alon) a]
              [else (sum/a (rest alon)
                           (+ (first alon) a))])))
    (sum/a alon0 0)))

alon が'()の場合、sum/a は alon上のすべての数の和を表すので、a を返します。この不変量はまた、0 が a0 の初期値であることを意味し、+ はこれから "忘れられる" ― (first alox) ― 数をアキュムレーター a に加えることによってアキュムレーターを更新します。


練習問題495
図183の(sum/a '(10 4) 0)の手動評価を完成させなさい。そうすると、sumとsum.v2は与えられた数字を逆順に足し算していることがわかる。sum が右から左へ数を加算するのに対して、アキュムレータースタイルは左から右へ加算する。

数に関する注意点: 正確な数値(exact numbers)の場合、この差は最終結果に影響を与えないことを覚えておいてください。不正確な数(inexact numbers)では、この差は大きなものになります。"インテルメッツォ5：計算のコスト" の最後にある練習問題を参照してください。■


2つ目の例として、よく知られている階乗関数を紹介します(階乗関数はアルゴリズムの解析に有用です)。

  ; N -> N
  ; (* n (- n 1) (- n 2) ....1) を計算する
  (check-expect (!.v1 3) 6)
  (define (!.v1 n)
    (cond
      [(zero? n) 1]
      [else (* n (!.v1 (sub1 n)))]))

relative-2-absolute と invert がリストを処理するのに対して、factorial関数は(複数の)自然数で動作し、そのテンプレートが反映されます。

前回同様、アキュムレーター・スタイルのテンプレートで進めます：

(define (!.v2 n0)
  (local (; N ??? -> N
          ; computes (* n (- n 1) (- n 2) ... 1)
          ; accumulator ...
          (define (!/a n a)
            (cond
              [(zero? n) ...]
              [else (... (!/a (sub1 n)
                              ... a ...) ...)])))
    (!/a n0 ...)))

以下は手での評価のスケッチです：

    (!.v1 3)
    == (* 3 (!.v1 2))
    == (* 3 (* 2 (!.v1 1)))
    ...
    == 6

    (!.v2 3)
    == (!/a 3 a0)
    == (!/a 2 ... 3 ... a0)
    ...
    == 6

左 (ここでは上) の列はオリジナル版の動作、右 (ここでは下)の列はアキュムレーター・スタイルの関数がどう動作するかの概略を示します。どちらも0に達するまで自然数を構造的に走査します。オリジナル版が乗算だけをスケジュールするのに対し、アキュムレーターは与えられた自然数を構造的に走査する際に各数を追跡します。

これらの数を掛け合わせるという目的が与えられると、!/a は数を掛け合わせるためにすぐにアキュムレーターを使うことができます。

    a は区間 [n0,n) にある自然数の積である。

特に、n0 が3, n が1のとき、a は6となります。


練習問題496
n0 が 10, n が 8 のとき、a の値はどうなるべきでしょうか。■


この不変量を使って、aの初期値 ― つまり1 ―を簡単に選ぶことができ、現在のアキュムレーターにnを乗じることが適切な更新操作であることがわかります。

(define (!.v2 n0)
  (local (; N N -> N
          ; 計算する (* n (- n 1) (- n 2) ...)1)
          ; アキュムレーターaは、区間[n0,n]の自然数の積である。
          (define (!/a n a)
            (cond
              [(zero? n) a]
              [else (!/a (sub1 n) (* n a))])))
    (!/a n0 1)))

また、アキュムレーターの記述から、nが0のとき、アキュムレーターはnから1までの積、つまり目的の結果であることがわかります。つまり、sumと同様に、!/a はこの場合は a を返し、2番目の場合は再帰の結果を使用します。

練習問題497
sumと同様に、!.v1は原始的な計算、この場合は乗算を逆順で実行します。意外なことに、これは関数の性能にマイナスの影響を与えます。

(!.v1 20)を1,000回評価するのにかかる時間を測定してください。(time an-expression) 関数が、an-expression を実行にかかる時間を決定することを思い出してください。■

最後の3番目の例では、簡略化された二分木の高さを測定する関数を使用します。この例は、アキュムレーター・スタイルのプログラミングが、単一の自己参照で定義されたデータだけでなく、あらゆる種類のデータに適用できることを示しています。実際、リストや自然数と同様に、複雑なデータ定義によく使われます。

以下は、関連する関数の定義です：

    (define-struct node [left right])
    ; Tree は以下のいずれかである。
    ; ? '()
    ; ? (make-node Tree Tree)
    (define example
      (make-node (make-node '() (make-node '() '())) '()))

これらの木は情報を持ちません。葉は '() です。しかし、図184が示すように、多くの異なる木があります。また、これらのデータが木としてどのように見えるか、示唆的な図形を使って説明しています。

次のような木の高さを計算したい場合があるとします：

(define (height abt)
  (cond
    [(empty? abt) 0]
    [else (+ (max (height (node-left abt))
                  (height (node-right abt))) 1)]))


ここで止まってください！ 署名とテストを書いてください。図184の表は木の高さの測定方法を示していますが、その概念はやや曖昧です：つまり木の根から最も高い葉までのノード数か、その経路上の接続数のいずれかです。関数 height は2番目に従います。

            イメージ

            	'()


            イメージ

            	(make-node '() '())


  イメージ

  (make-node
    (make-node '()
               (make-node '() '()))
    '())


    図184：いくつかの要素を取り除いた二分木

この関数をアキュムレーター・スタイルの関数に変換するために、標準的な方法を取ります。まず、適切なテンプレートから始めます。

(define (height.v2 abt0)
  (local (; Tree ??? -> N
          ; abtの高さを測定する
          ; accumulator ...
          (define (height/a abt a)
            (cond
              [(empty? abt) ...]
              [else
                (... (height/a (node-left abt)
                               ... a ...) ...
                 ... (height/a (node-right abt)
                               ... a ...) ...)])))
    (height/a abt0 ...)))

いつものように、問題はアキュムレーターがどのような知識を表しているかを決定することです。明らかな選択肢の1つは、通過した辺の数です。

    a は abt0 から abt に到達するのにかかるステップ数である。


このアキュムレーターの不変量を説明するには、図の例で説明するのが最適です。図184をもう一度見てください。一番下の木には2つの注釈があり、それぞれが1つのサブツリーを指しています。

1. abt0 が完全な木であり、かつ abt が丸で囲んだ1が指す部分木だとすると、abtのルートからabt0のルートに行くのにちょうど1ステップかかるので、アキュムレーターの値は1でなければなりません。

2. 同じように、図184の一番下の図で 2というラベルの付いたサブツリーでは、ここに到達するまでに2ステップかかるので、アキュムレーターは2です。

上記の2つの例に関して、不変量はアキュムレーターのデザインレシピの残りをどう辿るかを指示します：aの初期値は0、更新操作はadd1、基本ケースはアキュムレートされた知識を返すことでそれを使用します。これをコードに置き換えると、次のような骨格となる定義が得られます。

(define (height.v2 abt0)
  (local (; Tree N -> N
         ; abtの高さを測定する
         ; アキュムレーター a はステップ数を示します。
         ; それは abt0 から abt に到達するのに必要なステップ数です。
         (define (height/a abt a)
            (cond
              [(empty? abt) a]
              [else
                (... (height/a (node-left abt)
                               (+ a 1)) ...
                 ... (height/a (node-right abt)
                               (+ a 1)) ...)])))
    (height/a abt0 0)))

しかし、最初の2つの例とは対照的に、aは最終的な結果ではありません。2番目のcond節では、2つの再帰的な呼び出しによって2つの値が得られます。構造的な関数の設計レシピでは、この場合の答えを出すために、これらを組み合わせることになっています; 上の関数定義における点 (...) は、これらの値を組み合わせる演算を選ぶ必要があることを示しています。

; Tree -> N
; abt0 の高さを測定する
(check-expect (height.v2 example) 3)
(define (height.v2 abt0)
  (local (; Tree N -> N
          ; abtの高さを測定する
          ; アキュムレーター a はステップ数を示します。
          ; それは abt0 から abt に到達するのに必要なステップ数です。
          (define (height/a abt a)
            (cond
              [(empty? abt) a]
              [else
               (max
                 (height/a (node-left abt)  (+ a 1))
                 (height/a (node-right abt) (+ a 1)))])))
    (height/a abt0 0)))

    図185  アキュムレータータイプのバージョンの 関数 height


設計レシピに従うと、2つの値を解釈して適切な関数を見つける必要があることもわかります。height/a の目的の声明によると、最初の値は左のサブツリーの高さ、2番目の値は右のサブツリーの高さです。私たちは abt 自体の高さに興味があり、高さは葉に到達するのにかかる最大のステップ数であることを考えると、適切なものを選ぶために max 関数を使用します；完全な関数定義については図185を参照してください。


代替的なデザインに関するメモ: ノードに到達するまでのステップ数をカウントすることに加え、アキュムレーター関数はこれまでに遭遇した最大の高さを保持できるでしょう。以下は、この設計のアイデアに対するアキュムレーターについての声明です。

    最初のアキュムレーターは abt0（のルート）から abt に到達するのにかかるステップ数を表しています。2番目のアキュムレーターはabt0においてabtの左側にある部分(木)の厳密な高さを表します。

明らかに、この声明は2つのアキュムレーター・パラメーターを持つテンプレートを想定しており、これまで我々が遭遇したことがないものです。

... ;Tree N N -> N
    ; abtの高さを測定する。
    ; アキュムレーターsはabt0からabtに到達するのにかかるステップ数を表す。
    ; アキュムレーターmはabt0の部分の最大の高さである。
    ; abt0はabtの左側にある部分木である。??
    (define (h/a abt s m)
      (cond
        [(empty? abt) ...]
        [else
         (... (h/a (node-left abt)
                   ... s ... ... m ...) ...
          ... (h/a (node-right abt)
                   ... s ... ... m ...) ...)])) ...


練習問題 498
height.v3 を完成させてください。
ヒント 図184の最下段の木には、1で印をつけた部分木の左側の部分に(さらなる)部分木がありません。この木には、2で印をつけた部分木の左側の部分に、根から木への完全な経路が1つあります。この経路は2ステップで構成されます。■



この2つ目の設計は、1つ目の設計よりも複雑なアキュムレーター不変量を持っています。そのため、その実装には、最初のものよりも注意が必要です。同時に、明らかな利点もありません。

私たちが言いたいのは、アキュムレーターの不変量が異なれば、異なるバリエーションが生まれるということです。同じ設計レシピに従って、両方の変種を系統的に設計することができます。関数定義が完成したら、その結果を比較・対照し、証拠に基づいてどちらを残すかを決めることができます。代替のデザインに関するメモ 終了


練習問題499
リストにある数の積を計算する関数、product のアキュムレーター・スタイル版を設計しなさい。アキュムレーターの不変量を定式化したところでいったん止まって、誰かにチェックしてもらってください。

product の性能は O(n) (n はリストの長さ) です。それはアキュムレーター版で改善されるでしょうか？■


練習問題500
リスト上の要素の数を決定する関数である how-many のアキュムレーター・スタイル版を設計しなさい。アキュムレーターの不変量を定式化したところでいったん止まって、誰かにチェックしてもらってください。

how-many の性能は O(n) で、n はリストの長さです。アキュムレーター版はこれを改善するのでしょうか？

（コンピュータ科学者はこの空間をスタック空間と呼ぶことがありますが、今のところこの用語は無視しても大丈夫です）

(how-many some-non-empty-list) を手で評価する場合、関数が '() に到達するまでに、add1 の n (n:リスト上の要素の数) 個 の適用がペンディングしてしまいます。アキュムレーターは結果を計算するために必要なスペースを減らすことができますか？■


練習問題501
add-to-pi のアキュムレーター・スタイルのバージョンを設計してください。この関数は、+ を使わずに円周率piに自然数を加算する。

    ; N -> Number
    ; + を使わずに pi に n を足す。
    (check-within (add-to-pi 2) (+ 2 pi) 0.001)
    (define (add-to-pi n)
      (cond
        [(zero? n) pi ]
        [else (add1 (add-to-pi (sub1 n)))]))

アキュムレーターの不変量を定式化したところでいったん止まって、誰かにチェックしてもらってください。


練習問題502
空でないリストを受け取り、最後の要素を中心にリストをミラーリングして回文を構成する関数 palindrome を設計しなさい。(explode "abc") が与えられると、 (explode "abcba") が得られます。

ヒント 関数合成で設計された解は以下のようになります。

    ; [NEList-of 1String] -> [NEList-of 1String]
    ; s0 から回文を生成する
    (check-expect
      (mirror (explode "abc")) (explode "abcba"))
    (define (mirror s0)
      (append (all-but-last s0)
              (list (last s0))
              (reverse (all-but-last s0))))

last については「11.4 一般化する補助関数」を参照してください； all-but-last を類似の方法で設計してください。

解はs0を4回走査 (traverse) します。

1. all-but-last を経由して。

2. last 経由で。

3. 再度 all-but-last 経由で。

4. ISL+ 版の invert である reverse を経由して。

all-but-lastの結果をローカルに定義しても、この関数は3回の走査を必要とします。これらの走査は"スタック"されないので、この関数の性能に大きな影響を与えませんが、アキュムレーター版では、1回の走査で同じ結果を計算することができます。■


演習問題503
演習問題467では、行列において、最初の行の最初の係数が0と異なるまで行列を回転させる関数の設計が暗黙のうちに求められています。演習問題467のコンテキストでは、最初の位置に0があると、最初の行を最後にシフトして新しい行列を作る生成-再帰関数が解として求められています。以下はその解です。

  ; Matrix -> Matrix
  ; 0 で始まらない行を見つけ
  ; それを最初の行として使用します。
  ; 生成的に最初の行を最後尾に移動させる。
  ; すべての行が0から始まる場合、終了しない。
  (check-expect (rotate '((0 4 5) (1 2 3)))
                '((1 2 3) (0 4 5)))
  (define (rotate M)
    (cond
      [(not (= (first (first M)) 0)) M]
      [else
        (rotate (append (rest M) (list (first M))))]))

ここでストップしてください。すべての行が 0 で始まるとき、エラーを通知するようにこの関数を修正してください。

この関数を大規模なMatrixのインスタンスで測定すると、意外な結果が得られる。

    Mにおける行数   1000    2000    3000    4000    5000
     rotateの回数     17      66     151     272     436

行数が1,000から5,000になると、rotateに費やす時間は5倍ではなく、20倍になる。

問題はrotateがappendを使っていることです。appendでは (rest M)のような全く新しいリストを作り、最後に(first M)を追加するだけです。Mが1,000行で、最後の行が0でない係数を持つ唯一の行であるとすると、およそ

    1,000・1,000 = 1,000,000

のリストです。Mが5,000行で構成されている行列の場合、リストはいくつになるのでしょうか？

ここで、アキュムレーター・スタイル版の方が生成的なものよりも高速であると推測すると、次のようになります。以下は、rotate の構造的再帰バージョンのアキュムレーター・テンプレートです：

    (define (rotate.v2 M0)
      (local (; Matrix ... -> Matrix
              ; アキュムレーター ...
              (define (rotate/a M seen)
                (cond
                  [(empty? (rest M)) ...] ;これは (empty? M) に簡略化できるか？
                  [else (... (rotate/a (rest M)
                                       ... seen ...)
                         ...)])))
        (rotate/a M0 ...)))

目標は、再帰のたびにappendを使わずに、先頭の係数が0であるときの最初の行を記憶することです。

アキュムレーター・ステートメントを策定します。次に、アキュムレーターの設計レシピに従って、上記の関数を完成させます。最後の行を除いて先頭が 0 の行からなる Matrix 上で、この関数がどの程度速く動作するかを測定してください。設計が正しく完了すれば、この関数はかなり高速に動作します。■


演習問題504
関数 to10 を設計してください。これは数字のリストを消費し、それに対応する数字を生成します。リストの最初の要素は最上位の桁である。したがって、'(1 0 2)に適用すると、102が生成されます。

領域知識 小学校で習ったことを思い出すかもしれませんが、結果は 1・10^2 + 0・10^1 + 2・10^0 = ((1・10 + 0)・10) + 2 = 102 で決まります。■


練習問題505
自然数を消費して、それが素数であれば #true を、そうでなければ #false を返す関数 is-prime を設計しなさい。

領域知識 数nは、(n - 1)から2までの任意の数によって割り切れない場合、素数である。

ヒント N [>=1] の設計レシピでは、次のようなテンプレートを提案しています。

    ; N [>=1] -> Boolean
    ; nが素数であるかどうかを判定する。
    (define (is-prime? n)
      (cond
        [(= n 1) ...]
        [else (... (is-prime? (sub1 n)) ...)])

このテンプレートでは、関数が再帰する際に初期引数であるnを忘れてしまうことが即座に分かります。nはnが(- n 1)、(- n 2)などで割り切れるかどうかを決定するのに確実に必要なので、アキュムレーター・スタイルの関数が必要なことが分かります。■


速度に関する注意 初めてアキュムレーター・スタイルの関数に出会ったプログラマは、アキュムレーター・スタイル の関数は通常の関数より常に速いという印象を持つことが多いようです。そこで、練習問題497の解答を見てみましょう。

    !.v1    5.760    5.780    5.800    5.820    5.870    5.806

    !.v2    5.970    5.940    5.980    5.970    6.690    6.111

この表は上段(の2列目から6列目) が(!.v1 20)を5回実行したときの秒数、下段(の2列目から6列目) が(!.v2 20)を(5回)実行したときの秒数を示します。最後の列は平均値を示します。要するに、この表は人々が早合点しがちなことを示しています。少なくともあるアキュムレーター・スタイルの関数の性能はオリジナル版の性能より悪いのです。先入観を信用してはいけません。その代わり、自分自身でプログラムの性能特性を測定してください。 速度に関する注意 おわり


練習問題506
mapのアキュムレーター・スタイルバージョンを設計してください。■


演習問題507
練習問題257は、本書の最初の2つのパートのデザインレシピとガイドラインでfoldlをデザインする方法を説明しています。

  (check-expect (f*ldl + 0 '(1 2 3))
                (foldl + 0 '(1 2 3)))
  (check-expect (f*ldl cons '() '(a b c))
                (foldl cons '() '(a b c)))
  ; バージョン1
  (define (f*ldl f i l)
    (foldr f i (reverse l)))

つまり、foldl は、与えられたリストを反転させ、その中間的なリストに対し与えられた関数を foldrを使って fold した結果です。

f*ldl  関数は明らかに2回リストを走査していますが、関数をすべて設計すると、それが機能するのはいかに困難であるかが明らかになります：

; バージョン2
; version 2
(define (f*ldl f i l)
  (local ((define (reverse l)
            (cond
              [(empty? l) '()]
              [else (add-to-end (first l)
                                (reverse (rest l)))]))
          (define (add-to-end x l)
            (cond
              [(empty? l) (list x)]
              [else (cons (first l)
                          (add-to-end x (rest l)))]))
          (define (foldr l)
            (cond
              [(empty? l) i]
              [else (f (first l) (foldr (rest l)))])))
    (foldr (reverse l))))

reverse 関数はリスト上の各要素に対してリストを一度スキャンしなければならないことを私たちは知っていますが、それは f*ldl は長さ n のリストに対して実際に n^2 回の走査を行うことを意味します。幸い、アキュムレーターを使ってこのボトルネックを解消する方法を私たちは知っています：

; version 3
(define (f*ldl f i l)
  (local ((define (reverse/a l a)
            (cond
              [(empty? l) a]
              [else (reverse/a (rest l)
                              (cons (first l) a))]))
          (define (foldr l)
            (cond
              [(empty? l) i]
              [else
               (f (first l) (foldr (rest l)))])))
    (foldr (reverse/a l '()))))

reverse 関数がアキュムレーターを使用すると、実際にはリストの2回の走査の見かけ上の実績が得られます。問題は、ローカルに定義された foldr にアキュムレーターを追加することによって、これを改善できるかどうかです：

;バージョン4
(define (f*ldl f i l0)
  (local ((define (foldr/a a l)
            (cond
              [(empty? l) a]
              [else
               (foldr/a (f (first l) a) (rest l))])))
    (foldr/a i l0)))

この関数にアキュムレーターを装備させると、リストを走査する順序が逆転するので、最初のリストの反転は不要です。

課題1 foldlのシグネチャを思い出してください。

    ; [X Y] [X Y -> Y] Y [List-of X] -> Y

これはまた、f*ldlのシグネチャでもあります。fold/a のシグネチャとそのアキュムレーター不変量を定式化してください。ヒント l0とlの差は (list x1 x2 x3) であると仮定してください。そのとき a は何でしょうか？

また、なぜfold/aがこのように変わった順序で引数を消費するのか、つまり、最初にアキュムレーターでその次がリストなのか不思議に思うかもしれません。この順序の理由を理解するために、代わりにfold/aが最初の引数として f を消費することを想像してみてください。この時点で、fold/aがfoldlであることは明白になります。

; version 5
(define (f*ldl f i l)
  (cond
    [(empty? l) i]
    [else (f*ldl f (f (first l) i) (rest l))]))


課題2 アキュムレーター・スタイルのアプローチでbuild-l*stを設計しなさい。この関数は以下のテストを満足しなければならない：

    (check-expect (build-l*st n f) (build-list n f))

は、任意の自然数nと関数fに対して成り立つ。


=====

32.4 マウスを使ったグラフィカルなエディター

"5.10 グラフィカル・エディター" では、ワンラインエディターの概念を紹介し、グラフィカル・エディターを作成するためのいくつかの演習を紹介しています。グラフィカル・エディターとは、キーイベントを文字列の編集動作として解釈する対話型プログラムであることを思い出してください。具体的には、ユーザーが左または右矢印キーを押すと、カーソルは左または右に移動し、同様に、deleteキーを押すと、編集中のテキストから1Stringが削除されます。エディターのプログラムでは、2つの文字列を構造体で結合したデータ表現が用いられている。"10.4 グラフィカル・エディター 再訪"では、これらの演習を再開し、同じプログラムでも、2つの文字列を組み合わせた別のデータ構造を用いることで大きな効果が得られることを示しています。

どちらのセクションもナビゲーションのためのマウスアクションを扱っていませんが、最近のアプリケーションはすべてこの機能をサポートしています。マウスイベントの基本的な難しさは、カーソルを適切な場所に配置することです。このプログラムでは1行のテキストを扱うので、(x,y)でのマウスクリックは明らかに xの位置かその周辺で見える文字の間にカーソルを置くことを目的としています。このセクションでは、そのギャップを埋めます。

"10.4 グラフィカル・エディター 再訪"の関連する定義を思い出してください。

  (define FONT-SIZE 11)
  (define FONT-COLOR "black")

  ; [List-of 1String] -> Image
  ; 文字列をエディター用の画像としてレンダリングします。
  (define (editor-text s)
    (text (implode s) FONT-SIZE FONT-COLOR))

  (define-struct editor [pre post])
  ; editor は構造体である。
  ;  (make-editor [List-of 1String] [List-of 1String])
  ; 解釈: (make-editor p s) が対話型の editor の状態であれば
  ; (reverse p) はカーソルの左側のテキストに対応し、
  ; s はカーソルの右側のテキストに対応する。


練習問題508
構造設計のレシピを使って、関数 split-structural を設計しなさい。この関数は、1String のリスト ed と自然数 x を消費します。前者は editor 内の完全な文字列を表し、後者はマウスクリックのx座標を表す。この関数は

   (make-editor p s)

を作ります。この (make-editor p s) は、(1) p と s が ed を構成し、(2) x は p の画像より大きく、かつ、 (もしあれば) s 上の最初の 1String で拡張された p の画像より小さい、となるようなものです。（訳注：つまり以前作ったエディターで、マウスをクリックするときにマウスの位置に応じてカーソルを配置するための関数を作ります? ← もっとわかりやすく書きたい。）

ここでは、条件(1)をISL+式で表現しています:

  (string=? (string-append p s) ed)

条件(2)は

  (<= (image-width (editor-text p))
      x
      (image-width (editor-text (append p (first s)))))

です。ここで s は（cons? s）を想定しています。

ヒント (1) x 座標は左からの距離を表します。したがって、この関数は、ed のますます大きくなる prefix が与えられた幅に収まるかどうかをチェックしなければならなりません。最初にフィットしないものが希望する Editor の pre フィールドに対応し、ed の残りがpostフィールドに対応します。

(2) この機能を設計するためには、例とテストを徹底的に開発することが必要です。"4 区間、列挙、項目化" を参照してください。■


練習問題509
関数 split を設計してください。アキュムレーターの設計レシピを使用し、演習508の結果を改善してください。結局、関数が正しい分割点を発見するとき、リストの両方の部分が必要であり、一方の部分は再帰によって明らかに失われることがヒントですでに指摘されています。■


この演習を解いたら、A Graphical Editor, Revisitedの主な機能にマウスクリックの節を装備してください。マウスクリックによるカーソル移動を試してみると、splitのテストには合格していても、他のデバイスで使っているアプリケーションのような動作にはならないことに気づくでしょう。

エディターのようなグラフィカルなプログラムでは、最高の「ルック・アンド・フィール」体験を実現するために、さまざまな実験が必要です。この場合、エディターのカーソル配置が単純すぎるのです。コンピュータのアプリケーションは、分割点を決定した後、どの文字分割がX座標に近いかを判断し、そこにカーソルを配置します。


練習問題510
多くのオペレーティングシステムには、fmtプログラムが付属しています。このプログラムは、ファイル内の単語を並べ替えて、結果のファイル内のすべての行が最大幅になるようにすることができます。fmtは広く使われているプログラムであるため、さまざまな関連機能をサポートしています。この演習では、その中心的な機能に焦点を当てます。

(訳注: fmtコマンドは、文章を整形するためのコマンドです。横に長くなってしまった文章を一定の幅になるように結合や分割を行います。fmtコマンドは、デフォルトでは１行75文字以内になるように文章を折り返します)

プログラムfmtを設計してください。このプログラムは、2htdp/batch-io ティーチパックのread-fileと同じ意味で、 自然数w, 入力ファイル名 in-f, 出力ファイル名 out-f を消費します。その目的は、in-fからすべての単語を読み、これらの単語を与えられた順序で 最大幅 w の行に並べ、これらの行を out-f に書き込むことです。■


==========

33 アキュムレーターのその他の使用法

本章では、さらに3つのアキュムレーターの使用法を紹介します。最初のセクションは、ツリー構造処理の関数と組み合わせたアキュムレーターの使用に関するものです。ISL+のコンパイルを例にとって説明します。第2章では、なぜデータ表現の中にアキュムレーターが必要なのか、そしてどのようにアキュムレーターを配置すればよいのかを説明します。最後の節では、フラクタルの描画の議論を再開します。

=====

33.1 アキュムレーターとツリー

DrRacketにISL+のプログラムを実行させる場合、プログラムをあなたの特定のコンピュータ用のコマンドに変換します。このプロセスはコンパイルと呼ばれ、このタスクを実行するDrRacketの部分をコンパイラーと呼びます。コンパイラーはISL+プログラムを翻訳する前に、すべての変数がdefine, define-struct または lambdaによって宣言されているかどうかをチェックします。

ここで止まってください。 x, (lambda (y) x), (x 5)を完全なISL+プログラムとしてDrRacketに入力し、それぞれを実行するように指示します。何が見えるでしょうか？

この考えをサンプル問題で表現してみましょう。

    サンプル問題 あなたはISL+コンパイラーの一部を再作成するように依頼されました。具体的には、多くのプログラミング言語のマニュアルで使われている、いわゆる文法表記で指定された次のような言語断片を扱います (ここでは、この演習が単なるプログラミング言語ではなく、研究対象としてのISL+を扱うことを示すために、ラムダの代わりにギリシャ文字のλを使用することにします)。

    expression = variable
 	   	         | (λ (variable) expression)
 	 	           | (expression expression)


    インターメッツォ1で、文法を声に出して読むには、= を "の中の一つである" に、｜を "または" に置き換えればよいことを思い出してください。

    λ式は名前のない関数であることを思い出してください。これらはパラメーターを本体で束縛します。逆に、変数の出現は、パラメーターとして同じ名前を指定するλの周囲で宣言されます。"Intermezzo 3: Scope and Abstraction" では、プログラマーの視点から同じ問題を扱っているので、もう一度読んでみるとよいでしょう。"binding occurrence", "bound occurrence", "free." という用語を探してみてください。

    変数をシンボルで表現し、上記の言語断片のためのデータ表現を作成しなさい。そして、宣言されていない変数をすべて '*undeclared' に置き換える関数を設計しなさい。

この問題は、翻訳プロセスの多くのステップを代表するものであると同時に、アキュムレーター・スタイルの関数の素晴らしいケーススタディでもあります。

この問題に入る前に、ラムダについて知っていることを思い出しながら、このミニ言語の例を見てみよう。

    (λ (x) x)は与えられたものを何でも返す関数で、恒等関数とも呼ばれる。

    (λ (x) y) は y が宣言されていないことを除けば、引数が与えられると y を返す関数のように見えます。

    (λ (y) (λ (x) y)) は、ある値vが与えられたとき、常にvを返す関数を生成する関数である。

    ((λ (x) x) (λ (x) x)) は、自分自身に恒等関数を適用する。

    ((λ (x) (x x)) (λ (x) (x x))) は短い無限ループです。

    (((λ (y) (λ (x) y) (λ (z) z)) (λ (w) w)) は複雑な式なので、ISL+で実行して、それが終了するかどうかを調べるのが最も良い方法です。

実際、上記のISL+式をすべてDrRacketで実行すれば、書かれている内容を確認することができます。


練習問題511
上記の例におけるそれぞれの束縛の発生のスコープを説明しなさい。束縛から束縛発生への矢印を描いてください。← ??? ■


言語のデータ表現を開発することは容易です。というのはその記述には特に文法表記が用いられているためです。以下はあり得る例です：

; A Lam is one of:
; ? a Symbol
; ? (list 'λ (list Symbol) Lam)
; ? (list Lam Lam)

quote のため、このデータ表現により、ISL+のサブセットで式のためのデータ表現を簡単に作成することができます。

    (define ex1 '(λ (x) x))
    (define ex2 '(λ (x) y))
    (define ex3 '(λ (y) (λ (x) y))
    (define ex4 '((λ (x) (x x))) (λ (x) (x x)))

この4つのデータ例は、上記の表現の一部を表現したものです。ストップ!残りの例のデータ表現を作成してください。


練習問題512
is-var?、is-λ?、is-app?、すなわち、変数をλ式や関数適用(application)から区別する述語を定義してください。

また、以下を定義してください：

    λ式からパラメーターを抽出する λ-para

    λ式からボディを抽出する λ-body

    関数適用から関数を抽出する app-fun

    関数適用から引数を抽出する app-arg

これらの述語やセレクタを使えば、基本的には構造体指向のデータ表現を定義したかのように振る舞うことができます。

λ項においてλパラメーターとして使用されるすべてのシンボルのリストを生成する、declaredsを設計してください。重複するシンボルについては心配しないでください。■


練習問題513
リストの代わりに構造体を用いる、ISL+の上記と同じサブセットについて、データ表現を作成しなさい。また、データ定義に従ってex1、ex2、ex3のデータ表現も作成しなさい。■


構造設計のレシピに従うときの、ステップ2と3の成果物は以下のようになります：。

    ; Lam -> Lam
    ; パラメータが s のλ式のボディ内にそれらが存在しない場合、
    ; le におけるすべてのシンボル s を '*undeclared に置き換えます。

    (check-expect (undeclareds ex1) ex1)
    (check-expect (undeclareds ex2) '(λ (x) *undeclared))
    (check-expect (undeclareds ex3) ex3)
    (check-expect (undeclareds ex4) ex4)

    (define (undeclareds le0)
      le0)

ex4の表現を実行すると無限ループしますけれども、ex4 を処理するのにundeclareds をとなることを期待します；コンパイラはプログラムを実行するのではなく、それを読み込んで別のプログラムを作成するのです。

目的の声明をよく見ると、この関数にはアキュムレーターが必要であることが直接的にわかります。このことは、undeclareds に対するテンプレートを検査することで、さらに明確になります。

  (define (undeclareds le)
    (cond
      [(is-var? le) ...]
      [(is-λ? le) (... (undeclareds (λ-body le)) ...)]
      [(is-app? le)
       (... (undeclareds (app-fun le))
        ... (undeclareds (app-arg le)) ...)]))


undeclareds がλ式（の表現）のボディで再帰するとき、宣言された変数 (λ-para le) を忘れます。

そこで、letfsはアキュムレーター・スタイルのテンプレートから始めましょう:

  (define (undeclareds le0)
    (local
      (; Lam ??? -> Lam
       ; accumulator a represents ...
       (define (undeclareds/a le a)
         (cond
           [(is-var? le) ...]
           [(is-λ? le)
            (... (undeclareds/a (λ-body le)
                                ... a ...) ...)]
           [(is-app? le)
            (... (undeclareds/a (app-fun le)
                                ... a ...)
             ... (undeclareds/a (app-arg le)
                                ... a ...) ...)])))
      (undeclareds/a le0 ...)))

この文脈で、今度はアキュムレーターの不変量を定式化することができます:

    aは、le0の先頭からleの先頭までの経路で遭遇するλパラメーターのリストを表す。


例えば、le0が

    '(((λ (y) (λ (x) y)) (λ (z) z)) (λ (w) w))
              ---------

で、le がハイライトされた部分木である場合、a は y を含みます。図186の左側(のツリー)は、同じ例を図で表したものです。これは、Lam 式を上下逆さまの木として示しています（つまり、ルートが一番上にあります）。ノード @ は、2つの子孫を持つ適用を表します(他のノードは自明です)。このツリー図では、太字のパスは1つの変数宣言を通じて le0 から le へとつながります。

同様に、同じデータから別のサブツリーを選ぶと、

    '(((λ (y) (λ (x) y)) (λ (z) z)) (λ (w) w))
                     -

は、'y と 'x の両方を含むアキュムレーターを得ることができます。図186の右側(のツリー)は、この点を再び強調している。ここでは、太字のパスは2つの 'λ ノードを通って四角形で囲まれたサブツリーにつながり、アキュムレーターは太字のパスに沿って宣言された変数のリストである。


                イメージ画像

    図186:ツリーとしてのLam項


アキュムレーターのデータ表現とその不変量が決まったので、残りの設計上の問題を解決することができます:

  ・アキュムレーターの初期値として'()を選ぶ。

  ・a に (λ-para le) を追加するには、consを使います。

  ・undeclareds/a が変数を扱う節でアキュムレーターを利用します。具体的には、この関数は、変数が宣言のスコープ内にあるかどうかをチェックするためにアキュムレーターを使用します。



図 187 は、これらのアイデアを完全な関数定義に変換する方法を示しています。アキュムレーターの declareds という名前に注意してください。これは、アキュムレーターの不変性の背後にある重要なアイデアを伝え、プログラマが定義を理解するのに役立ちます。基本ケースでは、ISL+ のmember? を使って変数 le が declareds にあるかどうかを判断し、ない場合は'*undeclared に置き換えます。2番目のcond節は、拡張したアキュムレーター newd を導入するためにlocalを使用します。para は式の再構築にも使用されるため、それ自身のローカル定義をもちます。最後の節は、変数を宣言せず、直接使用もしない関数適用に関するものです。その結果、3つの節の中で最も単純なものとなっています。

 ; Lam -> Lam
 (define (undeclareds le0)
   (local (; Lam [List-of Symbol] -> Lam
           ; アキュムレーターの declareds は、le0 からle までのパス上にある
           ; すべての λ パラメーターのリストである。
           (define (undeclareds/a le declareds)
             (cond
               [(is-var? le)
                (if (member? le declareds) le '*undeclared)]
               [(is-λ? le)
                (local ((define para (λ-para le))
                        (define body (λ-body le))
                        (define newd (cons para declareds)))
                  (list 'λ (list para)
                    (undeclareds/a body newd)))]
               [(is-app? le)
                (local ((define fun (app-fun le))
                        (define arg (app-arg le)))
                (list (undeclareds/a fun declareds)
                      (undeclareds/a arg declareds)))])))
     (undeclareds/a le0 '())))

    図187: 未宣言の変数の検索


練習問題514
x が自由と束縛の両方に現れる ISL+ 式を作り上げよ。それをLamの要素として定式化しなさい。あなたの式で undeclareds は正しく機能しますか？■


練習問題515

次の式を考えよ。

    (λ (*undeclared) ((λ (x) (x *undeclared)) y))

はい、そうです。変数として *undeclared を使っているのです。これをLam式で表現して、undeclareds がその式に対し何を生成するか確認してください。

関数 undeclaredsが、引数として与えられたlam式における 'x の自由な出現を (list '*undeclared 'x) に置き換え、そして (同じく引数として与えられたlam式における) 'y の束縛された出現を (list '*declared 'y) に置き換えたものを出力するように、undeclareds を修正してください。

そうすることで、問題のある箇所を明確にすることができます。なぜなら、DrRacketのようなプログラム開発環境では、エラーを強調することができるので。

注 変数の出現を適用の表現に置き換えるというトリックは、厄介に感じられます。もしこれが好きでないなら、代わりに '*undeclared:x と 'declared:y というシンボルを合成することを検討してみてください。■


練習問題516
演習513の構造ベースのデータ表現に対応するように、undeclareds 関数を再設計しなさい。■


                イメージ画像

    図188:静的距離


練習問題517
関数 static-distance を設計してください。この関数は、変数のすべての出現箇所を、宣言しているλがどれだけ離れているかを表す自然数で置き換えます。図188は、

    '((λ (x) ((λ (y) (y x)) x)) (λ (z) z)))

という項に対する考え方を図示したものです。この図には、変数の出現箇所から対応する変数の宣言箇所までを指す、点線の矢印が描かれています。下の図は、(点線の)矢印はないが同じ形のツリーを示している。'λ ノードには名前がなく、変数の出現はどのλがその変数を宣言しているかを示す自然数に置き換えられています。各自然数 n は、束縛された出現が ― Lamツリーのルートに向かって ― nステップ上方にあることを意味します。値0 はルートに向かうパス上の最初の 'λ を示し、値1は2番目の 'λ を示し、そして(値3, 値4, ... は)以下同様となります。

ヒント undeclareds/a の undeclareds アキュムレーターは le から le0 へのパス上のすべてのパラメーターの逆順のリストで、最後に見られたものがリストの最初にあります。■


=====

33.2 アキュムレーターを用いたデータ表現

Intermezzo 5: The Cost of Computation の最後に、*SL はリストなどのコンテナのサイズをトラバースして測定すると説明しました。また、他のプログラミング言語では、別の方法でサイズを計算することをほのめかしていました。この節では、データ表現にアキュムレーターを追加して、このアイデアを実装する方法を示します。

このアイデアの初期の例として Finite State Machines を参照してください。

*SLによくあるリストについて考えてみましょう。すべてのリストは cons と '() から構成されます。例えば、quote や listといった操作は、単にこの二つの省略形です。「What Is '(), What Is cons」 が示すように、適切な構造型と関数定義を使って、BSLでリストを模倣することも可能です。

  (define-struct pair  [left right])
  ; ConsOrEmptyのいずれかである。
  ; - '()
  ; - (make-pair Any ConsOrEmpty)

  ; Any ConsOrEmpty -> ConsOrEmpty
  (define (our-cons a-value a-list)
    (cond
      [(empty? a-list) (make-pair a-value a-list)]
      [(pair? a-list)  (make-pair a-value a-list)]
      [else (error "our-cons: ...")]))

  ; ConsOrEmpty -> Any
  ; 与えられたペアの左部分を抽出する
  (define (our-first mimicked-list)
    (if (empty? mimicked-list)
        (error "our-first: ...")
        (pair-left mimicked-list)))

    図 189:BSLにおけるリストの実装

図189は、その基本的な考え方を私たちに想起させます。ここで止まってください! 関数our-rest をいま定義できますか？


重要な洞察は、pair の構造体型の定義に第3のフィールドを追加できることである。

    (define-struct cpair [count left right])
    ; [MyList X] は次のいずれかである。
    ; - '()
    ; - (make-cpair (tech "N") X [MyList X])
    ; countフィールドのアキュムレーターは cpair の個数

アキュムレーターのステートメントに書かれているように、追加のフィールドはリストを作成するために使用された cpair インスタンスの数を追跡するために使用されています。つまり、リストの構築に関する事実を記憶しているのです。この種の構造体フィールドをデータアキュムレーターと呼びます。

リストのメジャーなコンストラクターにーフィールドを追加するのは、タダではありません。そもそも、このコンストラクタのチェック済みバージョン、つまり実際にプログラムから利用できるバージョンに変更を加える必要があります。

    ; データ定義、コンストラクタ関数経由の
    (define (our-cons f r)
      (cond
        [(empty? r) (make-cpair 1 f r) ]である。
        [(cpair? r) (make-cpair (+ (cpair-count r) 1) f r)]
        [else (error "our-cons: ...")]))

拡張されたリストが '() の場合は、count に 1 が格納され、それ以外の場合は与えられた cpair から長さを計算します。

さて、our-lengthの関数定義は明らかです：

    ; Any -> N
    ; l はいくつの要素を含むか？
    (define (our-length l)
      (cond
        [(empty? l) 0]
        [(cpair? l) (cpair-count l)]
        [else (error "my-length: ...")]))

この関数は任意の種類の値を消費します。'() と cpair のインスタンスに対しては、自然数を生成します；それ以外の場合はエラーを通知します。

count フィールドを追加したことにより発生した2つ目の問題は、パフォーマンスに関するものです。実際、2つの懸念があります。一方では、リストを作成するたびに追加フィールドができるため、メモリ消費量が33%増加します。もう一方では、フィールドの追加により、our-cons がリストを構築する速度が低下します。拡張されたリストが '() か cpair のインスタンスであるかどうかのチェックに加えて、コンストラクタはリストのサイズを計算するようになりました。この計算には一定の時間がかかりますが、our-cons を使うたびに課されます。この本で何回、cons を使って、そして結果のリストの長さを計算しなかったか考えてみてください!


練習問題518
our-cons は入力の大きさに関係なく、その結果を計算するのに一定の時間がかかることを論ぜよ。■


練習問題519
長さを定時間関数にするために、すべてのプログラムのconsに余分なコストを課すことは許容されるか？■


リストに count フィールドを追加するのは疑問の余地がありますが、データアキュムレーターが解決策を見つけるために重要な役割を果たすことがあります。次の例は、ボードゲームをプレイするプログラムにいわゆる人工知能を追加するもので、そのデータアキュムレーターは絶対必要なものです。

ボードゲームを遊んだりパズルを解いていると、どの段階でも自分の可能な手を考えることが多いものです。上達すると、最初のステップの後の可能な手まで想像するようになるかもしれません。その結果、ゲームツリーと呼ばれる、ルールで許されるすべての可能な手の（一部の）ツリーが出来上がります。まず、ある問題から始めてみましょう。

    サンプル問題 あなたの上司は次のような話をします。

    「昔々、あるジャングルで3人の人食い人種が3人の宣教師を案内していました。彼らは一番近い伝道所に行く途中でした。しばらくして、彼らは、危険なヘビと魚でいっぱいの広い川に到着しました。ボートがなければ川を渡ることはできません。幸い、少し探しただけで2本のオールのついた手漕ぎボートが見つけました。しかし、その船は小さすぎて、全員を乗せることはできません。一度に二人乗れるかどうかです。しかも、川幅が広いので、誰かが舟を漕いで帰らなければならない。

    「宣教師たちは人食い人種を信用できなかったので、6人全員を安全に川を渡らせる計画を考えなければなりませんでした。問題は、この人食い人種は、一地点で人食い人種が宣教師より多くなると、すぐに宣教師を殺して食べてしまうということでした。宣教師は、川の両側で宣教師が少数派に決してならないことを保証する計画を考案しなければならなかった。しかし、人食い人種は、そうでなければ協力してくれると信じていた。具体的には、宣教師が改宗者の候補を見捨てないように、彼らは食料になりそうなものを見捨てないということです。

    上司は、具体的な設計課題は出さないが、このようなパズルを解くプログラムを設計する（そして販売する）ことができないかと考えている。

パズルはボードゲームではありませんが、このプログラムではゲームツリーの考え方を最もわかりやすく説明しています。

原理的には、このようなパズルを手作業で解くことは非常に簡単である。以下はその大まかなアイデアである。問題の状態を図式化したものを選びます。図式は3つの部分からなる箱で、左は宣教師と人食い人種、真ん中は川とボートを組み合わせたもの、(右の)3番目は川の右岸を表しています。次の初期状態の表現を見てみよう。

    イメージ

黒丸は宣教師、白丸は食人族を示します。いずれも左側の川岸にいて、ボートも左側にあります。右側には誰もいません。以下にさらに2つの状態があります。

    イメージ1   イメージ2

1枚目は最終的な状態で、すべての人とボートが川の右岸にいる状態です。2枚目は左岸に2人とボート、右岸に4人の人がいる中間状態を示します。

                イメージ

    図 190:


パズルの状態を書き出す方法を得たので、各段階での可能な状態を考えることができます。そうすると、可能な手のツリーができます。図190は、そのような木の最初の2.5層をスケッチしたものです。一番左の状態が初期状態です。ボートは最大でも2人を運ぶことができ、少なくとも1人が漕がなければならないので、5つの可能な状態があります：1人の人食い人種がボートをこいで川を横切る、2人の人食い人種が横切る、1人の宣教師と1人の人食い人種が右岸に行く、1人の宣教師が横切る、2人の宣教師が右岸に行く、です。これらの可能性は、初期状態から5つの中間状態へ向かう5本の矢印で表現されます。

この5つの中間状態のそれぞれについて、もう一度同じゲームをすることができます。図190では、新しい状態のうち真ん中(上から3番目)の状態について、ゲームがどのように継続されるかを見ます。右の川岸には2人しかいないので、3つの可能性があります。人食い人種が戻るか、宣教師が戻るか、あるいは両方が戻るかです。したがって、3本の矢印が(訳注 2列目の)真ん中の状態と右側の3つの状態をつないでいます。この可能な状態の木をシステミックな方法で描き続けると、やがて最終的な状態を発見することができます。

図190をもう一度見てみると、この単純な方法で「可能な状態の木」を生成することには2つの問題があることがわかります。一つ目は、右(3列目)の真ん中の状態と初期状態を結ぶ破線の矢印です。これは、右(の真ん中の状態)から左(の状態)に二人を戻すと、パズルが初期状態に戻ってしまうことを示しています。つまり、最初からやり直すことになり、明らかに望ましくありません。もうひとつは、右上に星印がある状態です。どちらの場合も、左の川岸には白丸で表される人食い人種が黒丸で表される宣教師より多いので、人食い人種が宣教師を食べてしまうことになります。この場合も、目標はそのような状態を避けることですので、これらの動きは望ましくありません。

このパズルをプログラムにする一つの方法は、ある最終状態 ―ここでは(全員が無事に右岸に渡れている)という最終状態― が、ある与えられた状態から到達可能かどうかを判断する関数を設計することです。以下は適切な関数の定義です。

    ; PuzzleState -> PuzzleState
    ; state0 から正しい最終状態に到達可能か？
    ; Generative は正しい終結状態を含むツリーを作成するか？

    (check-expect (solve initial-puzzle) final-puzzle)

    (define (solve state0)
      (local (; [List-of PuzzleState] -> PuzzleState)
              ; generative (生成)は los の後継の状態 (successors) を生成する
              (define (solve* los)
                (cond
                  [(ormap final? los)
                  (first (filter final? los))]
                [else
                 (solve* (create-next-states los))])))
        (solve* (list state0))))

補助関数は生成再帰を使い、可能な状態のリストが与えられたら、すべての新しい可能な状態を生成します。与えられた可能性のうちの1つが最終状態である場合、この関数はそれを返します。

solve 関数は生成的であることは明らかです。PuzzleStates のコレクション、最終状態を認識する関数、そしてすべての「後継(状態)」を生成する関数さえ定義すれば、solve はあなたのパズルで動作することができます。


練習問題520
solve* 関数は、n + 1回の船旅を必要とする状態を見る前に、船旅の一部が以前に遭遇した状態に戻るとしても、n回の船旅で到達可能なすべての状態を生成する。このように木をシステミックに走査するため、solve* は無限ループに入ることができません。それはなぜでしょうか？ (用語解説 このような木やグラフの探索方法は、幅優先探索と呼ばれています)■


練習問題521
宣教師と人食い人種のパズルの状態についての表現を開発しなさい。グラフ表現と同様に、データ表現も川の両岸にいる宣教師と人食い人種の数と、船の位置を記録しなければならない。

PuzzleStateの記述では、新しい構造体型が求められています。上記の初期状態、中間状態、最終状態を表現してください。

与えられた状態において、すべての人が右の川岸にいるかどうかを検出する関数final?を設計しなさい。

宣教師と人食い人種のパズルの状態を画像にマッピングする関数render-mcを設計してください。■


問題は、最終的な状態を返すことで、プレイヤーが初期状態から最終的な状態に至る方法について何も語っていないことです。言い換えれば、関数 create-next-states は与えられた状態から返された状態への行き方を忘れてしまうのです。この状況は明らかにアキュムレーターを必要としますが、同時に、蓄積された知識は solve* や他の関数ではなく、個々の PuzzleState に最もよく関連付けられます。


練習問題522
演習521の表現を修正して、ある状態がそこに到達するまでにたどった一連の状態を記録するようにしなさい。状態のリストを使用してください。

追加のフィールドを説明するデータ定義でアキュムレーターの声明を明確化し、書き下してください。

必要に応じて、この表現のために final? または render-mc を修正してください。■


練習問題523
create-next-states 関数を設計してください。この関数は、宣教師と人食い人種の状態のリストを消費し、1回のボートの移動で到達できるすべての状態のリストを生成します。

create-next-statesの最初のドラフトではアキュムレーターを無視してください。しかしながら、この関数が人食い人種が宣教師を食べることができる状態を生成しないようにしてください。

2番目のデザインでは、パズル状態の構造体のアキュムレーターフィールドを更新し、それを使って現在のステートに至るまでに遭遇した状態を除外します。


練習問題524
アキュムレーター指向のデータ表現を利用して、solve を修正してください。修正された関数は、最初の PuzzleState から最終的な PuzzleState に至る状態のリストを生成します。

また、render-mc を使って画像を生成し、このリストからムービーを作成することも検討してください。ムービーを表示するには run-movie を使ってください。■


=====

33.3 結果としてのアキュムレーター

図156をもう一度見てください。シェルピンスキーの三角形とその作り方の暗示が表示されています。具体的には、右の画像で、その背後にある生成的なアイデアの1つのバージョンを説明しています。

    与えられた問題は三角形である。三角形が小さすぎてこれ以上細分化できない場合、アルゴリズムは何もしない。そうでない場合は、その3つの辺の中点を見つけ、外側の3つの三角形を再帰的に処理する。

一方、"27.1 Fractals, a First Taste" では、シェルピンスキーの三角形を代数的に合成する方法を示しているが、この記述には対応しない作業である。

ほとんどのプログラマは、"draw" はあるキャンバスに三角形を追加する動作を意味すると思っています。2htdp/imageライブラリのscene+line関数は、この考えを具体化したものです。この関数は画像 s と 2 点の座標を引数として受け取り、その 2 点を通る直線を s に追加します。

    サンプル問題 add-sierpinski関数を設計してください。この関数は、画像と、三角形を記述する3つの posn を引数として受け取ります。そして、後者を用いてシェルピンスキーの三角形を画像に追加します。

この問題が、上記のシェルピンスキーの三角形の描き方に関するプロセスの記述を暗黙のうちに参照していることに注意してください。言い換えれば、我々は古典的な生成再帰的問題に直面していて、生成再帰の古典的なテンプレートと、次の4つの中心的な設計上の質問から始めることができます。

  ・三角形が小さすぎて細分化できない場合、この問題は自明(trivial)です。

  ・自明なケースではこの関数は与えられた画像を返します。

  ・そうでない場合は、与えられた三角形の辺の中点を計算し、別の三角形を追加する。その後、それぞれの「外の」三角形が再帰的に処理されます。

  ・このような再帰的なステップを経て、画像が生成されます。残りの質問はこれらの画像をどのように合成するかということです。

  ; Image Posn Posn Posn -> Image
  ; 生成的に三角形(a, b, c)をscene0に追加する。
  ; その3辺の中点を取って、3つの三角形に分割する。
  ;(a, b, c)が小さすぎる場合は停止する。
  (define (add-sierpinski scene0 a b c)
    (cond
      [(too-small? a b c) scene0]
      [else
       (local
         ((define scene1 (add-triangle scene0 a b c))
          (define mid-a-b (mid-point a b))
          (define mid-b-c (mid-point b c))
          (define mid-c-a (mid-point c a))
          (define scene2
            (add-sierpinski scene0 a mid-a-b mid-c-a))
          (define scene3
            (add-sierpinski scene0 b mid-b-c mid-a-b))
          (define scene4
            (add-sierpinski scene0 c mid-c-a mid-b-c)))
         ; ?IN?
         (... scene1 ... scene2 ... scene3 ... scene4 ...))]))

    図191:生成的再帰の結果としてのアキュムレーター、スケルトン

図191は、これらの答えをスケルトン的な定義に変換した結果です。各中点は2回使用されるので、スケルトンはISL+の生成ステップを定式化するためにlocalを使用します。local式は、3つの新しい中点に加え、add-sierpinskiの3つの再帰的な適用を導入しています。(上記の関数の)本体のドットは、scene の組み合わせを示唆しています。


練習問題525
スケルトンが示唆するウィッシュリストに取り組みましょう：

    ; Image Posn Posn Posn -> Image
    ; 黒い三角形 a, b, c をシーンに追加する。
    (define (add-triangle scene a b c) scene)

    ; Posn Posn Posn -> Boolean
    ; 三角形a, b, cは小さすぎて分割できないか？
    (define (too-small? a b c)
      #false)

    ; Posn Posn -> Posn
    ; a と b の中点を決定する。
    (define (mid-point a b)
      a)

3つの機能を設計します。

領域知識 (1) too-small? 関数に関しては2点間の距離を測定し、それがある選ばれた閾値、例えば10以下かどうかをチェックすれば十分である。(x0,y0)と(x1,y1)の間の距離は次のようになります。

      ((x0 - x1)^2 + (y0 - y1)^2)^(1/2)

つまり、(x0 - x1,y0 - y1) の原点までの距離です。

点(x0,y0)と点(x1,y1)の中点は、それぞれのx座標とy座標の中点を座標とします。

      ((1/2)・(x0 + x1), (1/2)・(y0 + y1))
■

さて、すべての補助関数が揃ったので、再帰的な呼び出しによって作成された3つの画像を結合する問題に戻る時が来ました。1つの明白な推測は、overlayまたはunderlay関数を使うことですが、DrRacketのインタラクション領域での評価は、関数がその下の三角形を隠してしまうことを示しています。

具体的には、3つの再帰的な呼び出しによって、以下のような空のシーンが生成され、適切な場所に1つの三角形が付け加えられると想像してください。

    > シーン1

    イメージ

    > シーン2

    イメージ

    > シーン3

    イメージ

組み合わせはこの図のようになるはずです。

    イメージ

しかし、これらの形状をオーバーレイやアンダーレイで組み合わせても、この望む形状は得られません。

    > (overlay scene1 scene2 scene3)

    イメージ

    > (underlay scene1 scene2 scene3)

    イメージ

実際、ISL+の画像ライブラリは、これらのシーンを適切に合成する機能をサポートしていません。

これらの相互作用についてもう一度考えてみましょう。scene1 が与えられたシーンに上の三角形を追加した結果で、scene2 が左下に三角形を追加した結果だとすると、おそらく2回目の再帰呼び出しは最初の呼び出しの結果に三角形を追加するということになるはずです。そうすると、次のようになります：

    イメージ

そして、このシーンを3回目の再帰呼び出しに渡すと、思い通りのものが出来上がります。

    イメージ

---
; Image Posn Posn Posn -> Image
; 生成的に三角形(a, b, c)をscene0に追加する。
; 三角形の各辺の中点を取って、3つの三角形に分割する。
; 三角形 (a, b, c) が小さすぎるときには停止する。
; アキュームレーター: 関数はscene0の三角形をアキュームレートする。
(define (add-sierpinski scene0 a b c)
  (cond
    [(too-small? a b c) scene0]
    [else
     (local
       ((define scene1 (add-triangle scene0 a b c))
        (define mid-a-b (mid-point a b))
        (define mid-b-c (mid-point b c))
        (define mid-c-a (mid-point c a))
        (define scene2
          (add-sierpinski scene1 a mid-a-b mid-c-a))
        (define scene3
          (add-sierpinski scene2 b mid-b-c mid-a-b)))
       ; ?IN?
       (add-sierpinski scene3 c mid-c-a mid-b-c))]))

    図192：生成再帰の結果としてのアキュムレーター、関数
---


図192は、この洞察に基づく再定式化です。3つのハイライトは、重要な設計思想をピンポイントで示しています。いずれも三角形が十分に大きく、与えられたシーンに追加される場合に関するものです。三角形の辺が細分割されると、最初の外側の三角形は、与えられた三角形を追加した結果であるscene1を使って再帰的に処理されます。同様に、この最初の再帰処理の結果であるscene2は、2番目の三角形を処理する2回目の再帰処理に使用されます。最後に、scene3が3回目の再帰呼び出しに流れ込みます。つまり、アキュムレーターが引数であり、知識を集める道具であると同時に、その関数の結果であるということが新規性のある点です。

add-sierpinskiを探求するには、正三角形と十分に大きな境界を残す画像から始めるのが最もよいでしょう。以下はこの2つの条件を満たす定義です。

    (define MT (empty-scene 400 400))
    (define A (make-posn 200 50))
    (define B (make-posn 27 350))
    (define C (make-posn 373 350))

    (add-sierpinski MT A B C)

このコードの断片がどのようなシェルピンスキー・フラクタルを作るか調べてみてください。練習問題525の定義を使って、最初のものよりも疎なシェルピンスキーの三角形、また、密なシェルピンスキーの三角形を作る実験をしてみてください。

練習問題526
等辺のシェルピンスキー三角形の端点を計算するには、円を描き、その円上に120度離れた3点、例えば、120度、240度、360度を選んでください。

circle-pt関数を設計してください(訳注: 引数には、120度であれば 120/360 というように有理数を使用します)。

    (define CENTER (make-posn 200 200))
    (define RADIUS 200) ; 半径をピクセル単位で指定します。

    ; Number -> Posn
    ; 中心がCENTERで、半径がRADIUSの円の円周上の点で、
    ; 角度がfactor 度の点を計算する。

    ; 例
    ; 120/360, 240/360, 360/360が与えられたとき
    ; 目的の点のx,y座標は何でしょうか。

    (define (circle-pt factor)
      (make-posn 0 0))

領域知識 この設計問題では、数学の知識が必要とされます。この問題の一つの見方として、複素数の極座標での表現から Posn での表現への変換があります。ISL+のmake-polar, real-part, imag-partを読んでみてください。もう一つの方法は、三角法、(DrRacketの) sin と cos を使って座標を決定することです。この方法を選択する場合、これらの三角関数は、サインとコサインを度数ではなくラジアン単位で計算することを思い出してください。また、画面上の位置は上方向ではなく、下方向に伸びていくことも覚えておいてください。■


練習問題527

次の2つの画像を見てください。

    イメージ画像1  イメージ画像2

図156がシェルピンスキーの三角形の描き方を示すのと同じように、これらはフラクタル・サバンナツリーを生成する方法を示しています。左の画像はフラクタル・サバンナツリーがどのようなものかを示しています。右は生成的構築のステップを説明するものです。

関数add-savannahを設計してください。この関数は、画像と4つの数を引数とします: (4つの数というのは、) (1) 線の基点の x 座標、(2) 線の基点の y 座標、(3) 線の長さ、(4) 線の角度 です。それらは与えられた画像にフラクタルなサバンナツリーを追加します。

線が短すぎない限り、この関数は指定された線を画像に追加します。そして、その線を3つのセグメントに分割します。そして、その中間の2点を2本の線の新たな始点として再帰的に使用します。2 本の線の長さと角度は、互いに独立に、一定の方法で変化します。定数を使ってこれらの変化を定義し、自分のツリーを十分に気に入るまで調整してみてください。

ヒント 左の枝をそれぞれ3分の1以上短くし、0.15度以上左に回転させて実験してください。右の枝は、それぞれ20%以上短くし、反対方向に0.2度回転させます。■


練習問題528
グラフィックス・プログラマーはしばしば、2つの点を滑らかな曲線で結ぶ必要があります。ここで、「滑らか」というのはある遠近法(perspective)に近いです。ここに二つのスケッチがあります。

    イメージ画像    イメージ画像

左は点Aと点Cを結ぶ滑らかな曲線、右は遠近点Bと観察者の角度を供給します。

このような曲線の描き方のひとつは、ベジェによるものである。これは生成的再帰の代表例であり、以下のシーケンスでそのアルゴリズムの背後にある「エウレカ！」(訳注: ギリシャ語に由来する感嘆詞で、何かを発見・発明したことを喜ぶときに使われる言葉)を説明します。

    イメージ画像    イメージ画像    イメージ画像

左の画像を考えてみてください。この図から、与えられた3つの点が三角形を構成し、AからCへの接続がアルゴリズムの焦点であることがわかります。目標は、AからCへの線をBに向かって引き、滑らかな曲線にすることである。

では、真ん中の画像をご覧ください。生成ステップの本質的な考え方が説明されています。このアルゴリズムでは、2本の観察線A-BとB-C上の中点と、それらの中点A-B-Cが決定されます。

最後に、一番右の図は、これらの3つの新しい点が、2つの異なる再帰的呼び出しを生成する様子を示しています：1つは左の新しい三角形を処理し、もう1つは右の三角形を処理します。より正確には、A-B と B-C が新しい観察点となり、A から A-B-C への線と C から A-B-C への線が、2 つの再帰的呼び出しの焦点となります。

三角形が十分に小さい場合、自明に解決可能なケースがあります。このアルゴリズムは三角形を描くだけで、それが与えられた画像上の点として現れる。このアルゴリズムを実装する際には、曲線が滑らかに見えるように「十分に小さい」という概念を使って実験する必要があります。■


=====
34 まとめ

この最後のパートは、データ構造のトラバーサル中に知識を収集するメカニズムであるアキュムレーターを使用した設計についてです。アキュムレーターを追加することで、性能上の欠陥を修正し、終了の問題をなくすことができます。このパートから得られるものは、2つ半の設計上の教訓です。

    最初のステップは、アキュムレーターを導入する必要性を認識することである。探索は、ある部分から次の部分へ移るときに、引数の断片を生成します。もし、そのような知識が関数fsの設計を単純化できることを発見したら、アキュムレーターを導入することを検討してください。最初のステップは、アキュムレーター・テンプレートに切り替えることです。

    重要なステップは、アキュムレーターステートメントを作成することである。後者はアキュムレーターがどのような知識をどのようなデータとして収集するかを表現する必要があります。ほとんどの場合、アキュムレーター文は元の引数と現在の引数との差を記述します。

    第3のステップは、マイナーなものでありますが、アキュムレーター文から （a）アキュムレーターの初期値は何か、（b）トラバーサルステップ中にそれをどう維持するか、（c）その知識をどう利用するかを推論することです。

知識を蓄積するという考え方はどこにでもあり、様々な形で登場します。ISL+のようないわゆる関数型言語では広く使われています。一方、命令型言語のプログラマがアキュムレーターに出会うのは、値を返せない原始的なループ構文の代入文が主です。このような命令型アキュムレーターのプログラム設計は、ここでのアキュムレーター関数の設計と同じように進められますが、その詳細は体系的なプログラム設計に関するこの最初の本の範囲外です。

