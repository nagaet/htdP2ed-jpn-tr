How to Design Programs, Second Edition.
Matthias Felleisen, Robert Bruce Findler, Matthew Flatt, Shriram Krishnamurthi 著.

---

V Generative Recursion

    25 非標準の再帰性

      25.1 構造を持たない再帰性

      25.2 構造を無視した再帰性

    26 アルゴリズムの設計

      26.1 デザインレシピの適応

      26.2 解除

      26.3 構造的再帰性と生成的再帰性

      26.4 選択肢の作成

    27 テーマによるバリエーション

      27.1 フラクタル、ファーストテイスト

      27.2 バイナリサーチ

      27.3 構文解析の一端を垣間見る

    28の数学的な例

      28.1 Newtonfs法

      28.2 数値積分

      28.3 プロジェクトガウス消去

    29 バックトラックを行うアルゴリズム

      29.1 グラフのトラバース

      29.2 プロジェクトバックトラック

    30 まとめ




最初の4つの部分の設計レシピに従うと、ドメイン知識をコードに変えるか、データ定義の構造を利用してコードを整理します。いくつかの関数は単にそのような関数を構成します。後者の関数は、通常、引数を直接の構造要素に分解し、それらの要素を処理します。この直前の構成要素の1つが入力と同じクラスのデータである場合、その関数は構造的に再帰的です。構造的に設計された関数が世の中のコードの大部分を占めていますが、構造的な設計アプローチでは解決できない問題もあります。

このような複雑な問題を解決するために、プログラマは構造的再帰より厳密により強力な再帰の形式である生成的再帰を用います。生成的再帰の研究は数学と同じくらい古くからあり、しばしばアルゴリズムの研究と呼ばれる。アルゴリズムの入力は問題を表す。アルゴリズムは問題をいくつかの問題の集合に並べ替え、それらを解き、それらの解を組み合わせて一つの全体的な解にする傾向がある。新しく生成された問題のいくつかは、与えられた問題と同じ種類の問題であることが多く、その場合、アルゴリズムを再利用して問題を解くことができる。このような場合、アルゴリズムは再帰的であるが、その再帰は入力データの即時的な部分ではなく、新しく生成されたデータを使用する。

生成的再帰の説明から、生成的再帰関数の設計は構造的な再帰関数の設計よりもアドホックな活動であることが分かります。それでも、一般的な設計レシピの多くの要素はアルゴリズムの設計にも適用され、このパートでは設計レシピがどのように、そしてどの程度役立つかを説明する。アルゴリズム設計の鍵は「生成」のステップにあり、これはしばしば問題を分割することを意味する。そして、問題を分割する新しい方法を見つけ出すには、洞察力が必要である。例えば、文字列の分割に関する常識的な知識を少し必要とするだけかもしれません。また、数字に関する深い数学的定理に依存する場合もある。実際には、プログラマーは簡単なアルゴリズムは自分で設計し、複雑なアルゴリズムは専門家に依頼する。いずれの場合も、プログラマーはアルゴリズムの基礎となる考え方を徹底的に理解し、コードを書き上げ、そのプログラムが将来の読者とコミュニケーションできるようにしなければなりません。この考えを理解する最良の方法は、様々な例を研究し、実世界に現れるかもしれない生成的な再帰の種類に対する感覚を養うことである。


------------------------------------------------------

25 非標準的な再帰

この時点で、あなたは構造的再帰を採用した数多くの関数を設計しています。関数を設計するとき、その主要な入力のデータ定義を見る必要があることはご存じでしょう。この入力が自己参照型のデータ定義で記述されている場合、基本的にデータ定義が自分自身を参照する関数ができあがります。

この章では、再帰を異なる方法で使用した2つのサンプルプログラムを紹介する。これらは、明白なアイデアから洗練された洞察に至るまで、ある種の「エウレカ」を必要とする問題を例証するものである。



=====
25.1 構造を持たない再帰

あなたがDrRacketチームに参加したと想像してください。チームはプログラマー間のコラボレーションをサポートするための共有サービスに取り組んでいます。具体的には、DrRacketの次のリビジョンでは、ISLプログラマがDrRacketの定義領域の内容を複数のコンピュータで共有することができるようにする予定です。あるプログラマーがバッファを修正するたびに、修正されたDrRacketは、共有セッションに参加しているDrRacketのインスタンスに定義領域の内容をブロードキャストします。

    サンプル問題 あなたの課題は、定義領域の内容をブロードキャスト用に準備する関数 bundle を設計することです。DrRacketはコンテンツを1Stringsのリストとして渡します。この関数のタスクは、個々の文字列をバンドルし、与えられた長さの文字列のリスト ― チャンクと呼ばれる― を生成することです。この文字列の長さはチャンクサイズと呼ばれます。

ご覧のように、問題は基本的にシグネチャーを綴ったものであり、問題固有のデータ定義は必要ありません。

    ; [List-of 1String] N -> [List-of String]
    ; sのチャンクを長さnの文字列に束ねる。
    (define (bundle s n)
      '())

目的の声明は、問題の声明から文の断片(fragment)を再構成し、ダミー関数のヘッダーのパラメータを使用する。

第3ステップでは、関数の例を要求します。ここでは、1Stringsのリストを示します:

    (list "a" "b" "c" "d" "e" "f" "g" "h")

このリストをペアで束ねるようにbundleに指示すると、つまりnが2だとすると、以下のリストが期待される結果となる。

    (list "ab" "cd" "ef" "gh")

ここで、nが3であれば、文字が余ります。問題文には、どの文字が余るかは書かれていないので、少なくとも2つの有効なシナリオが考えられる。

    ・関数は、(list "abc" "def" "g") を生成する．つまり、最後の文字を余った文字と見なす。

    ・あるいは、先頭の文字を勝手に文字列に詰め込む、(list "a" "bcd" "efg")を生成する。

ストップ！ 少なくとも1つの他の選択肢を考えてください。

簡単にするために、最初の選択肢を望ましい結果として選び、それに対応するテストを書きます。

    (check-expect (bundle (explode "abcdefg") 3)
                  (list "abc" "def" "g"))

explode を使っていることに注意してください。（この関数によって）テストが読みやすくなります。

また、例題やテストでは、データ定義の境界で何が起こるかを記述しなければなりません。この文脈では、境界とは明らかに、与えられたチャンクサイズに対して短すぎるリストが関数 bundleに与えられたことを意味します。

    (check-expect (bundle '("a" "b") 3) (list "ab"))

また、bundleに'()が与えられたときに何が起こるかを考えなければならないことも意味しています。簡単のために、望ましい結果として '() を選びます。

    (check-expect (bundle '() 3) '())

自然な代替案として、'("") を求めるのも一つの手です。他にもみつけられますか？

---
  ; Nはcompound、sはatomicとみなす
  ; (二つのリストを同時に処理する: ケース1)
  (define (bundle s n)
    (cond
       [(zero? n) (...)]
       [else (... s ... n ... (bundle s (sub1 n)))]))
             
  ; [List-of 1String] as compound, n atomic
  ; (二つのリストを同時に処理する: ケース 1)
  (define (bundle s n)
    (cond
      [(empty? s) (...)]
      [else (... s ... n ... (bundle (rest s) n))]))
             
  ; [List-of 1String]とNは同等の条件上にある。
  ; (二つのリストを同時に処理する: ケース2)
  (define (bundle s n)
    (cond
      [(and (empty? s) (zero? n)) (...)]
      [else (... s ... n ... (bundle (rest s) (sub1 n)))]))
             
  ;すべての可能性を検討する
  ; (二つのリストを同時に処理する: ケース3)
  (define (bundle s n)
    (cond
      [(and (empty? s) (zero? n)) (...)]
      [(and (cons? s) (zero? n)) (...)]
      [(and (empty? s) (positive? n)) (...)]
      [else (... (bundle s (sub1 n)) ...
             ... (bundle (rest s) n) ...)]))

    図146：文字列をチャンクに分割するための無駄なテンプレート
---

テンプレートのステップでは、構造的なアプローチではうまくいかないことが明らかになります。図146は4つの可能なテンプレートを示している。bundleへの引数は両方とも複雑なので、最初の2つは引数のうちの1つをアトミックとみなしています。関数は各引数を分解しなければならないので、明らかにそうなることはできません。3番目のテンプレートは2つの引数がロックステップ（完全な同一歩調）で処理されるという仮定に基づいており、bundleが明らかに一定の間隔でチャンクサイズを元の値にリセットしなければならないことを除けば、それに近いものです。最後のテンプレートでは、2つの引数は独立して処理され、各ステージで4つの可能性があることを意味します。この最後の設計では、リストと数える数を一緒に処理しなければならないため、引数を切り離し過ぎています。要するに、構造テンプレートはこの設計問題には役に立たないように見えることを認めざるを得ません。

---
  ; [List-of 1String] N -> [List-of String]
  ; sのチャンクを長さnの文字列に束ねる。
  ; n個のアイテムを一度に取ってドロップするアイデア
  (define (bundle s n)
    (cond
      [(empty? s) '()]
      [else
       (cons (implode (take s n)) (bundle (drop s n) n))]))
             
  ; [List-of X] N -> [List-of X]
  ; 可能であれば lから最初のn個の項目あるいはすべてを保持する。
  (define (take l n)
    (cond
      [(zero? n) '()]
      [(empty? l) '()]
      [else (cons (first l) (take (rest l) (sub1 n)))]))
             
  ; [List-of X] N -> [List-of X]
  ; 可能であればlから最初のn個の項目もしくはすべてを削除する
  (define (drop l n)
    (cond
      [(zero? n) l]
      [(empty? l) l]
      [else (drop (rest l) (sub1 n))]))

    図147：生成的再帰
---

図147はbundleの完全な定義を示しています。この定義では、演習395で要求されたdropとtakeの関数を使用しています。これらの関数は標準ライブラリでも利用可能です。drop はリストの先頭から最大 n 個の項目を削除し、take はその個数までの項目を返します。これらの関数を使って、bundleを定義するのは非常に簡単である。

   1. 与えられたリストが'()であれば、結果は決められたとおりの'()になります。

   2. そうでなければ、bundle は take を使って s から最初の n 個の 1String を取り出し、それらをimplodeでプレーン(plain)の String にします。

   3. dropでn個分リストを短くします。そのリストに対して再帰します。

   4. 最後に、cons は 2. の文字列と 3. の文字列のリストを結合し、完全なリストの結果を作成します。

項目3は、bundleと最初の4つのパートにある(図146の)すべての関数との重要な違いを強調しています。List-of cons の定義では、リストに項目を追加して別のリストを作るので、最初の4つのパートのすべての関数は、空でないリストを分解するためにfirstとrestを使っています。これに対して、bundleはdropを使います。dropは1つだけではなくn個の項目を一度に削除します。

bundleの定義は変わっていますが、基本的な考え方は直感的で、これまで見てきた関数とあまり変わりません。実際、チャンクサイズnが1であれば、bundleは構造的に再帰的な定義に特化します。また、dropは任意に並べ替えられたバージョンではなく、与えられたリストの必要な部分を生成することが保証されています。そして、このアイデアこそが、次の節で紹介するものです。


練習問題421
(bundle '("a" "b" "c") 0) はbundle関数の正しい使い方でしょうか？それは何を生成しますか？なぜですか？■


練習問題422
関数 list->chunks を定義せよ．この関数は任意のデータからなるリストlと自然数nを消費し、その結果はサイズnのリストチャンクのリストである。各チャンクはlにおける要素の部分列を表す。

list->chunksを使用して、関数合成によるbundleを定義してください。■


練習問題423
partition を定義せよ。この関数は文字列 s と自然数 n を消費し、サイズ n の文字列の塊のリストを生成する。

空でない文字列sと正の自然数nの場合、

       (equal? (partition s n) (bundle (explode s) n))

は#trueとなる。しかし、この等式をpartitionの定義として使用しないでください。代わりにsubstringを使用してください。

ヒント 空の文字列に対する自然な結果をパーティションに生成させる。n が 0 の場合については、演習 421 を参照のこと。

注 パーティション機能は、bundleよりも協調的なDrRacket環境が必要とするものに幾分近いです。■


=====

25.2 構造を無視した再帰処理

11章の"Design by Composition"のsort>関数は、数値のリストを受け取り、それを何らかの順序（通常は昇順または降順）に並べ替えるものであることを思い出してください。この関数は、最初の数字を、ソートされた残りのリストの適切な位置に挿入することで処理を進めます。言い換えれば、これは構造的に再帰的な関数であり、自然な再帰の結果を再処理するものである。

Hoareのクイックソート・アルゴリズムは、リストのソートを根本的に異なる方法で行い、生成的再帰性の典型例となった。この生成的なステップでは、分割統治（divide-and-conquer）という伝統的な戦略を用いている。つまり、問題の自明でない実例(instance)を、関連する2つの小さな問題に分割し、それらの小さな問題を解き、その解を元の問題の解に結合するのである。クイックソートの場合、中間目標は数字のリストを2つのリストに分割することである。

    ・1つ目は、最初の数よりも厳密に小さい数をすべて含むもの

    ・もうひとつは、最初の数よりも厳密に大きい数をすべて集めたものです。

次に、2つの小さなリストをクイックソート・アルゴリズムでソートする。2つのリストの並べ替えが終わると、その結果は最初の要素が中央に置かれた状態で構成されます。その最初の要素は、その特別な役割からピボットと呼ばれます。

            イメージ

    図148:クイックソートアルゴリズムの図解

クイックソートの仕組みを理解するために、クイックソート(list 11 8 14 7)の例を見てみましょう。図148は、このプロセスを図式化したものである。この図は、上半分の「分割」フェーズと下半分の「統治」フェーズで構成されます。

分割段階は、箱と実線の矢印で表現される。丸で囲んだ中央のピボット、その左側にピボットより小さい数の箱に入ったリスト、そして右側にピボットより大きい数の箱に入ったリストです。処理の各ステップではピボットとして少なくとも1つの数を分離させます。つまり、隣接する2つのリストは、与えられたリストよりも短いということです。その結果、全体としての処理も終了します。

最初のステップで、入力が (list 11 8 14 7) である場合を考えてみましょう。ピボットは11です。リストを11より大きい項目と小さい項目に分割すると、(list 8 7)と(list 14)が生成されます。分割の残りのステップも同じように行われる。すべての数字をピボットとして分離した時点で、分割は終了します。この時点ですでに、ピボットを左から右に読むことで、最終的な結果を読み取ることができます。

統治の段階は破線の矢印と箱入りのリストで表現される。3本の矢印がそれぞれの結果ボックスに入ります。真ん中の矢印はピボットから、左の矢印は小さい数字を並べた結果ボックスから、右の矢印は大きい数字を並べた結果ボックスから、それぞれ入っています。各ステップごとに、ピボットである結果リストに少なくとも1つの数字が追加され、図の下に向かってリストが大きくなっていくことになります。下部の箱は、上部にある与えられたリストを並べ替えたものです。

一番左上の統治のステップを見てください。これはピボット7と2つの空のリストを組み合わせて、'(7)を生成しています。その次のステップは、8を分離した分割ステップに相当し、'(7 8)が得られます。統治段階での各レベルは、分割段階での対応するレベルを反映しています。結局のところ、全体のプロセスは再帰的です。


練習問題 424
(list 11 9 2 18 12 14 4 1)について、図 148 のようなクイックソート図を描いてください。■


さて、クイックソートの考え方をよく理解したところで、ISL+に翻訳してみましょう。明らかに、quick-sort< は2つのケースを区別している。入力が '() であれば、このリストはすでにソートされているので '() を生成し、そうでなければ生成的再帰を実行します。この場合分けは、次のようなcond式を示唆します。


  ; [List-of Number] -> [List-of Number]
  ; alonのソートされたバージョンを生成する。
  (define (quick-sort< alon)
    (cond
      [(empty? alon) '()]
      [else ...]))


最初のケースは答えが与えられています。2番目のケースでは、quick-sort< の入力が空でないリストであるとき、アルゴリズムはリストの最初の要素を使用してリストの残りを2つのサブリストに分割します：ピボットより小さいすべての要素を持つリストとピボットより大きい要素を持つもう一つのリストです。

リストの残りの部分はサイズが不明であるため、我々はリストの分割を2つの補助関数 smallers と largers に任せます。これらの関数はリストを処理し、それぞれ、ピボットより小さい要素と大きい要素をフィルターします。したがって、各補助関数は2つの引数、すなわち、数のリストと数を受け取ることになる。この2つの関数を設計することは、構造的再帰の訓練になります。自分でやってみるか、図149に示す定義を読んでみてください。


--
; [List-of Number] -> [List-of Number]
; alonのソートされたバージョンを生成する。
; 番号がすべてdistinctであると仮定する
(define (quick-sort< alon)
  (cond
    [(empty? alon) '()]
    [else (local ((define pivot (first alon)))
            (append (quick-sort< (smallers alon pivot))
                    (list pivot)
                    (quick-sort< (largers alon pivot))))]))
 
; [List-of Number] Number -> [List-of Number]
(define (largers alon n)
  (cond
    [(empty? alon) '()]
    [else (if (> (first alon) n)
              (cons (first alon) (largers (rest alon) n))
              (largers (rest alon) n))]))
             
; [List-of Number] Number -> [List-of Number]
(define (smallers alon n)
  (cond
    [(empty? alon) '()]
    [else (if (< (first alon) n)
              (cons (first alon) (smallers (rest alon) n))
              (smallers (rest alon) n))]))

    図149：クイックソート・アルゴリズム
--


これらのリストはそれぞれquick-sort<を使って別々にソートされるが、これは再帰の使用を意味し、具体的には次の2つの式が使われる。

   1.  (quick-sort< (smallers alon pivot)) は、ピボットより小さい要素のリストをソートします。

   2.  (quick-sort< (largers alon pivot))で、ピボットより大きな要素のリストをソートします。


quick-sort< は、上記2つのリストがソートされたバージョン（のリスト）を取得したら、その2つのリストと pivot を適切な順序で結合する必要があります。最初と最後のリストはすでにソートされているので、quick-sort< は単純に append を使用することができます。

(append (quick-sort< (smallers alon pivot))
        (list (first alon))
        (quick-sort< (largers alon pivot)))


図149はプログラム全文を含みます；進む前に読んでください。

実際の関数定義ができたので、上の例を手で評価することができます。

(quick-sort< (list 11 8 14 7))
==
(append (quick-sort< (list 8 7))
        (list 11)
        (quick-sort< (list 14)))
==
(append (append (quick-sort< (list 7))
                 (list 8)
                (quick-sort< '()))
        (list 11)
        (quick-sort< (list 14)))
==
(append (append (append (quick-sort< '())
                        (list 7)
                        (quick-sort< '()))
                (list 8)
                (quick-sort< '()))
        (list 11)
        (quick-sort< (list 14)))
==
(append (append (append '()
                         (list 7)
                        '())
                (list 8)
                '())
        (list 11)
        (quick-sort< (list 14)))
==
(append (append (list 7)
                (list 8)
                '())
        (list 11)
        (quick-sort< (list 14)))
...

この計算は、ソート処理の本質的なステップ、すなわち、分割ステップ、再帰的なソートのステップ、および3つの（部分リストの）連結を示している。この計算から、図148に示された処理をquick-sort< がどのように実装しているかを容易に理解することができる。

図148と計算は、quick-sort< が与えられたリストの構造をいかに完全に無視しているかということも示しています。最初の再帰は元々与えられたリストから離れた2つのリストに対して働き、2番目の再帰はリストの3番目の項目に対して動作します。これらの再帰はランダムではありませんが、データ定義の構造には依存していないことは確かです。

Quick-sort< の構成と11章の"Design by Composition" のsort>関数の構成を対比してください。後者の設計は構造設計のレシピに従っており、リストを項目ごとに処理するプログラムができあがります。リストを分割することで、quick-sort<はリストのソート処理を高速化することができますが、その代償として、プレーンなfirstとrestを使用することができません。


練習問題425
図149のsmallersと largersの目的の声明を明瞭にしなさい。■


練習問題426
上からの手による評価を完成させなさい。この評価をよく見てみると、quick-sort< のための追加の些細なケースを示唆しています。 quick-sort< が 1要素からなるリストを消費すると、そのリストをそのまま返します。結局のところ、1つの要素からなるリストのソートされたバージョンはリストそのものなのです。

この観測を利用するために、quick-sort< を修正してください。この例をもう一度評価してください。修正されたアルゴリズムは何ステップを節約できるか？ ■


練習問題427
quick-sort< は多くの場合問題のサイズを素早く小さくしますが、小さな問題では不適切に遅くなります。それゆえ、人々は問題のサイズを小さくするためにquick-sort<を使い、リストが十分に小さくなったら別のソート関数に切り替えます。

入力の長さがある閾値以下であれば sort< ("11.3 Auxiliary Functions that Recur" の sort> を適切に適応させたもの) を使用する quick-sort< のバージョンを開発せよ。■


練習問題428
quick-sort< への入力に同じ数字が何度か含まれている場合、アルゴリズムは入力より厳密に短いリストを返します。これはなぜですか？問題を修正し、出力が入力と同じ長さになるようにしてください。■


練習問題429
関数 filterを使用して、smallers と largers を定義してください。■


練習問題430
与えられたリスト alon を、ピボットより小さい alon の要素を含むリストとそうでないものを含むリストに分割する、比較関数 < を 1 つだけ使うquick-sort< の別バージョンを開発せよ。

プログラムを一つの関数としてまとめるためにlocalを使用します。この関数がリストと比較関数を消費するように、この関数を抽象化してください。■



------------------------------------------------------

26 アルゴリズムの設計

このパートの概要で、生成的再帰関数の設計が構造設計よりもアドホック("特別の、その場その場の")であることを既に説明した。25章で示したように、2つの生成的再帰は関数を処理する方法が根本的に異なることがある。bundle と quick-sort< はどちらもリストを処理するが、前者が少なくとも与えられたリストの順序を尊重するのに対し、後者は与えられたリストを自在に並べ替える。問題は、このように大きく異なる関数を作成する際に、単一の設計レシピで対応できるかどうかである。

最初のセクションでは、設計レシピのプロセスの次元を生成的再帰性に適合させる方法を示す。第2のセクションでは、アルゴリズムが入力の一部に対して答を生成できないことがあるという、もう一つの新しい現象に注目する。そのため、プログラマはプログラムを分析し、プログラムの終了に関するコメントで設計の情報を補完する必要がある。残りの節では、構造的再帰と生成的再帰を対比させる。

(訳注：この本では、生成的再帰とはいわゆるアルゴリズムを使った再帰のことを指しています。)

=====

26.1 設計レシピの適用

前章の事例をもとに、構造設計の一般的な6つのステップを考えてみましょう。

　・前回同様、問題の情報をデータとして、選択したプログラミング言語で表現する必要があります。問題のデータ表現の選択は、計算プロセスの考え方に影響を与えるので、事前にある程度の計画を立てることが必要である。あるいは、バックトラック(後戻り)して異なるデータ表現を検討することも準備しておく必要があります。いずれにせよ、問題の情報を分析し、データコレクションを定義する必要があります。


  ・また、シグネチャ、関数のヘッダ、目的の声明も必要である。生成ステップはデータ定義の構造とは無関係なので、目的の声明は、関数が何を計算するかということを越えて、関数がどのようにその結果を計算するかも説明しなければならない。


  ・前章でbundleやquick-sort<を説明したように、関数の例で"how"を説明することが有効である。つまり、構造的な世界での関数の例は関数がどの入力に対してどの出力を出すかを指定するだけであるが、生成的再帰の世界での関数の例の目的は、計算処理の背後にある基本的な考え方を説明することである。

  　bundle については、例で関数が一般的にどのように動作するか、また、特定の境界の例でどのように動作するか記述しています。quick-sort<では、図148の例で、関数が与えられたリストをピボットに関してどのように分割するかを説明しています。このような作業例を目的の声明に加えることで、私たち設計者は望ましい処理の理解を深め、このコードの将来の読者にこの理解を伝えることができます。


  ・この議論は、アルゴリズムに関する一般的なテンプレートを示唆している。大雑把に言えば、アルゴリズムの設計は2種類の問題、すなわち、自明に解決可能な問題とそうでない問題を区別する(ここでは「自明」は専門用語である)。ある問題が自明に解決できる場合、アルゴリズムはその解を生成する。例えば、空のリストや1つの項目のリストをソートする問題は、自明的に解決可能である。しかし、多数の項目を持つリストは自明でない問題である。このような非自明な問題に対しては、アルゴリズムは、与えられた問題と同じ種類の問題を新たに生成し、それらを再帰的に解いて、その解を組み合わせて全体の解とするのが一般的である。

　　このスケッチに基づき、すべてのアルゴリズムはおおよそこのような構成になっています。

  (define (generative-recursive-fun problem)  
    (cond
      [(trivially-solvable? problem) 
       (determine-solution problem)]   
      [else
       (combine-solutions     
         ... problem ...
         (generative-recursive-fun    
           (generate-problem-1 problem))  
         ... 
         (generative-recursive-fun        
         (generate-problem-n problem)))])) 

  　元の問題は、新しく生成された問題の解を組み合わせるために必要になることがあるため combine-solutionsに渡されている。

  ・このテンプレートは、あくまでも示唆的な青写真であり、決定的な形ではありません。テンプレートの各パーツは、次の4つの問いについて考えることを思い出させるためのものです。

     - 自明に解決可能な問題は何か。

     - 自明な問題はどのように解決されるか。

     - アルゴリズムはどのようにして、元の問題よりも簡単に解ける新しい問題を生成するのでしょうか？ 我々が生成する新しい問題は1つなのか、それとも複数あるのか？

     - 与えられた問題の解は、新しい問題の（1つの）解と同じなのでしょうか？それとも、解を組み合わせて元の問題の解を作る必要があるのでしょうか？その場合、元の問題のデータから何か必要なものがあるのでしょうか？

    アルゴリズムを関数として定義するためには、これら4つの質問に対する答えを、選択したデータ表現に応じた関数や式で表現する必要がある。

    このステップでは、9章 "Designing with Self-Referential Data Definitions" にあるテーブル駆動の試みが再び役立つかもしれない。「25.2 構造を無視した再帰処理」のquick-sort< の例を再考してみましょう。quick-sort< の中心的なアイデアは、与えられたリストをより小さいアイテムとより大きいアイテムのリストに分割し、それらを別々にソートすることである。図150は、いくつかの簡単な数値の例が、自明でない場合についてどのように動作するかを綴っている。これらの例から、4番目の質問に対する答えは、(ピボットより）小さい数がソートされたリスト、ピボットの数、（ピボットより）大きい数がソートされたリストを append することであると推測するのは簡単で、これは簡単にコードに変換することができます。

alon        pivot      sorted, smaller     sorted, larger      expected
------------------------------------------------------------------------------- 
'(2 3 1 4)  2          '(1)                '(3 4)              '(1 2 3 4)
'(2 0 1 4)  2          '(0 1)              '(4)                '(0 1 2 4)
'(3 0 1 4)  3          '(0 1)              '(4)                '(0 1 3 4)

    図 150:解を組み合わせるためのテーブルベースの推測手法


  ・関数が完成したらテストするときです。前述したように、テストの目的はバグを発見し排除することです。


練習問題431
bundleの問題に対して上記4つの重要な質問と、quick-sort<の問題に対して最初の3つの質問に答えよ。generate-problemのインスタンスはいくつ必要ですか？ ■


練習問題432
演習 219 では、関数 food-create が紹介されています． この関数は Posn を消費して、与えられた Posn とは異なることが保証されたランダムに選ばれた Posn を生成します．まず、2つの関数をlocalを使って1つの定義として再定式化し、次にfood-createの設計を正当化しなさい。■


=====

26.2 (処理の）終了

生成的再帰は、計算に「非終端」という全く新しい側面を加える。bundleのような関数は、ある入力に対して決して値を生成したり、エラーを通知したりしないことがある。練習問題421では、(bundle '("a" "b" "c") 0)の結果は何かと問われているが、ここでは、なぜ結果が出ないのかについて説明する。

  (bundle '("a" "b" "c") 0)
  ==
  (cons (implode (take  '("a" "b" "c") 0))
        (bundle (drop  '("a" "b" "c") 0) 0))
  ==
  (cons (implode '())
         (bundle (drop  '("a" "b" "c") 0) 0))
  == (cons "" (bundle (drop  '("a" "b" "c") 0) 0))
  == (cons "" (bundle '("a" "b" "c") 0))
  

  この計算は、(bundle '("a" "b" "c") 0)の評価が、まったく同じ式の結果を持つことを必要とすることを示している。ISL+の文脈では、これは評価が止まらないことを意味する。コンピュータ科学者は、bundleが第2引数が0になるときに終了しないという。関数がループしている、あるいは計算が無限ループに陥っているとも彼らは言う。

この洞察を、最初の4つのパートで示された設計と対比してください。レシピに従って設計されたすべての関数は、すべての入力に対して答えを生成するか、エラーシグナルを発生させるかのどちらかです。結局のところレシピは各自然再帰が、入力そのものではなく入力の当面の一部を消費することを指示しているのです。データは階層的に構築されるため、入力は各段階で縮小する。最終的に、関数はアトミックなデータ片に適用され、再帰は停止する。

この注意点は、生成的再帰関数が発散する理由も説明している。生成的再帰の設計レシピによれば、アルゴリズムは何の制限もなく新しい問題を生成することができる。もし、新しい問題が与えられた問題よりも小さいという保証を設計レシピが必要とすれば、アルゴリズムは終了する。しかし、そのような制限を課すと、bundleのような関数の設計をいたずらに複雑にしてしまう。

そこで本書では、設計レシピの最初の6段階をほぼそのままに、7番目の段階である終了論証を追加して補う。図151は生成的再帰の設計レシピの最初のパート、図152は2つ目のパートを示したものである。これらは、従来の表形式で設計レシピを示している。修正されていないステップには、アクティビティ欄にダッシュ('―')が付されている。その他は、生成的再帰の設計レシピが構造的再帰の設計レシピとどのように異なるかのコメント付きである。図152の最後の行は全く新しいものである。

終了の議論には2つの形式がある。最初のものは、各再帰呼び出しが与えられた問題より小さい問題で動作する理由を論証するものである。多くの場合、この議論は簡単である。まれに、このような議論に対して定理を証明するために数学者と一緒に作業する必要がある場合がある。2つ目は、終了しないかもしれない関数を例にして説明します。理想的には、その形式は関数がループする可能性のあるデータのクラスも記述すべきです。まれに、コンピュータサイエンスがまだ十分に知らないために、どちらの議論もできないことがあります。


 段階    　　  　結果       	         活動
---------------- ----------------------- ------------------------------------------------
 問題分析        データ表示と定義        ―
---------------- ----------------------- ------------------------------------------------
 ヘッダー        関数の"how"に関する     関数が何を計算するかという説明に、
                 目的の声明              どのように結果を計算するかという一行を追加する。
---------------- ----------------------- ------------------------------------------------
 例              例題とテスト            いくつかの例に関する"how" をやりぬく。
---------------- ----------------------- ------------------------------------------------
 テンプレート    固定されたテンプレート  ―
---------------- ----------------------- ------------------------------------------------
　　図151 アルゴリズムの設計アルゴリズムの設計(その1)


 段階    　　  　結果       	         活動
---------------- ----------------------- ------------------------------------------------
 定義            本格的な関数定義        ・自明な問題に対する解の条件を設定すること
                                  　　　 ・自明な問題に対する解を設定すること
                                         ・自明でない問題に対する新しい問題の生成方法
                                         （場合によっては補助関数を使用）を決定すること
                                         ・生成した問題の解を与えられた問題に対する
                                         　解に結合する方法を決定すること
---------------- ----------------------- ------------------------------------------------
 テスト         誤りをみつける           ―
---------------- ----------------------- ------------------------------------------------
 終了           (1)各再帰呼び出しの      各再帰データに対する問題データが
                 サイズ引数、または      与えられたデータより小さいかどうかを調べる;
                (2)終了時の例外の例      関数がループする原因となる例を探す
---------------- ----------------------- ------------------------------------------------
     図152 アルゴリズムの設計アルゴリズムの設計(その2)


この2種類の終了論証を例として説明しよう。bundle 関数では、チャンクサイズ 0 について読者に警告すれば十分である。

    ; [List-of 1String] N -> [List-of String]
    ; sの部分文字列を長さnの文字列に束ねる。
    ; 終了: (bundle s 0) は s が '()' でない限りループする。
    (define (bundle s n) ...)

この場合、bundleがいつ終了するかを正確に記述する述語を定義することが可能である。quick-sort< については、quick-sort< の再帰的な使用はそれぞれ alon よりも短いリストを受け取るということが重要な観察点である。

    ; [List-of Number] -> [List-of Number]
    ; alonをソートしたもの（リスト）を作成する。
    ; 終了： quick-sort< の再帰的な呼び出しの両方はピボットアイテムがないリストを受け取る
    ; termination both recursive calls to quick-sort<
    ; receive list that miss the pivot item
    (define (quick-sort< alon) ...)

ある例では、一方のリストはピボットより厳密に小さい数からなるリストであり、もう一方は(ピボットより)厳密に大きい数からなるリストである。


練習問題433
すべての入力に対して終了が保証された検査済バージョンの bundle を開発せよ。元のバージョンではループしてしまうような場合、エラーを通知することができる。■


練習問題434
quick-sort<の2つの"問題生成器"の1つである smallers の定義を考えてみよう。

  ; [List-of Number] Number -> [List-of Number]
  (define (smallers l n)
    (cond
      [(empty? l) '()]
      [else (if (<= (first l) n)
                (cons (first l) (smallers (rest l) n))
                (smallers (rest l) n))]))

このバージョンを「25.2 構造を無視する再帰」のquick-sort< の定義と一緒に使うと、何が問題になるのでしょうか？■


練習問題435
練習問題430や練習問題428に取り組んだとき、あなたはループする解答を作ったかもしれません。同様に、練習問題434では、quieck-sort<の終了論証がいかにもろいものかを実際に明らかにしています。すべての場合において、smallersとlargers は最大でも与えられたリストと同じ長さのリストを生成するという考えと、どちらの関数も与えられたピボットを結果に含まないという理解に基づいているのです。

この説明に基づいて quick-sort< の定義を修正し、与えられたリストより短いリストを smallers と largers 両方の関数が受け取るようにしなさい。■


練習問題436
演習問題432からfood-createの終了論証を定式化しなさい。■


=====

26.3 構造的再帰と生成的再帰

アルゴリズムのテンプレートは、構造的に再帰的な関数を含むほど一般的なものである。図153の左側(generalの定義)を考えてみよう。このテンプレートは1つの自明な節と1つの生成ステップを扱うように特化されている。もし、trivial? を empty? に、generate を rest に置き換えたら、リスト処理関数のテンプレートが得られる；図153の右側(specialの定義)を参照。

(define (general P)
  (cond
    [(trivial? P) (solve P)]
    [else
     (combine-solutions
       P
       (general
         (generate P)))]))

	
(define (special P)
  (cond
    [(empty? P) (solve P)]
    [else
     (combine-solutions
       P
       (special (rest P)))]))

    図153:生成的再帰性から構造的再帰性へ


練習問題437
以下を満たすようなsolveとcombine-solutionsを定義せよ：

   ・1. specialは入力の長さを計算する。

   ・2. specialは与えられた数値のリストにある各数の反数(政府の符号を変えた数)を求める。

   ・3. specialは与えられた文字列のリストを大文字に変える。

これらの演習から、あなたは何を結論づけることができますか？ ■


さて、構造的再帰設計と生成的再帰設計の間に本当に違いがあるのだろうかと思われるかもしれません。我々の答えは「場合による」です。もちろん、構造的再帰を使う関数はすべて生成的再帰の特殊なケースに過ぎないと言うこともできます。もちろん、構造的再帰を使う関数はすべて生成的再帰の特殊なケースに過ぎないと言うこともできますが、関数の設計プロセスを理解する上で、この「すべてが等しい」という態度は何の役にも立ちません。それは、異なる形式の知識を必要とし、異なる結果をもたらす2種類の設計を混同しているからです。もう1つは、問題解決のプロセスそのものを深く、しばしば数学的に理解する必要があります。一方はプログラマに自然な形で関数を終了させるように仕向け、もう一方は終了についての議論を必要とする。この2つのアプローチを混同することは有益ではありません。



=====

26.4 選択をする

数字のリストをソートする関数fを操作するとき、f が sort< なのか quick-sort< なのかを知ることはできない。 2つの関数は観測可能な等価性を持って動作する。このことは、プログラミング言語がsort<, quick-sort< のどちらを提供すべきかという問題を提起している。より一般的には、構造的再帰と生成的再帰を使って関数を設計できる場合、どちらを選ぶべきかを考えなければならない。

 (観測可能な等価性は、プログラミング言語の研究からの中心的なコンセプトです)。

この選択がもたらす結果を説明するために、数学の古典的な例として、2つの正の自然数の最大公約数（gcd）を求める問題を取り上げることにする。このような数はすべて共通に1を約数として持っている。2と3のように、これが唯一の共通約数であることもある。6も25もいくつかの約数を持つ数である。

    6は 1, 2, 3, 6で割り切れる。

    25は 1, 5, 25で割り切れる。

一方、18と24は共通の約数が多く、その最大公約数は6である。

    18は 1, 2, 3, 6, 9, 18で割り切れる。

    24は 1, 2, 3, 4, 6, 8, 12, 24で割り切れる。

デザインレシピの最初の3ステップを完了させるのは簡単です。

    ; N[>= 1] N[>= 1] -> N
    ; nとmの最大公約数を求める。
    (check-expect (gcd 6 25) 1)
    (check-expect (gcd 18 24) 6)
    (define (gcd n m) 42)

シグネチャは、1以上の自然数 2個を入力として指定する。

ここから、構造的再帰と生成的再帰的の両方による関数を設計します。本書のこの部分は生成的再帰についてなので、図154には構造的再帰による答を示すだけで、設計のアイデアは演習に任せることにします。ただ、(= (remainder n i) (remainder m i) 0)は、nとmが共にiで割り切れるという考えをコード化していることに注意してください。

  (define (gcd-structural n m)
    (local (; N -> N
            ; nとmのgcdがiより小さいかどうかを判定する。
            (define (greatest-divisor-<= i)
              (cond
                [(= i 1) 1]
                [else
                 (if (= (remainder n i) (remainder m i) 0)
                     i
                     (greatest-divisor-<= (- i 1)))])))
      (greatest-divisor-<= (min n m))))

    図154:構造的再帰性による最大公約数の求め方


練習問題438
あなたの言葉で、greatest-divisor-<= はどのように機能するか述べてください。設計レシピを使って、ぴったりした言葉を見つけましょう。ローカルで定義された greatest-divisor-<= はなぜ (min n m) で再帰するのですか？■


gcd-structuralの設計はかなり単純で、同時に素朴でもある。これは、nとmの小さい方から1までのすべての数について、nとmの両方を割り切るかどうかをチェックし、そのようになる最初の数を返すだけです。nとmが小さいうちはこれでうまくいいます。しかし、次のような例を考えてみよう。

    (gcd-structural 101135853 45014640)

その結果は177である。gcd-structuralは45014640の偶数回割り切れる条件、つまり45014640 - 177の余りをチェックするのです。これだけの数のremainder関数を―2回も!―チェックするのは大変な作業なので、そこそこ速いコンピュータでもこの作業を完了するのに時間がかかります。


練習問題439
gcd-structuralをDrRacketにコピーし、以下をインタラクションエリア内に設置して評価してください。

    (time (gcd-structural 101135853 45014640))  
■


数学者たちは、この構造的再帰関数の非効率性をずいぶん前に認識していたので、約数を求める問題を深く研究した。その本質的な洞察は『 2つの自然数について、大きい方をL、小さい方をSとすると、最大公約数は、Sと、LをSで割った余りの最大公約数に等しくなる』ということです。この洞察を方程式として表現すると次のようになります：

    (gcd L S) == (gcd S (remainder L S))

(remainder L S)はLとSの両方より小さいので、右辺のgcdの使用はSを先に消費する。

この洞察が、以下の小さな例にどのように適用されるかを説明します。

 ・与えられた数字は18と24である。

 ・上記の洞察によれば、それらは18と6と同じgcdを持つ。

 ・そして、この2つは、同じ最大公約数6と0を持っています。

ここで、0が予想外の数字であるため、行き詰まったように見えます。しかし、0はすべての数で均等に割り切れるので、6という答がわかったことになります。

例題に取り組むことで、基本的な洞察が検証されるだけでなく、その洞察をアルゴリズムに転換する方法も提案されます。

 ・(2つの)数の小さい方が0であるとき、自明なケースに直面する。

 ・2数のうち大きい方の数が解になるという自明なケース。

 ・新しい問題を生成するのに1個のremainderの計算が必要である

 ・上記の等式から、新しく生成された問題の答が元々与えられていた問題の答でもあることわかる。

つまり、デザインレシピの4つの問いに対する答が抽出されるのです。

  (define (gcd-generative n m)
    (local (; N[>= 1] N[>= 1] -> N
            ; generative recursion
            ; (gcd L S) == (gcd S (remainder L S)) 
            (define (clever-gcd L S)
              (cond
                [(= S 0) L]
                [else (clever-gcd S (remainder L S))])))
      (clever-gcd (max m n) (min m n))))

    図155:生成的再帰による最大公約数の求め方

図155は、アルゴリズムの定義を示しています。local定義では、この関数の主力であるclever-gcdを導入している。その最初のcond行はsmallerと0を比較することで自明なケースを発見し、マッチする解を生成します。生成ステップでは、clever-gcdの新しい第1引数としてsmallerを、clever-gcdの新しい第2引数として (remainder large small)を 使用します。

ここで、上記の例でgcd-generativeを使うとすると。

    (gcd-generative 101135853 45014640)

はほぼ瞬時に反応することがわかる。手で評価したところ、clever-gcdは解を生成するまでにわずか9回しか再帰していないことがわかった。

  ...
  == (clever-gcd 101135853 45014640)
  == (clever-gcd 45014640 11106573)
  == (clever-gcd 11106573 588348)
  == (clever-gcd 588348 516309)
  == (clever-gcd 516309 72039)
  == (clever-gcd 72039 12036)
  == (clever-gcd 12036 11859)
  == (clever-gcd 11859 177)
  == (clever-gcd 177 0)

これは、9個のremainderの条件しかチェックしないことを意味し、gcd-structuralが費やすよりもはるかに小さな労力であることは明らかです。


練習問題440
gcd-generativeをDrRacketの定義領域にコピーし、次をインタラクション領域で評価してください。

    (time (gcd-generative 101135853 45014640))
■


あなたは今、生成的再帰設計が gcd 問題のとても速い解法を発見したと思い、生成的再帰が常に正しい方法であると結論づけるかもしれない。この判断は3つの理由からとても軽率である。第一に、よく設計されたアルゴリズムであっても、同等の構造的再帰的な関数より常に高速であるとは限らない。例えば、quick-sort< は大きなリストに対してのみ有効で、小さなリストに対しては標準的なsort< 関数の方が速いのです。さらに悪いことに、アルゴリズムの設計が悪いと、プログラムの性能に打撃を与える可能性があります。第二に、構造的再帰のレシピを使って関数を設計することは、一般に簡単です。逆に、アルゴリズムを設計するには、新しい問題をどのように発生させるかというアイデアが必要で、このステップでは、しばしば深い洞察が必要とされます。最後に、関数を読むプログラマは、多くの文書がなくても、構造的再帰関数を容易に理解することができる。しかし、アルゴリズムの生成の段階は、「エウレカ!」に基づいており、良い説明がなければ、将来の読者（古いバージョンの自分自身も含む）にとって理解することが困難である。

経験上、プログラムのほとんどの関数は構造的な設計を採用しており、生成的な再帰を利用するものはごくわずかです。構造的再帰と生成的再帰のどちらを使ってもよいという状況に遭遇した場合、まず構造的再帰から始めるのが最もよい方法です。その結果、処理に時間がかかりすぎるようであれば、そのときこそ生成的な再帰の使い方を検討するときです。


練習問題441

    (quick-sort< (list 10 6 8 9 14 12 3 11 14 16 2)))

を手で評価してみてください。quick-sort<の新しい再帰的な呼び出しを導入する行だけを表示してください。quick-sort<の再帰的な適用は何回必要ですか？append関数は何回再帰的に呼び出されるか？長さnのリストに対する一般規則を提案しなさい。

次に、
   (quick-sort< (list 1 2 3 4 5 6 7 8 9 10 11 12 13 14))

を手で評価してみてください。quick-sort<を何回再帰的に実行する必要があるか？appendの再帰的な適用は何回必要か？これは演習の最初の部分と矛盾しているか？■


練習問題442
sort< と quick-sort< を定義域に追加してください。関数のテストを実行し、基本的な例で動作することを確認しなさい。また、大きなテストケースをランダムに作成する関数である create-tests を開発してください。そして、様々なリストに対してそれぞれがどの程度速く動作するかを調べてください。

この実験は、短いリストでは普通のsort<関数がしばしばquick-sort<に勝り、逆もまた真なりという主張を裏付けるものでしょうか。

クロスオーバーポイントを決定します。それを使って、大きなリストでは quick-sort< のように振る舞い、このクロスオーバーポイント以下のリストでは sort< のように振る舞う賢いソート関数を構築してください。練習問題427と比較してみてください。■


練習問題443
gcd-structuralのヘッダを考えると、設計レシピの素朴な使い方として、以下のテンプレートかその変形を使うかもしれません。

  (define (gcd-structural n m)
    (cond
      [(and (= n 1) (= m 1)) ...]
      [(and (> n 1) (= m 1)) ...]
      [(and (= n 1) (> m 1)) ...]
      [else
       (... (gcd-structural (sub1 n) (sub1 m)) ...
        ... (gcd-structural (sub1 n) m) ...
        ... (gcd-structural n (sub1 m)) ...)]))

なぜ、この作戦では約数を求めることができないのでしょうか？■


練習問題444
練習問題443は、gcd-structuralの設計には、ある程度の計画と構成による設計が必要であることを意味しています。

最大公約数 "の説明から、2段階のアプローチが可能であることがわかります。まず、自然数の約数のリストを計算する関数を設計する。次に、nの約数のリストとmの約数のリストに含まれる最大公約数を選ぶ関数を設計する。

    (define (gcd-structural S L)
      (largest-common (divisors S S) (divisors S L)))
     
    ; N[>= 1] N[>= 1] -> [List-of N].
    ; kより小さいか等しい、lの約数を計算する。
    (define (divisors k l)
     　'())
     
    ; [List-of N] [List-of N] -> N
    ; リストkとlに共通にある中で、最大の数を求める。
    (define (largest-common k l)
      1)

なぜdivisorsは2つの数字を消費するのでしょうか？なぜ両方の用途でSを第1引数として消費するのでしょうか？■



------------------------------------------------------

27 テーマによるバリエーション

アルゴリズムの設計は、与えられた問題よりも簡単に解ける問題を作り、その解が与えられた問題の解決に貢献するというプロセスを非公式に記述することから始まる。このようなアイデアを思いつくには、ひらめき、応用分野への没頭、多くの種類の例に対する経験などが必要です。

本章ではアルゴリズムの例をいくつか紹介します。あるものは多くのアイデアの源である数学から直接引き出されたものであり、他のものは計算的な背景から得られたものです。最初の例は、我々の原理であるシェルピンスキーの三角形を図式化したものです。2つ目は、関数の根を求めるという簡単な数学の例で、分割統治原理を説明します。そして、この考え方を、広く使われている応用の、列(sequence)の探索のための高速なアルゴリズムに変える方法を示します。第3のセクションでは、実世界のプログラミングでよく問題になる1Stringの列の「構文解析」について説明します。


=====

27.1 フラクタル、最初の味わい

フラクタルは計算幾何学において重要な役割を担っている。ゲイリー・ウィリアム・フレイクはThe Computational Beauty of Nature (The MIT Press, 1998)の中で次のように述べています：「幾何学はフラクタル次元の対象を説明するために拡張することができる。フラクタルとして知られるこのようなオブジェクトは、自然界に見られる豊かで多様な形態をほとんど捉えている。フラクタルは、複数の ... スケールで構造的な自己相似性を持っており、フラクタルの一部分が全体と同じように見えることが多い」


           (画像のため省略)

    図156:シェルピンスキーの三角形


図156は、シェルピンスキーの三角形と呼ばれるフラクタル形状の一例を示したものである。基本形は中央のような（正）三角形である。この三角形を十分に多く三角形状に構成すると、一番左のような形になります。

図156の一番右の画像は、生成ステップの説明である。単体で見ると、「三角形が与えられたら、それぞれの辺の中点を求め、それらを互いに結ぶ」というものである。このステップでは、4つの三角形が得られる。これらの三角形が小さすぎない限り、外側の3つの三角形のそれぞれについてこのプロセスを繰り返す。

2htdp/image ライブラリの形状合成関数に適した別の説明は、中央の画像から右の画像への遷移に基づくものです。中央の三角形を2つ並べ、その上に1つコピーを置くと、右のような形にもなります。

  > (s-triangle 3)
  (画像のため省略)

  > (beside (s-triangle 3) (s-triangle 3))
  (画像のため省略)

  > (above (s-triangle 3)
           (beside (s-triangle 3) (s-triangle 3)))
  (画像のため省略)


このセクションでは、Sierpinski アルゴリズムを設計するための別の記述を使用します。"33.3 結果としての累算器"では最初の記述を扱う。目標は正三角形の画像を生成することで、我々は問題を(正)三角形の辺の長さである(正の)数値で符号化します。この決定により、シグネチャー、目的の声明、ヘッダーが生成されます：

  ; Number -> Image
  ; creates Sierpinski triangle of size side
  
  (define (sierpinski side)
    (triangle side 'outline 'red))

さて、いよいよ生成的再帰に関する4つの問いを取り上げます。

  ・与えられた数が非常に小さく、その中に三角形を描くことが無意味な場合、この問題は自明なものとなる。

  ・その場合、1個の三角形を生成すれば十分です。

  ・そうでなければ、アルゴリズムは(side / 2)のサイズのシェルピンスキーの三角形を生成しなければなりません。というのは、そのような三角形を2つ並べると元の1辺の長さが得られるためです。

  ・half-sized が、1辺の長さが(side / 2)のシェルピンスキーの三角形であるなら

    (above half-sized
           (beside half-sized half-sized))

    は一辺の長さがsizeのSierpinskiの三角形である。

--
  (define SMALL 4) ; ピクセル単位でサイズを指定する。
 
  (define small-triangle (triangle SMALL 'outline 'red))
 
  ; Number -> Image
  ; generative creates Sierpinski Δ of size side by generating
  ; one for (/ side 2) and placing one copy above two copies
  ; 1辺の長さが(/ side 2)の三角形を生成し、2つのその三角形を並べてその上に同じ三角形を1つ置くことによって
  ; サイズが side のシェルピンスキーの三角形を生成的に生成します。

  (check-expect (sierpinski SMALL) small-triangle)
  (check-expect (sierpinski (* 2 SMALL))
                (above small-triangle
                       (beside small-triangle small-triangle)))
 
  (define (sierpinski side)
    (cond
      [(<= side SMALL) (triangle side 'outline 'red)]
      [else
       (local ((define half-sized (sierpinski (/ side 2))))
         (above half-sized (beside half-sized half-sized)))]))

    図157:シェルピンスキーアルゴリズム
--


これらの答で、関数を定義するのは簡単です。図157に詳細を示します。「自明性の条件」は、ある定数SMALLに対して(<= side SMALL)と変換されます。自明な答の場合、この関数は与えられた大きさの三角形を返します。再帰的な場合、指定されたサイズの半分の大きさのシェルピンスキーの三角形に対して half-sizedという名前をlocal定義で導入します。再帰的な呼び出しによって小さなシェルピンスキーの三角形が生成されると、aboveとbesideによってこの画像が構成されます。

この図では、他に2つの点が強調されている。第一に、目的の声明は、関数が "何を" 達成するのか

    ; 一辺の長さが1.5mのシェルピンスキーの三角形になります。

そして、その目標を "どのように" 達成するのか

    ; 1辺の長さが(/ side 2)の三角形を生成し、...
    ; 2つのその三角形を並べてその上に同じ三角形を1つ置くことによって

を説明するものとして明示されていることです。

第二に、この例では、与えられたサイズが十分に小さい場合と、それでも大きすぎる場合の二つの可能性を示している。後者の場合、期待された結果を計算する式は、まさに目的の声明が意味するところを説明しています。

関数 sierpinski は生成的再帰に基づくので、関数を定義しそれをテストすることは最後のステップではありません。また、与えられた正当な入力に対して、なぜアルゴリズムが終了するのかを我々は考えなければなりません。sierpinskiの入力は1つの正の数 side です。もしその数がSMALLより小さければ、アルゴリズムは終了します。そうでない場合、再帰呼び出しは与えられた数の2分の1の数を使用する。したがって、SMALLが正であると仮定すると、アルゴリズムはすべての正の数 side について終了しなければならない。

シェルピンスキーのプロセスはその問題をすぐに解けるようになるまで半分に分割する、という見方がある。少し想像力を働かせれば、この過程を利用して、ある性質を持った数を探索できることがわかるでしょう。次節では、この考え方を詳しく説明します。



27.2 二分探索 (バイナリサーチ）

応用数学者は実世界を非線形方程式でモデル化し、それを解こうとします。具体的には、問題を数から数への関数fに変換し、次のようになるようなある数rを探します:

    f(r)=0

この値rをfの根 (root) と呼ぶ。

                イメージ

    図158:区間[a,b]に根を持つ数値関数f(ステージ1)

ここで、物理学の領域からの問題です。

 サンプル問題 ロケットが v [マイル/時間] の一定速度で d0 マイル先の目標に向かって一直線に飛んでいる．その後、a [マイル/(時間の2乗)]で t 時間加速する．ロケットはいつ目標に衝突するか？

物理学では、移動距離は時間の関数として次のように表されます。

    d(t) = (v * t + 1/2 * a * t^2)

いつ目標に到達するかという問題では、物体が目標に到達するような時間t0を求めることになります。

    d0 = (v * t0 + 1/2 * a * t0^2)

代数学から、これは2次方程式であり、d0, a, vがある条件を満たせば、このような方程式を解くことが可能であることが分かっています。

一般に、このような問題は2次方程式よりも複雑さを必要とします。これに対し、数学者は過去数世紀をかけて、様々な種類の関数に対する根の探索法を開発してきました。本節では、解析学の初期の成果である中間値の定理（Intermediate Value Theorem (IVT) ) に基づく解法を調べます。このアルゴリズムは、数学の定理に基づく生成的再帰の主要な例です。コンピュータ科学者はこれを二値探索アルゴリズムに一般化しました。

中間値の定理とは、連続関数 f が区間 [a,b] に根を持つのは、f(a) と f(b) が それぞれ x 軸の反対側にあるときである、とするものです。連続とは「ジャンプ」せず、ギャップ(間隙)がなく、「滑らか」な経路を進む関数のことです。

図158は中間値定理を説明する図である。関数fは、途切れることのない滑らかなグラフで示唆されるように、連続関数である。関数の値は aでx軸の下にあり、bで x軸の上にあります。そして実際に、(図158では "range 1"とラベル付けされている)区間のどこかでx軸と交差しています 。

ここで、aとbの中点を見てみましょう:

    m = (a + b) / 2

これは区間[a,b]を、より小さく、同じ大きさをもつ2個の区間に分割している。ここで、mにおけるfの値を計算し、それが0より下か上にあるかを見ることができます。ここで、f(m) > 0であるから、中間値の定理により、根は(2つの区間のうち)左の区間[a, m] にあることになります。図158の "range 2" と書かれた左の区間に根があることから、このことが確認できます。

これで、根の探索プロセスの重要なステップの記述ができました。次に、この記述を ISL+ のアルゴリズムに変換します。我々の最初のタスクはその目的を述べることです。明らかにこのアルゴリズムは、関数と、根を見つけることが期待される区間の境界を消費します。

  ; [Number -> Number] Number Number -> ...
  (define (find-root f left right) ...)

3つのパラメータは、任意の関数と数値ではありえません。find-rootが動作するためには、以下のことが成り立つと仮定しなければなりません：

  (or (<= (f left) 0 (f right))
      (<= (f right) 0 (f left)))

つまり、(f left) と (f right) は x 軸の反対側になければならない。

次に、関数の出力(仕様)を修正し、目的の声明を定式化する必要がある．簡単に言うと、find-rootは根を含む区間を見つけます。探索は区間をその大きさ、(- right left) が許容できるほど小さくなるまで、例えばある定数 ε より小さくなるまで分割します (DrRacketでは ε のようなギリシャ語の記号を使用することができます。しかし、代わりにEPSILONと書くこともできます)。その時点で、この関数は3つの出力 ―左境界、右境界、区間の表現― のうちの1つを作り出すことができます。そのうちのどれかが区間を完全に特定します。ここでは数字を返す方が簡単なので、左境界を選びます。以下は、完全なヘッダー情報です：

    ; [Number -> Number] Number Number -> Number
    ; fが 区間[R,(+ R A)]に根を持つようなRを決定する。
    ; fが連続であると仮定する
    ; (2) (or (<= (f left) 0 (f right)) (<= (f right) 0 (f left)))
    ; 生成的再帰: 
    ;  区間を半分に分割する。根はその半分の区間のどちらかにあるので(2)に従って区間を選び再帰的に実行する
    (define (find-root f left right))
      0)


練習問題445
次の関数定義を考えよ。

    ; Number -> Number
    (define (poly x)
      (* (- x 2) (- x 4)))  ; x^2 - 6*x + 8 

これは、その根を手作業で決定できるような2項式を定義するものです。

  > (poly 2)
  0
  > (poly 4)
  0

polyを使ってfind-rootのcheck-satisfied を使ったテストを定式化してください。

また、polyを使ってルート探索のプロセスを説明してください。区間[3,6]から始め、ε=0について以下のように情報を表にしてください。

step		left	f left		right	f right		mid	f mid
----		----	------		-----	-------		----	-----
n=1		   3        -1		 6.00	   8.00		4.50	 1.25
n=2		   3        -1		 6.00	   8.00		   ?	    ?

(訳注. f leftは polyに leftを代入した値です。たとえばleftが3のとき f leftは (* (- 3 2) (- 3 4)) つまり -1 です。
      また、mid は leftとrightの中間値です。たとえば left=3, right=6 のときmid=(/ (+ 3 6) 2) つまり4.5です)
■


次の課題は、アルゴリズム設計の4つの問いに取り組むことです。

   1. 問題が解けるときの条件と、それに対応する答が必要です。これまでの議論を踏まえると、これは簡単です：

        (<= (- right left) ε)

   2. 自明な場合の対応する答が残ります。

   3. 生成的(再帰)の場合、find-rootのための新しい問題を生成する式が必要である。我々の非公式な説明によれば、このステップでは中点とその関数の値を決定する必要があります。

        (local ((define mid (/ (+ left right) 2)))
                (define f@m (f mid)))
          ...)

    そして、その中点が次の区間を選ぶのに使われる。IVTの結果、

        (or (<= (f left) 0 f@m) (<= f@m 0 (f left))))

    が #trueであれば、区間[left,mid]は次の候補です。?? ←意味不明

    ところが

        (or (<= f@m 0 (f right)) (<= (f right) 0 f@m))

    が #trueの場合、[mid,right]が再帰呼び出しに使用されます。?? ←意味不明

    コードに置き換えると、localの本体は条件付きでなければならない。

        (cond
          [(or (<= (f left) 0 f@m) (<= f@m 0 (f left)))
           (... (find-root f left mid) ...)]
          [(or (<= f@m 0 (f right)) (<= (f right) 0 f@m)])
           (... (find-root f mid right) ...)])

    どちらのcond節でも、find-rootを使用して検索を継続します。

   4. 最後の質問に対する答えは明白です。find-rootの再帰的な呼び出しがfの根を見つけるので、他にやることはありません。


完成した機能を図159に示します。以下の演習問題では、その設計について詳しく説明します。

    ; [Number -> Number] Number Number -> Number
    ; fが[R,(+ R ε)]に根を持つようなRを決定する ;。
    ; fは連続であると仮定する
    ;  (or (<= (f left) 0 (f right)) (<= (f right) 0 (f left))) が#trueであると仮定します
    ; 生成的再帰は区間を半分に分割し、根はそのどちらかにあり、仮定にしたがって区間を選ぶ
    (define (find-root f left right)
      (cond
        [(<= (- right left) ε) left]
        [else
          (local ((define mid (/ (+ left right) 2))
                  (define f@mid (f mid)))
            (cond
              [(or (<= (f left) 0 f@mid) (<= f@mid 0 (f left)))
               (find-root f left mid)]
              [(or (<= f@mid 0 (f right)) (<= (f right) 0 f@mid))
               (find-root f mid right)]))]))

      図159:根元発見アルゴリズム


練習問題446
図159のプログラムに、練習問題445のテストを追加してください。A の値を変えて実験してください。■


練習問題447
poly関数には2つの根があります。polyと両方の根を含む区間でfind-rootを使用してください。■


練習問題448
find-rootアルゴリズムは、仮定が成立するすべての（連続）f、left、rightに対して終了する。なぜか？終了の議論を定式化しなさい。

ヒント find-rootの引数が大きさS1の区間を記述しているとする。find-rootの最初の再帰的呼び出しと2回目の再帰的呼び出しにおける左と右の間の距離はどのくらいか？何ステップ後に(- right left)はAより小さくなるか、またはAに等しくなるか？■


練習問題449
図159に示されるように、find-rootは各境界値に対してfの値を2回計算し、次の区間を生成する。この再計算を避けるために、localを使用せよ。

さらに、find-rootは再帰的な呼び出しにまたがって境界の値を再計算する。例えば、(find-root f left right) は (f left) を計算し、次の区間として [left,mid] が選ばれた場合、 find-root は再び (f left) を計算する．find-rootのように、leftとrightだけでなく、各再帰段階で (f left) と (f right) も消費するヘルパー関数を導入する．

この設計では、(f left)の再計算を何回までなら最大に回避できるだろうか？

注意 このヘルパー関数の2つの追加引数は各再帰ステージで変化しますが、その変化は数値引数の変化に関係します。これらの引数はいわゆる「アキュムレータ」で、「Ⅵ アキュムレータ」の話題である。■


練習問題450
関数fは、(<a b)が成立するとき、(<= (f a) (f b)) が成立するとき、単調増加する関数である。与えられた関数が連続であるだけでなく、単調増加であると仮定して、find-rootを簡略化せよ。■


練習問題451
テーブル(table)は、自然数 length と関数 arrayの2つのフィールドからなる構造です。arrayは 0から length (exclusive)(←??) の間の自然数を消費し、答を作り出します。

(Racketを含む多くのプログラミング言語は、表に似ている、配列とベクトルをサポートしています）

    (define-struct table [length array])
    ; tableは構造体である。
    ; (make-table N [N -> Number])

このデータ構造はやや特殊であるため、例を挙げて説明することが重要です：

    (define table1 (make-table 3 (lambda (i) i)))
     
    ; N -> Number
    (define (a2 i)
      (if (= i 0)
          pi
          (error "table2 is not defined for i =!= 0")))
    
    (define table2 (make-table 1 a2))

ここでは、table1の関数arrayは length フィールドが許す以上の入力に対して定義されています。table2 はただ1つの入力、すなわち 0 に対して定義されています。最後に、テーブルの中の値を調べるための便利な関数も定義しておきます:

    ; Table N -> Number
    ; tのarrayにおけるi番目の値を検索する
    (define (table-ref t i)
      ((table-array t) i))

テーブルtのルートは、(table-array t)の中で0に近接した数です(訳注 つまり微小な数εを定めておいて(table-array t)と0との差の絶対値がεより小さい)。ルートインデックスは(table-ref t i)がテーブルtのルートであるような自然数iです。(table-ref t 0) が (table-ref t 1) より小さく、(table-ref t 1) が (table-ref t 2)より小さく、 ... というように続くならば、テーブル t は単調に増加するとします。

find-linearを設計してください。この関数は、単調に増加するテーブルを消費し、テーブルのルートの最小のインデックスを見つけます。N に対して、0 から 1、2 と進み、与えられたテーブルの array-length に達するまで、構造的再帰のレシピを使用してください。このようなルート探索のプロセスはしばしば線形探索と呼ばれます。

次に find-binaryを設計してください。これは単調増加するテーブルのルートの最小のインデックスを求めますが、そのために生成的再帰を使用してください。通常のバイナリサーチと同様に、このアルゴリズムは区間を可能な最小のサイズに狭め、それからインデックスを選択します。終了の議論をするのを忘れないようにしてください。

ヒント： 重要な問題は、テーブルインデックスが自然数であり、普通の数でないことです。従って、findの区間境界の引数は自然数でなければならない。この観察が、(1)自明な解決可能問題の性質、(2)中点の計算、そして、(3)次に生成すべき区間の決定 をどう変えるかを考えてみましょう。具体的には、1024個のスロットを持つテーブルがあり、ルートは1023であるとする。find-linearとfind-binaryではそれぞれ何回のfindの呼び出しが必要でしょうか。■


=====

27.3 構文解析を垣間見る

"20章 反復的精密化"で述べたように、コンピュータにはファイル(File)があり、これは永久記憶の一形態です。私たちから見れば、ファイルは、特別な文字列によって割り込まれるが、単なる1文字列のリストである。

(脚注: 厳密にはオペレーティングシステムによって異なるが、我々の目的には関係ない。)

    ; File は以下のいずれかである。
    ; - '()
    ; - (cons "\n" File)
    ; - (cons 1String File)
    ;  解釈: ファイルの内容を表します。
    ; "\n"は改行文字です。

アイデアとしては、ファイルは"\n"つまり行の終わりを示すいわゆる改行文字で複数のLineに分けられます。次に進む前に行(Line)を導入しましょう。

    ; Line は [List-of 1String] である。

多くの関数がファイルを行のリストとして処理する必要があります。2htdp/batch-ioライブラリのread-linesはその一つです。具体的には、この関数はファイル

    (list 
      "h" "o" "w" " " "a" "r" "e" " " "y" "o" "u" "\n"
      "d" "o" "i" "n" "g" "?" "\n"
      "a" "n" "y" " " "p" "r" "o" "g" "r" "e" "s" "？")

を3つの行のリストに変換します。

    (list
      (list "h" "o" "w" " " "a" "r" "e" " " "y" "o" "u")
      (list "d" "o" "i" "n" "g" "?")
      (list "a" "n" "y" " " "p" "r" "o" "g" "r" "e" "s" "s""？"))

同様に、File

    (list "a" "b" "c" "\n" "d" "e" "\n" "f" "g" "h" "\n").

も3つのLineのリストに相当します。

    (list (list "a" "b" "c")
          (list "d" "e")
          (list "f" "g" "h"))


ストップ！ 3つのケース '(), (list "?n"), (list "?n" "?n") の Lineのリストによる表現は何でしょうか。なぜ、これらの例は重要なテストケースなのでしょうか。

1Stringsの列をLineのリストに変換する問題を構文解析(Parsing)問題と呼びます。多くのプログラミング言語では、ファイルから行、単語、数、そしてその他のいわゆるトークンを取得する関数が用意されています。しかし、そのような機能があったとしても、プログラムでは一般的にこれらのトークンをさらに構文解析する必要があります。このセクションでは、構文解析のテクニックの一端を垣間見ることができます。しかし、構文解析は非常に複雑であり、本格的なソフトウェアアプリケーションを作成する上で非常に重要であるため、ほとんどの学部カリキュラムには構文解析に関するコースが少なくとも1つは含まれます。ですから、このセクションをマスターしても実際の構文解析問題にきちんと取り組めるとは思わないでください。

まず、ファイルを行のリストに変換する関数について、署名、目的の声明、上記の例のうち1つ、そしてヘッダーという当たり前のことを述べることから始めます。

    ; File -> [List-of Line]
    ; ファイルを行のリストに変換する
     
    (check-expect (file->list-of-lines
                    (list "a" "b" "c" "\n"
                          "d" "e" "\n"
                          "f" "g" "h" "\n"))
                  (list (list "a" "b" "c")
                        (list "d" "e")
                        (list "f" "g" "h")))
     
    (define (file->list-of-lines afile) '())

また、「Recursion without Structure」の経験から、構文解析のプロセスも簡単に説明できる。

1. この問題は、ファイルが'()であれば、自明な解答可能である。

2. その場合、ファイルには行が含まれません。

3. それ以外の場合、ファイルには少なくとも1つの"\n"または他の1Stringが含まれます。これらの項目（最初の"\n"まで）は、ファイルの残りの部分から分離されなければなりません。残りの部分は、file->list-of-linesが解決できるのと同じ種類の新しい問題です。

4. そして、最初のセグメントを1行として、ファイルの残りの部分から生じるLineのリストにconsすれば十分です。

この4つの質問は、生成的な再帰関数のテンプレートの簡単なインスタンス化を示唆している。最初のセグメントをファイルの残りの部分から分離するためには、任意に長い1Stringsのリストをスキャンする必要があるので、私たちは2つの補助関数をウィッシュリストに入れます：first-lineは、最初の"\n"が現れるかリストの終わりを除いて、それまでのすべての1Stringsを収集します。remove-first-lineはfirst-lineが収集したものと全く同じアイテムを削除します。

; File -> [List-of Line]
; ファイルを行のリストに変換する
(define (file->list-of-lines afile)
  (cond
    [(empty? afile) '()]
    [else
     (cons (first-line afile)
           (file->list-of-lines (remove-first-line afile)))]))
             
; File -> Line
; afile の先頭から 最初の NEWLINE が現れるまでを取得する。
(define (first-line afile)
  (cond
    [(empty? afile) '()]
    [(string=? (first afile) NEWLINE) '()]
    [else (cons (first afile) (first-line (rest afile)))]))
             
; File -> File
; 最初のNEWLINEの前にあるafileのサフィックスを削除する。
(define (remove-first-line afile)
  (cond
    [(empty? afile) '()]
    [(string=? (first afile) NEWLINE) (rest afile)]
    [else (remove-first-line (rest afile))]))
 
(define NEWLINE "\n") ; the 1String 
             

    図 160:ファイルを行のリストに変換する


ここから、プログラムの残りの部分を作成するのは簡単です。file->list-of-lines では、最初の節の答は '() でなければなりません。なぜなら、空ファイルはどんな行も含まないからです。2番目の節の答は、(first-line afile) を (file->list-of-lines (remove-first-line afile))に consしなければならない。最後に、補助関数(remove-first-line)は構造的再帰的な方法で入力をたどります。その開発は簡単な練習問題です。図160はプログラムコード全体を示します。

以下は、file->list-of-linesが2回目のテストを処理する様子です。

    (file->list-of-lines
      (list "a" "b" "c" "\n" "d" "e" "\n" "f" "g" "h" "\n")))
    ==
    (cons
      (list "a" "b" "c")
      (cons (file->list-of-lines
              (list "d" "e" "\n" "f" "g" "h" "\n")) )
    ==
    (cons
      (list "a" "b" "c")
      (cons (list "d" "e"))
            (file->list-of-lines
              (list "f" "g" "h" "\n")))
    ==
    (cons (list "a" "b" "c"))
          (cons (list "d" "e"))
                (cons (list "f" "g" "h")
                      (file->list-of-lines '()))))
    ==
    (cons (list "a" "b" "c"))
          (cons (list "d" "e"))
                (cons (list "f" "g" "h"))
                      '())))

この評価は、file->list-of-linesの再帰的適用の引数が、与えられたファイルの残りの部分ではほぼないことを思い出させるものです。また、この生成的再帰が与えられたファイルすべてに対して終了することが保証されている理由も示しています。すべての再帰的アプリケーションは与えられたリストより短いリストを消費します。つまり、再帰のプロセスが'()に到達したときに再帰的プロセスは停止します。


練習問題452
first-line, remove-first-lineともに、目的の声明が的を外しています(？ 要修正)。適切な目的の声明を明確に述べてください。■


練習問題453
関数tokenizeを設計しなさい。これは行をトークンのリストに変換します。ここで、トークンとは1Stringか、小文字のみからなるStringのどちらかである。つまり、ホワイトスペースの1Stringはすべて削除されます。他の文字以外のものはそのまま残ります。連続する文字はすべて"word"にまとめられます。 ヒント string-whitespace? 関数について調査してみてください。■


練習問題454
create-matrixを設計してください。この関数は、数 n と n^2 個の数のリストを消費します．この関数は、例えば n×nの行列を生成します．

(check-expect
  (create-matrix 2 (list 1 2 3 4))
  (list (list 1 2)
        (list 3 4)))

2つ目の例を作ってください。■



------------------------------------------------------

28  数学的な例

数学の問題解決には、生成的再帰を用いるものが多くあります。将来のプログラマーは2つの理由からそのような解法を知っておく必要があります。一つは、プログラミングのかなりの部分が、本質的に、このような数学的なアイデアをプログラムにすることだからです。もう一つは、そのような数学的な問題で練習することはしばしば アルゴリズムの設計にインスピレーションを与えるからである。この章ではそのような問題を3つ扱います。


=====

28.1 ニュートン法

バイナリサーチは、数学の関数の根を求める方法の一つをもたらしいます。同じセクションの演習でスケッチしたように、この方法は、表、ベクトル、配列から特定の値を見つけるような計算問題にも自然に一般化されます。数学的な応用では、プログラマは解析数学に由来する方法を採用する傾向があります。その代表的なものがニュートンによるものです。いわゆるニュートン法は、二項探索と同様に、根の近似値が十分に近くなるまで近似の改善を繰り返す方法です。r1から推測を始めると、プロセスのエッセンスは、r1でのfの接線方程式を作り、その根を決定します。その接線は関数を近似しますが、その根を求めるのも簡単です。この処理を十分な回数繰り返すことで、アルゴリズムは（f r）が十分に0に近い根rを見つけることができます。

このプロセスは、接線に関する2つの知識、すなわち傾きと根に依存していることは明らかです。非公式には、ある点r1での接線は点(r1, f(r1))を通り、fと同じ傾きをもつ直線です。接線の傾きを求める数学的な方法の1つは、x軸上でr1から等距離の2点を選び、その2点でのfで決まる直線の傾きを用いることです。慣例として、小さな数εを選び、r1 + εとr1 - εで作業する。つまり、点は(r1 -ε, f(r1 -ε)) と (r1 +ε, f(r1 +ε)) であり、直線と傾きが決定されるのである。

    slope(f, r1) = (f(r1+ε)-f(r1-ε))/((r1+ε)-(r1-ε)) = 1/(2ε)(f(r1+ε)-f(r1-ε))

練習問題455
この数式を、関数 f と数 r1 を r1 での f の傾きに対応させる ISL+ 関数 slope に変換せよ。εはグローバルな定数であると仮定してください。例には水平線、一次関数、あるいは微積分を知っていれば多項式など、正確な傾きがわかる関数を使いましょう。■


2つ目の領域知識は、単なる直線や一次関数である接線の根に関するものです。接線は (r1, f(r1)) を通り、上のような傾きを持つ。数学的には次のように定義されます：

    tangent(x) = slope(f, r1) (x - r1) + f(r1)

接線の根を求めることは、tangent(root-of-tangent)が0になるような値root-of-tangentを求めることです。

    0 = slope(f, r1) (root-of-tangent - r1) + f(r1)

この方程式を素直に解けばよいです：

    root-of-tangent = r1 - (f(r1)/(slope(f, r1))

練習問題456
f と r1 を (r1,(f r1)) を通る接線の根に写す関数 root-of-tangent を設計してください。■


さて、Newton法のプロセスをISL+のプログラムに変換するために設計レシピを利用できます。この関数（発明者に敬意を表して newton と呼びましょう）は、関数 f と数 r1 を消費します。

    ; [Number -> Number] Number -> Number
    ; (f r)が小さくなるような数rを求める。
    ; generative は繰り返し改良された推測を生成する
    (define (newton f r1) 1.0)

関数newtonのテンプレートは生成的再帰の設計レシピの中心である4つの質問に目を向けています。

 1.  (f r1)が0に十分近ければ問題は解かれている。0に近いということは(f r1)が小さな正の数であるか、小さな負の数であるということです。そこで、その絶対値を調べます。

        (<= (abs (f r1))) A)

 2. 解はr1です。

 3. アルゴリズムの生成的なステップは、fの接線の根をr1で見つけることであり、これが次の推測値を生成します。f とこの新しい推測値に 関数newton を適用することで、処理を再開する。

 4. 再帰の答えは、元の問題の答えでもある。

  ; [Number -> Number] Number -> Number
  ; (<= (abs (f r)) A) となるような数rを求める。
  
  (check-within (newton poly 1) 2 ε)
  (check-within (newton poly 3.5) 4 ε)
  
  (define (newton f r1)
    (cond
      [(<= (abs (f r1)) ε) r1]
      [else (newton f (root-of-tangent f r1))]))
  
  ;練習問題455参照
  (define (slope f r) ...)
  
  ; 練習問題456参照
  (define (root-of-tangent f r) ...)

    図161:ニュートン法のプロセス

図161に関数newtonを示しました。これには、「27.2 バイナリーサーチ」の関数 find-rootのテストから派生した2つのテストが含まれています。結局のところ、どちらの関数も関数の根を探索し、polyは2つの既知の根を持っています。

                イメージ

    図162:区間[-1,5]上のpolyのグラフ。


関数newtonの設計はまだ終わっていません。設計レシピの7番目のステップでは、関数の終了動作を調査することが求められています。newtonの場合、問題はpolyのところで現れます。

    ; Number -> Number
    (define (poly x) (* (- x 2) (- x 4)))

前述のように、その根は2と4です。図162のpolyのグラフではこれらの根を確認でき、また、2つの根の間で関数が平坦になることが分かります。数学の好きな人にとっては、この形状は、関数newtonが最初の推測値3に対してどのような計算をするのか、という疑問を抱かせます。

  > (poly 3)
  -1
  > (newton poly 3)
  /:division by zero

説明としては、関数 slopeは「悪い」値を生成し、root-of-tangent関数はそれをエラーに変えてしまうというものです。

  > (slope poly 3)
  0
  > (root-of-tangent poly 3)
  /:division by zero

この実行時エラーに加え、関数newtonは終端に関して2つの問題を示している。幸いなことに、この2つはpolyで実証することができます。最初の問題は、「1.1 数の算術」で簡単に触れた数の性質に関するものです。このプログラミングの初歩的な練習問題では、正確な数と不正確な数の区別を無視しても大丈夫です。しかし、数学をプログラムに変換するときには細心の注意を払って進めなければなりません。次のようなことを考えてみてください。

    > (newton poly 2.9999)

ISL+プログラムは2.9999を正確な数として扱い、newtonの計算もそのように処理しますが、数が整数でないため、計算には正確な有理数分数が使用されます。分数の演算は不正確な数の演算よりもずっと遅くなることがあるので、上記の関数呼び出しはDrRacketではかなりの時間を要します。お使いのコンピュータにもよりますが、数秒から1分以上かかるかもしれません。たまたまこの形式の計算をトリガーする他の数字を選んだ場合、newtonの呼び出しが全く終了しないかのように見えるかもしれません。

2つ目の問題は、プログラムの非終了に関するものです。以下はその例です。

    > (newton poly #i3.0)

これは初期値として不正確な数#i3.0を使用しますが、3とは異なり別の種類の問題が発生します。具体的には、関数slopeが関数polyに対して不正確な0を生成し、root-of-tangentが無限大にジャンプするようになった。

  > (slope poly #i3.0)
  #i0.0
  > (root-of-tangent poly #i3.0)
  #i+inf.0

(newtonの計算では #i+inf.0 が +nan.0 に変換されます。これは「数字ではない」というデータです。ほとんどの算術演算でこの値が伝搬してしまいます。この値はnewtonの挙動を説明します)

つまりnewtonは、複雑な終了動作に関して、あらゆる種類の問題を示しています。ある入力に対して、この関数は正しい結果を出します。ある入力に対してはこの関数はエラーを通知します。また、無限ループに陥ったり、無限ループに陥ったように見えるものもあります。newtonのヘッダーやnewtonに関するその他のメモは、その関数を使おうとする人や将来の読者にこれらの複雑さを警告しなければなりません。一般的なプログラミング言語における優れた数学ライブラリはそうしています。


練習問題457
関数double-amountを設計しなさい。この関数は、預金口座に利子が月ごとに固定金利で支払われる場合、与えられた金額が2倍になるのに何ヶ月かかるか計算します(この演習はAdrian Germanによって提案されたものです)。

ドメイン知識(Domain Knowledge): ちょっとした代数的操作で、与えられた金額は無関係であることを示すことができます。重要なのは金利だけです。また、金利rが「小さい」限り、およそ72/r月後に2倍になることを、ドメインの専門家は知っています。


=====

28.2 数値積分

物理の問題の多くは、曲線の下の面積を求めることに帰着する。

    例題 ある自動車が秒速 v メートルで一定速度で走っている。5秒、10秒、15秒の間にどれくらいの距離を走るだろうか？

    あるロケットが一定の加速度 12 m/s^2で飛び出した。5秒、10秒、15秒後に何メートルの高さに到達するか？

物理学では、自動車が一定の速度vでt秒間移動した場合、その移動距離はd(t)=v t メートルであるとされています。加速する乗り物の場合、移動距離は経過時間tの2乗に依存する。

    d_acc(t) = 1/2 a t^2

一般にこの法則では距離は時間tに対する速度v(t)のグラフの下の面積に対応することが分かります。

                イメージ画像

    図163:一定速度での走行距離と加速度での走行距離

図163は、この考え方を図式化したものです。左は2つのグラフを重ね合わせたもので、実線の平線が車の速度、上昇する破線が移動距離です。確認すると、後者は確かにすべての時点において前者とx軸で決まる面積であることがわかる。同様に、右は一定の加速度で速度を上げながら移動するロケットと、その到達する高さの関係を示しています。このように、ある区間の関数のグラフの下の面積を求めることを、（関数の）積分と呼びます。

数学者は2つのサンプル問題については正確な答えを与える公式を知っているが、一般的な問題では計算による解答が必要です。問題は、曲線はしばしば図164のグラフよりももっと複雑な形状をしていて、x軸、a、bと書かれた縦線、fのグラフの間の面積を知る必要があることです。応用数学者は、多くの小さな幾何的な形の面積を合計して、近似的にその面積を求めます。したがって、このような計算を扱うアルゴリズムを開発することは自然なことです。

            イメージ

    図164:aとbの間で関数fを積分する

積分アルゴリズムは3つの入力、すなわち関数fと2つの境界線、aとbを消費します。4番目のx軸は暗示的です。これは次のようなシグネチャーを示唆します：

        ; [Number -> Number] Number Number -> Number

積分の背景にある考え方を理解するためには、定数関数や一次関数のような簡単な例題を勉強するのが一番です。そこで、次のように考えてみましょう。

    (define (constant x) 20)

定数を12, 22とともに関数integrateに渡すと、幅10、高さ20の長方形が記述される。この長方形の面積は200であり、次のテストが得られることを意味します：

    (check-expect (integrate constant 12 22) 200)

同様に、linearを使って2つ目のテストを作成しましょう。

    (define (linear x) (* 2 x))

linear, 0, 10を関数integrateで使うと、面積は底辺の幅が10、高さが20の三角形になる。以下はテストとしての例題です。

    (check-expect (integrate linear 0 10) 100)

三角形の面積は、底辺の長さと高さの積の半分です。

3つ目の例として、ある分野固有の知識を利用する。前述のように、数学者はある関数の下での面積を正確に決定する方法を知っています。例えば、区間 [a, b]間で、関数

    square(x) = 3 x^2

の下の面積は、次の式

    b^3 - a^3

で計算できます。

このアイデアを具体的なテストにつなげる方法を紹介します。

    (define (square x) (* 3 (sqr x)))
     
    (check-expect (integrate square 0 10))
                  (- (expt 10 3) (expt 0 3)))


 --
    (define ε 0.1)
    
    ; [Number -> Number] Number Number -> Number
    ; aとbの間のfのグラフの下の面積を計算する。
    ; (< a b) が成り立つと仮定する。
    
    (check-within (integrate (lambda (x) 20) 12 22) 200 ε)
    (check-within (integrate (lambda (x) (* 2 x)) 0 10) 100 ε)
    (check-within (integrate (lambda (x) (* 3 (sqr x))) 0 10)
                  1000
                  ε)
         
    (define (integrate f a b) #i0.0)


    図 165:一般的な積分関数
 --


図165は、設計レシピの最初の3つのステップの結果を集めたものです。この図には、目的の声明と、区間の2つの境界値に関する明白な仮定が追加されています。check-expectの代わりにcheck-withinを使用して、このような計算の近似に伴う数値の不正確さを想定しています。同様に、integrateのヘッダーには戻り値として#i0.0が指定されており、この関数が不正確な数値を返すことが予想されることを告げています。

次の2つの演習では、ドメイン知識を積分の関数に変換する方法を紹介します。どちらの関数も、かなり粗い近似値を計算します。最初の関数は数式だけを使っていますが、2番目の関数は構造的再帰の設計のアイデアも少し使っています。これらの問題を解くことで、本節の核となる生成的-再帰的統合アルゴリズムに必要な理解が得られる。

練習問題458
ケプラーは簡単な積分法を提案しました。a と b の間の f の下の面積の推定値を計算するために、次のように進めます（この方法はケプラーのルール（Kepler's rule)として知られています）。

 1. mid = (a + b) / 2 で区間を半分に分割します；

 2. 次の2つの台形の面積を計算します：

        [(a,0),(a,f(a)),(mid,0),(mid,f(mid))]．

        [(mid,0),(mid,f(mid)),(b,0),(b,f(b))];

 3. 2つの領域の面積を合計します。

ドメイン知識： これらの台形を見てみましょう。ここでは、2つの可能性のある形を、混乱を避けるために最小限の注釈を付けて示しています：

    イメージ画像

左の図形は f(L) > f(R) の場合、右は f(L) < f(R) の場合です。このように非対称ではありますが、これらの台形の面積は一つの公式で計算することが可能です。

    [(R - L)・f(R)] + [(1/2)・(R - L)・(f(L) - f(R))]

ここでストップしてください。この式は、左の台形は(上の)三角形の面積を下の長方形の面積に足していて、右の台形は三角形を大きな長方形の面積から引いているということを理解してください。

また、上の式が次の式に等しいことを示します。

    (1/2)・(R - L)・(f(L) + f(R))

これは、数式が非対称であることを数学的に検証したものです。

関数integrate-keplerを設計してください。つまり、数学的知識をISL+関数にします。図165のテストケースをこの関数に適応させなさい。3つのテストのうちどれがどの程度失敗しますか？■


練習問題459
もう一つの簡単な積分法では、面積を多くの小さな長方形に分割します。各長方形の幅は一定で、高さは長方形の中央にある関数のグラフと同じ高さとします。各長方形の面積を足し上げると、関数のグラフの下の面積が推定されます。

以下の値を使ってください：

    R = 10

は、考慮すべき長方形の数を表します。したがって、各長方形の幅は

    W = (b - a) / R

となります。

これらの長方形の1つの高さは、その中点でのfの値です。(左から)最初の中点は、明らかにaに長方形の幅の半分 (S = W / 2)を足したところにあります。長方形の面積は以下であることになります：

    W・f(a + S)

2つ目の長方形の面積を計算するには、最初の中点に長方形の幅を足す必要があります：

    W・f(a + W + S)

3つ目(の長方形の面積を計算するに)は、次のようになります：

    W・f(a + 2・W + S)

一般に、i番目の長方形については、以下の式を用いることができます：

    W・f(a + i・W + S)

最初の長方形はインデックスは0で、最後の長方形のインデックスは(R - 1)です。

これらの長方形を使って、今度はグラフの下の面積を求めます。

    Σ W・f(a + i・W + S) = W・f(a + 0・W + S)
                            +
                            ...
                            +
                            W・f(a + (R - 1)・W + S)

この処理の記述を ISL+ 関数に変換し、integrate-rectangles とします。図165のテストケースをこのケースに適応させてください。

アルゴリズムがより多くの長方形を使用すればするほど、その推定値は実際の面積に近くなります。アルゴリズムの精度がε=0.1で問題がなくなるまで、Rをトップレベルの定数とし、10倍ずつ増やしてみてください。

Aを0.01に減らし、Rを十分に増やして、失敗するテストケースを再度排除してください。その結果を練習問題458と比較してください。■


練習問題458のケプラー法は、"27.2 バイナリサーチ"で紹介したバイナリサーチのような分割統治戦略をすぐに思い浮かべることができます。大雑把に言えば、そのアルゴリズムは区間を2つに分割し、それぞれの面積を再帰的に計算し、その2つの結果を足すというものです。


練習問題460
関数 f を境界 a と b の間で分割統治戦略を用いて積分するアルゴリズム integrate-dc を開発しなさい。区間が十分小さい場合はケプラー法を用いなさい。■


練習問題460の分割統治は無駄が多い。グラフがある部分では水平で、別の部分では急激に変化する関数を考えてみます。その具体的な例としては図166を参照してください。グラフが水平な部分については、区間を分割し続けることは無意味です。左半分の区間の面積を計算するのは（左区間全体の台形の面積を計算するのと同じくらい??）簡単です。しかし、"波状の(wavy)"部分については、グラフの不規則性が適度に小さくなるまで、区間を分割し続けなければならない。


      グラフのため省略

    図166:適応型統合の候補


fが水平であることを発見するために、アルゴリズムを次のように変更することができます。区間がどれだけ大きいかを調べる代わりに、新しいアルゴリズムでは3つの台形の面積を計算します：与えられた台形とそれを半分に分けた2つの台形です。もし、与えられた台形と、それを2つに分けたときの面積の合計の差が高さε、幅 (b - a)の小さな長方形の面積 ε・(b - a)より小さければ、全体の面積は良い近似値であると判断してよいです。言い換えれば、アルゴリズムは、fが許容誤差に影響するほど大きく変化するかどうかを判断します。そうであれば分割統治戦略のアプローチを継続し、そうでなければ停止してケプラーの近似を使用します。

練習問題461
integrate-adaptiveを設計してください。つまり、上記の再帰的プロセスの記述を ISL+ アルゴリズムに変えてください。図165のテストケースをそのテストに適応させるようにしてください。

integrate-adaptiveの停止は検討しないでください。

integrate-adaptive は integrate-kepler や integrate-rectangles よりもよい答を常に計算するのでしょうか？ integrate-adaptiveはどの点を改善することが保証されていますか？■


用語の解説 このアルゴリズムは、グラフの必要な部分に自動的に時間を割り当て、その他の部分にはほとんど時間をかけないことから、適応的積分と呼ばれています。具体的には、f のうち水平な部分にはわずかな計算を行い、それ以外の部分には許容誤差を少なくするために小さい間隔で検査します。コンピュータサイエンスは多くの適応的アルゴリズムを含みますが、integrate-adaptiveはその一つに過ぎません。



=====

28.3 プロジェクト：ガウス消去

数学者は1変数の方程式の解を探すだけでなく、連立方程式も研究しています：

    サンプルの問題: 物々交換の世界において、石炭の価値（x）、石油の価値（y）、ガスの価値（z）は、以下の交換の式で決定されます：

      2・x + 2・y +  3・z = 10 
      2・x + 5・y + 12・z = 31     (†)
      4・x + 1・y -  2・z = 1  


このような連立方程式の解は、数の集まりを構成します。これは変数ごとに1つの数となります。変数を対応する数に置き換えると、各方程式の両辺は同じ数に評価されます。この例では、解は以下となります。

    x = 1, y = 1, z = 2

この主張は簡単に確認することができます。

      2・1 + 2・1 +  3・2 = 10 
      2・1 + 5・1 + 12・2 = 31 
      4・1 + 1・1 -  2・2 = 1  

この3つの方程式は次のようになります。

    10＝10, 31＝31, 1＝1

 --
  ; SOEは空でないMatrixである。
  ; 制約条件: (list r_1 ... r_n)で、 (length r_i) は (+ n 1)である。
  ; 解釈: 連立一次方程式を表す。
  
  ;( 10.3 の演習問題 176より。
  ; Matrix は以下のうちのどれかになります：
  ;  - (cons Row '())
  ;  - (cons Row Matrix)
  ; 制約条件: matrixのすべての行は同じ(リストの)長さを持ちます。)

  ; Equation は [List-of-Number]である。
  ; 制約条件: 方程式は少なくとも2つの数を含む。
  ; 解釈: (list a_1 ... a_n b) が Equationであれば
  ;       a_1, ..., a_n は左辺の変数の係数である。
  ;       そしてbは右辺である。

  ; Solution は [List-of Number] です。

  (define M ; an SOE 
    (list (list 2 2  3 10) ; an Equation 
          (list 2 5 12 31)
          (list 4 1 -2  1)))
  
  (define S '(1 1 2)) ; a Solution
  
     図167:連立方程式のデータ表現
 --


図167は、我々の問題領域のデータ表現を紹介するものです。これには、連立方程式とその解の例が含まれています。この表現は、連立方程式の本質を捉えています：すなわち左辺の変数の係数と、右辺の値です。変数名は関数のパラメータと同じようなものであるため特に重要な役割を演じるわけではありません。つまり、一貫して変数名を変更すれば同じ解が得られます。

本節以降では、これらの関数を使用するのが便利である。

  ; Equation -> [List-of Number]
  ; 行列の行から左辺(の式に相当するもの)を取り出す
  (check-expect (lhs (first M)) '(2 2 3))
  (define (lhs e)
    (reverse (rest (reverse e))))
   
  ; Equation -> Number
  ; 行列の行から右辺(の数)を取り出す
  (check-expect (rhs (first M)) 10)
  (define (rhs e)
    (first (reverse e)))


練習問題462
関数 check-solution を設計しなさい。この関数は SOE と Solution を消費する。これは、SOE の方程式の変数に Solution からの数値を代入すると左辺の値と右辺の値が等しくなる場合は #true となります。そうでない場合は #false となります。check-satisfied を使ったテストを作成するには check-solution を使用します。

ヒント 最初に関数 plug-in を設計しましょう。この関数はEquationの左辺とSolustionを消費します。解を変数に代入すると左辺からその値が計算されます。■


ガウスの消去法は、連立方程式の解を求めるための標準的な方法です。これは2つのステップからなります。最初のステップは、連立方程式を、形は違うが同じ解を持つ連立方程式に変換することです。第二のステップは、一度に一つの方程式の解を見つけることです。ここでは、生成的再帰のもう一つの興味深い例である第一のステップに焦点を当てます。

ガウスの消去法の最初のステップは、結果が三角形の形をした連立方程式になることから、「三角形分割」と呼ばれています。これに対して、元の連立方程式は長方形です。この用語を理解するために、元の連立方程式を表す次のリストを見てください。

    (list (list 2 2  3 10)
          (list 2 5 12 31)   (1)
          (list 4 1 -2  1))

三角測量により、この行列は以下のように変換される。

    (list (list 2 2 3 10)
          (list   3 9 21)
          (list     1  2))

約束されたように、この連立方程式の形は（おおよそ）三角形です。


練習問題463
次の連立方程式

     2・x + 2・y + 3・z = 10 
            3・y + 9・z = 21     (*)
                   1・z =  2 

は、(†)でラベル付けされた連立方程式と同じ解をもつことを確認してください。練習問題462のcheck-solutionを使って解くのと、手書きでも行ってみてください。■


三角化の重要なアイデアは、最初の方程式を残りの方程式から引くことです。ある方程式を別の方程式から引くということは、2つの方程式の対応する係数を引くということである。上記の例(1)では、2番目の方程式から1番目の方程式を引くと、次のような行列になります:

    (list (list 2 2  3 10)
          (list 0 3  9 21)
          (list 4 1 -2 1))

これらの引き算の目的は、最初の式を除くすべての式の1列目に0を入れることである。3番目の方程式に関しては、0を最初の位置に入れるということは、3番目の方程式から1番目の方程式を2回引くということです。

    (list (list 2 2 3 10)
          (list 0 3 9 21)
          (list 0 -3 -8 -19))

慣例に従って、上記の最後の2つの式から先頭の0をリストから削除します:

    (list (list 2  2  3  10)
          (list    3  9  21)
          (list   -3 -8 -19))

つまり、最初の行のすべての要素に2をかけて、それを最後の行から引くのです。前述したように、この引き算は連立方程式の解を変えません。つまり、元の連立方程式の解は変換後の連立方程式の解でもあるのです。


練習問題464
次の連立方程式が(†)の連立方程式と同じ解を持つことを確認してください。

    2・x + 2・y + 3・z =  10 
           3・y + 9・z =  21  (‡)
         - 3・y - 8・z = -19 

は、(イメージ)と書かれた解答と同じです。ここでも練習問題462のcheck-solutionを使って解くのと、手書きの計算でも解いてみてください。■



練習問題465
subtractを設計してください。この関数は、同じ長さの 2つの方程式を使用します。この関数は、 2 番目の方程式から 最初の方程式を複数回"減算"し、結果として得られる方程式の最初の係数が 0 となるようにします。先頭の係数は 0 であることが分かっているので、subtract は引き算の結果得られたリストの残りを返します。■


では上記 SOEの残りを考えてみましょう。

    (list (list  3  9  21)
          (list -3 -8 -19))

これはSOEでもあるので、同じアルゴリズムを再び適用できます。この実行例では、次の減算ステップでは2番目の方程式から最初の方程式の(-1)倍を減算する必要があります。そうすると次のようになります。

    (list (list 3 9 21))
          (list   1  2))

このSOEの残りは1つの方程式であり、簡略化することはできません。


練習問題466
以下は三角形のSOEの表現です。

    ; TMは、[Equation]の長さが減少するような [NEList-of Equation]である。
    ; (例. Equationの長さが) n + 1, n, n - 1, ..., 2
    ; 解釈: 三角行列を表す。

triangulate アルゴリズムを設計しましょう。

    ; SOE -> TM
    ; 与えられた連立方程式を三角化する。
    (define (triangulate M)
      '(1 2))

上記の例をテストに置き換えて、(26.1 「設計レシピの適用」の)4つの問いに対する明確な答をこれまでの緩やかな説明に基づいて記述してください。

デザインレシピの終了ステップはまだ扱わないでください。■


残念ながら、練習問題466の解答では、望ましい三角形の連立方程式を作れないことがあります。次のような連立方程式の表現を考えてみよしょう。

    (list (list 2  3  3 8)
          (list 2  3 -2 3)
          (list 4 -2  2 4))

この連立方程式の解は x＝1, y＝1, z＝1 です。

まず、2行目から1行目を引き、3行目から1行目を2回引くと、次のような行列になります。

    (list (list 2  3  3   8)
          (list    0 -5  -5)
          (list   -8 -4 -12))

次に、三角測量はマトリックスの残りの部分に焦点を当てることになる。

    (list (list 0 -5 -5))
          (list -8 -4 -12))

0で割ることはできないので、アルゴリズムはsubtract経由でエラーを通知します。

この問題を解決するためには、問題領域から得られる別の知識を利用する必要があります。数学では、連立方程式の中の2つの方程式を入れ替えても解に影響がないことが分かっています。もちろん、方程式を入れ替えるとき、最終的には先頭の係数が0でない方程式を見つけなければなりません。ここでは、最初の2つを入れ替えればよいです。

    (list (list -8 -4 -12))
          (list  0 -5  -5))

ここからは、先ほどと同じように、残りの1つの式から最初の式を0回引くことができます。最終的な三角行列は

    (list (list  2  3  3   8)
          (list    -8 -4 -12)
          (list       -5  -5))

ストップ！ x = 1, y = 1, z = 1 がこれらの方程式の解であることを示してください。


練習問題467
演習 466 の triangulate を修正し、残りの方程式から最初の方程式を引く前に、まず方程式を回転させて(入れ替えて?)先頭の係数が 0 でないものを見つけるようにしなさい。

このアルゴリズムは、すべての可能な連立方程式に対して終了するのか？

ヒント 次の式は空でないリストLを回転させます。

    (append (rest L) (list (first L)))

その理由を説明してください。■


解決策を持たない連立方程式もあります。次を考えてみてください。

    2・x + 2・y + 2・z = 6
    2・x + 2・y + 4・z = 8
    2・x + 2・y + 1・z = 2

この連立方程式を手書きあるいは練習問題467で解いた方法で三角形化しようとすると、すべての方程式が0から始まる中間行列になります。

    0・x + 0・y + 2・z = 6
    0・x + 0・y - 1・z = 0


練習問題468
練習問題467の triangulate を修正し、先頭の係数がすべて0の連立方程式に到達した場合、エラーを通知するようにしなさい。■


練習問題463の(*)のような三角の連立方程式を得たら、それを一つずつ解いていくことができます。この例題では、最後の式でzが2であることがわかるので、代入によって2番目の式からzを消すことができる。

    3・y + 9・2 = 21

そうすることで、今度はyの値が決まる。

    y = (21 - 9・2) / 3

z = 2 と y = 1 が得られたので、これらの値を最初の方程式に代入することができます。

    2・x + 2・1 + 3・2 = 10

すると、もう一つの1変数の方程式が得られるので、これを次のように解きます。

    x = (10 - (2・1 + 3・2)) / 2

これにより、最終的にxの値が得られ、連立方程式の全体の完全な解が得られます。


練習問題469
solve 関数を設計してください。これは三角形の連立方程式を引数として解を返します。

ヒント 設計には構造的再帰を使用します。最後のn個の変数の解が与えられたときに、n+1個の変数で1つの連立方程式を解く関数の設計から始めましょう。一般に、この関数は左辺の残りの値を差し込み、右辺からその結果を引き、最初の係数で割る。この提案と上記の例題で実験してみてください。

課題 既存の抽象化とラムダを使って、解決策を設計する。■


練習問題470
練習問題468のtriangulate関数と練習問題469のsolve関数を組み合わせたgaussを定義してください。■



------------------------------------------------------

29 バックトラックを行うアルゴリズム

問題解決は常に一直線に進むわけではありません。ある方法をとっても、道を間違えて行き詰まってしまうことがあります。そのような場合、最初に決めた場所まで戻って、別の道を歩けばよいのです。アルゴリズムにはそのようにはたらくものがあります。この章では2つの例を紹介します。最初のセクションはグラフをトラバースするアルゴリズムを扱います。もう1つは、チェスのパズルの文脈でバックトラックを使う拡張された演習です。


=====

29.1 グラフのトラバース

グラフは、私たちの世界やコンピューティングの世界ではどこにでもあるものです。人のグループ、例えば学校の生徒を想像してください。すべての人の名前を書き出し、互いに知っている人たちの名前をつなげます。これで、最初の無向グラフができあがりました。

さて、図168をみてください。これは小さな有向グラフです。7つのノード（丸で囲んだ文字）と9つのエッジ（矢印）で構成されています。このグラフは、電子メールネットワークの小型版を表しているのかもしれません。ある会社と、その会社と行き来するすべての電子メールを想像してください。全従業員の電子メールアドレスを書き出してください。そして、そのアドレスから、オーナーが一週間のうちにメールを送るすべてのアドレスへ、アドレスごとにエッジを描きます。このようにして、図168の有向グラフを作成するのですが、最終的にはもっと複雑で、ほとんど理解不能なものになってしまうかもしれません。

                イメージ

    図168 有向グラフ

一般に、グラフはノードの集まりと、ノード間を結ぶエッジの集まりから構成される。有向グラフでは、エッジはノード間の一方向のつながりを表し、無向グラフでは、エッジはノード間の双方向のつながりを表します。この文脈で、以下は問題の一般的なタイプです：

(社会科学者は、このようなアルゴリズムを用いて、企業内の権力構造を把握する。同様に、彼らは電子メールの内容を知らなくても、このようなグラフを使用して、人々の起こりうる行動を予測することができます。)

    サンプル問題 大企業の有向グラフの中で、ある人を別の人に紹介する方法を提案するアルゴリズムを設計しなさい。このプログラムは、確立された電子メール接続と2つの電子メールアドレスを表す有向グラフを引数とします。そして、最初の電子メールアドレスと2番目の電子メールアドレスを接続する電子メールアドレスの列を返します。

数理科学者は、この望ましい配列を「道またはパス」と呼んでいる。

図168は、このサンプル問題を具体化したものです。例えば、プログラムはCからDへの経路が見つけられるかどうかをテストしたいかもしれません。その経路は始点ノードCと終点ノードDから構成されます。一方、あなたがノードEとDをつなぎたい場合、以下の2つのパスがあります：

  ・EからFにメールを送り、そしてDに送る。

  ・EからCにメールを送り、そしてDに送る。

2つのノードをパスで結ぶことができない場合もある。図168のグラフではエッジをたどってもCからGに移動することはできません。

図168を見ると、あるノードから別のノードへの移動方法はあまり考えなくても簡単にわかると思います。そこで、少しの間、図168のグラフが大きな公園であると想像してみましょう。また、あなたはEに位置していて、Gに行く必要があることをだれかから聞いたとしましょう。このとき、C に続くパスと F に続くパスがあることがはっきり見えます。最初のパスを辿り、EからFにたどることも可能なことを必ず覚えていてください。鍵となる洞察はこの新しい問題はもともとの問題とほぼ同じであることです；あなたはあるノードから別のノードにつながるパスを見つける必要があるという問題です。さらに、この問題が解ければ、EからGに行く方法がわかります。しかし、CからGに行く道はありません。幸い、EからFに行くことが可能であることをあなたは覚えています。それはつまり、選択ができるある地点まで戻って(バックトラックして）、そこから探索を再開することができるということを意味しています。

さて、このアルゴリズムを体系的なやり方で設計してみしょう。一般的な設計のレシピに従って、データ分析から始めます。ここでは、図168のグラフをリストでコンパクトに表現したものを2つ紹介します。

    (define sample-graph
      '((A (B E))
        (B (E F))
        (C (D))
        (D ())
        (E (C F))
        (F (D G))
        (G ())))
        
    	
    (define sample-graph
      '((A B E)
        (B E F)
        (C D)
        (D)
        (E C F)
        (F D G)
        (G)))

どちらも1つのノードにつき1つのリストを含む。これらのリストはそれぞれ、ノードの名前から始まり、次にその(直近の)隣接ノード、 つまり1本のエッジをたどることで到達可能なノードが続きます。この2つは、ノード（の名前）とその近傍をどのように接続するかが異なっています。つまり、1つめはリストを、2つめはconsを使用しています。例えば、図168のノードBと、BからEとFに出る2本のエッジを2番目のリストで表しています。1つめでは 'B は2要素リストの最初の名前であり、2個目では3要素リストの最初の名前です。


練習問題471
上記の定義の1つを、リストと適切なシンボルを使って、真正なリスト形式に変換せよ。(訳注. nil で終端された構造を真正なリスト(proper list)と呼びます)

ノードのデータ表現は単純です。

   ; Node は Symbol です。

任意の数のノードとエッジを許容する、全てのGraphの表現のクラスを記述するデータ定義を定式化してください。上記の表現のうち、1つだけがGraphに属していなければならない。

関数 neighbors を設計しなさい。この関数は、ノード n と Graph g を受け取り、g における n の直近のノードのリストを生成します。■


NodeとGraphのデータ定義を使って ―上述のグラフの表現方法のどちらを選ぶにせよ、関数neighborsを設計しさえすれば―グラフ内のパスを検索する関数find-pathのシグネチャと目的の声明を作成することができます。

    ;  Node Node Graph -> [List-of Node]
    ; Gにおいて始点ノードから終点ノードまでのパスを見つける。
    (define (find-path origination destination G))
      '())

このヘッダーが未解決のままにしているのは、結果の正確な形です。これは、結果がノードのリストであることを意味するが、どちらのノードが含まれるかは書いていません。

この曖昧さを理解し、なぜそれが重要なのかを理解するために、先ほどの例を調べてみましょう。ISL+では、次のように定式化することができます：

    (find-path 'C 'D sample-graph)
    (find-path 'E 'D sample-graph)
    (find-path 'C 'G sample-graph)

find-pathの最初の呼び出しはユニークなパスを返し、2つ目の呼び出しは2つのパスから1つを選び、3つ目の呼び出しはsample-graphに'Cから'Gへのパスが存在しないことを知らせる必要があります。ここで、戻り値をどのように構築するかについて2つの可能性があります：

 ・この関数の結果は、始点ノードから終点ノードに至る、この始点ノードと終点ノードを含むすべてのノードから構成されます。この場合、2つのノード間に経路がないことを表現するために、空のパスを用いることができます。

(与えられた2つのノードのどちらかをスキップするような他の方法も容易に想像できます)

 ・あるいは、呼び出し自体がすでに2つのノードをリストアップしているので、 出力はパスの「内部」のノードのみを示すことができます。その場合、最初の呼び出しに対する答えは「'()」となります。なぜなら、 「D」は「C」のすぐ隣のノードだからです。この場合はもちろん '()はもはや失敗のシグナルではないです。

パスがないことの問題については、この概念を示すために明確な値を選択する必要があります。なぜなら、#falseは明確で、意味があり、どちらの場合にも機能するからです。複数のパスの問題について決定するのは今のところは先延ばしにして、例のセクションで両方の可能性をリストアップしています。

    ; Path は [List-of-Node] である。
    ; 解釈: 
    ; ノードのリストは、リストの最初のノードから最後のノードに至る直接隣接するノードの列を指定する。
     
    ; Node Node Graph -> [Maybe Path]
    ; Gの中の始点ノードから終点ノードまでのパスを求める。
    ; もしパスがなければ、#false を返す。
     
    (check-expect (find-path 'C 'D sample-graph)
                  '(C D))
    (check-member-of (find-path 'E 'D sample-graph)
                     '(E F D) '(E C D))
    (check-expect (find-path 'C 'G sample-graph))
                  #false)
     
    (define (find-path origination destination G)
      #false)


次の設計ステップは、「自明な問題」の条件、マッチする解、新しい問題の生成、および組み合わせのステップという、関数の4つの重要な部分を理解することです。上記の探索プロセスの議論と3つの例の分析が答を示唆します。

 ・1. 与えられた2つのノードが与えられたグラフにおいて直接エッジで結ばれている場合、パスはこの2つのノードだけから構成されます。しかし、もっと単純なケースもあります。すなわち、find-path の引数である origination が destination と等しいときです。

 ・2. 2番目のケースでは、問題は本当に自明なことで、マッチする解は (list destination) です。

 ・3. 引数が異なる場合、アルゴリズムは origination の直近のノードをすべて調べ、そのうちの1つから destination へのパスがあるかどうかを判断しなければなりません。言い換えれば、直近のノードの1つを選ぶと、「パスを見つける」問題の新しいインスタンスが生成されます。

 ・4. 最後に、アルゴリズムがoriginationの隣接ノードからdestinationまでのパスを得ると、前者から後者への完全な経路を構築するのは簡単です。destination ノードをリストに追加するだけです。

プログラミングの観点からは、3番目の点が重要です。ノードは任意の数の隣接ノードを持つことができるため、単一のプリミティブでは「すべての隣接ノードを検査する」タスクは複雑すぎます。そこで、ノードのリストを消費し、それぞれのノードに対して新しいパスの問題を生成する補助関数が必要になります。別の言い方をすれば、この関数は find-path のリスト指向バージョンです。

この補助関数をfind-path/listと呼び、それに対するウィッシュを作ってみましょう。

  ; [List-of Node] Node Graph -> [Maybe Path]
  ; lo-originations にあるノードから目的地のノードまでのパスを見つける。
  ; みつけられなければ、#false を返す。
  (define (find-path/list lo-originations destination G)
    #false)

このウィッシュを使って、生成-再帰関数の汎用テンプレートを書き込めば、find-pathの最初のドラフトができあがります。

  (define (find-path origination destination G)
    (cond
      [(symbol=? origination destination)
       (list destination)]
      [else
       (... origination ...
        ...(find-path/list (neighbors origination G)
                         destination G) ...)]))

練習問題471のneighorsとウィッシュリストの関数find-path/listを使い、それ以外は生成的再帰関数に関する4つの質問の答を使います。

残りの設計作業は、これらの関数を適切に構成するための詳細についてです。find-path/listのシグネチャを考えてみましょう。find-pathのように、これは[Maybe Path]を生成します。つまり、もし近傍からパスが見つかれば、そのパスを生成します．そうでなければ、もし隣接ノードのどれもが目的ノードに接続していなければ、この関数は #false を生成します．したがって、find-pathの答はfind-path/listが生成する結果の種類に依存し、コードは2つの可能な答をcond式で区別しなければなりません。

  (define (find-path origination destination G)
    (cond
      [(symbol=? origination destination)
       (list destination)]
      [else
       (local ((define next (neighbors origination G))
               (define candidate
                 (find-path/list next destination G)))
         (cond
           [(boolean? candidate) ...]
           [(cons? candidate) ...]))]))

この2つのケースは、受け取るかもしれない2種類の答、つまり、ブール値かリストかを反映しています。最初のケースでは、find-path/listは隣接ノードからdestinationへのパスを見つけることができず、それはfind-path自身もそのようなパスを構築することができないことを意味します。2番目のケースでは、補助関数はパスを見つけます。しかし candidateは origination自身ではなく、上でみられように originationの隣接ノードの1つから始まるため、find-pathはこのパスの先頭にoriginationを追加する必要があります。

  ; Node Node Graph -> [Maybe Path]
  ; Gの中の origination から destination までのパスを求める。
  ; パスがない場合は#falseを返す。
  (define (find-path origination destination G)
    (cond
      [(symbol=? origination destination) (list destination)]
      [else (local ((define next (neighbors origination G))
                    (define candidate
                      (find-path/list next destination G)))
              (cond
                [(boolean? candidate) #false]
                [else (cons origination candidate)]))]))

  ; [List-of Node] Node Graph -> [Maybe Path]
  ; lo-Os上のあるノードからDへのパスを見つける。
  ; もしパスがなければ、この関数は#falseを生成する。
  (define (find-path/list lo-Os D G)
    (cond
      [(empty? lo-Os) #false]
      [else (local ((define candidate
                      (find-path (first lo-Os) D G)))
              (cond
                [(boolean? candidate)
                 (find-path/list (rest lo-Os) D G)]
                [else candidate]))]))

    図173 グラフ内のパスを検索する


図173はfind-pathの完全な定義を含んでいます。また、構造的再帰によってその最初の引数を処理する find-path/list の定義も含まれています。リスト内の各ノードについて、find-path/listはパスをチェックするためにfind-pathを使用します。find-pathが本当にパスを生成した場合、そのパスが答となります。そうでなければ、find-path/listはバックトラックします。

Note Treesでは、構造的な世界でのバックトラックを論じています。特に良い例は、家系図から青い目の先祖を検索する関数です。この関数はノードに出会うと、まず家系図の一方の枝、たとえば父親を検索し、この検索で#falseが出たら、もう半分を検索します。グラフは木を一般化したものであるので、この関数と find-path を比較することは有益な練習です。Noteおわり

最後に、find-pathがすべての可能な入力に対して答を出すかどうかをチェックする必要があります。図172のグラフとその中の任意の2つのノードが与えられたとき、find-pathが常に何らかの答を出すことを確認するのは比較的簡単です。ストップ！ 次の練習問題を解いてから、その先を読んでください。

練習問題472
find-pathをテストしてください。この関数を使ってsample-graphにおける 'Aから 'Gへのパスをみつけてください。どのパスをみつけますか。それはなぜですか。

test-on-all-nodesを設計してください。この関数はグラフgを引数とし、任意のペアのノードの間にパスがあるかどうかを決定します。■


                イメージ

    図170:サイクルを持つ有向グラフ


しかし、他のグラフでは特定のノードのペアでfind-path は終了しないことがあります。図170のグラフを考えてみましょう。

ストップ! この図のグラフを表現するために、cyclic-graphを定義してください。

図168と比べると、この新しいグラフには、CからBへというエッジが追加されました。この一見小さな追加によって、あるノードから探索を始め、そして同じノードに戻ることができるようになりました。具体的には、B→E→Cと移動し、それからBに戻ることができます。実際、'B, 'D とこのグラフに find-path を適用するとき、手で評価すると停止しないことが確認されます。

    (find-path 'B 'D cyclic-graph)
    == ... (find-path 'B 'D cyclic-graph) ....
    == ... (find-path/list (list 'E 'F) 'D cyclic-graph) ...
    == ... (find-path 'E 'D cyclic-graph) ...
    == ... (find-path/list (list 'C 'F) 'D cyclic-graph) ....
    == ... (find-path 'C 'D cyclic-graph) ...
    == ... (find-path/list (list 'B 'D) 'D cyclic-graph) ...
    == ... (find-path 'B 'D cyclic-graph) ...

手で評価すると、find-path と find-path/list をあわせて7回適用した後、ISL+ は開始時と全く同じ式を評価しなければならないことがわかります。同じ入力はどの関数でも同じ評価を引き起こすので、find-pathはこれらの入力に対して終了しません。(このルールの例外は1つだけ知っている：random 関数です)

要約すると、(訳注: 関数の)終了の議論は次のようになります。あるグラフにサイクルがない場合、find-pathは与えられた入力に対してある出力を生成します。結局のところ、すべてのパスは有限の数のノードしか含むことができず、パスの数も有限です。したがってこの関数は、あるノードから始まるすべての解を網羅的に調べるか、あるいは、始点から終点のノードまでのパスを見つけます。しかし、グラフがサイクルを含む場合、つまり、あるノードからそれ自身に戻るパスがある場合、 find-path はある入力に対して結果を生成しないことがあります。

次の部では、このような問題に対処するプログラム設計技術を紹介します。特に、グラフのサイクルを扱うことができるfind-pathの変種を提示します。

練習問題473
B, C, および図170のグラフに対して find-path をテストせよ。また、演習472のtest-on-all-nodesをこのグラフで使用しなさい。■


練習問題474
find-pathプログラムを1つの関数として再設計しなさい。■


練習問題475
find-path/list を再設計し、明示的な構造的再帰の代わりに図 95 と 96 にある既存のリスト抽象化を使用するようにしなさい。ヒント Racket の ormap のドキュメントを読んでください。ISL+ の ormap 関数とどのように違うのでしょうか？前者はここで役に立ちますか?■

==
データの抽象化に関するメモ：
 find-path 関数は Graph がどのように定義されているかを知る必要がないことに気がついたかもしれません。Graph に正しい neighbors 関数を与えさえすれば、find-path は全く問題なく動作します。要するに、find-path プログラムはデータの抽象化を使っているのです。

「第III部 抽象化」で言ったように、データの抽象化は関数の抽象化と同じように機能します。ここで、abstract-find-pathという関数を作ることができますが、これはfind-pathよりも1つ多くパラメータ neighbors を消費でしょう。abstract-find-pathに常にGraphからグラフGを渡して、それにマッチするneighbors関数を渡しさえすれば、グラフを適切に処理することができます。余分なパラメータは従来の意味での抽象化を示唆していますが、Gとneighborという2つのパラメータの間に必要な関係は、abstract-find-pathがGraphの定義の上でも抽象化されていることを実際に意味しています。後者はデータの定義なので、この考え方はデータ抽象化と呼ばれています。

プログラムが巨大化すると、プログラムの構成要素としてデータ抽象化は重要な手段となります。次巻のHow to Designシリーズではこの考え方を詳しく扱います。次の節では別の例でこのアイデアを説明します メモ終わり
==


練習問題476
"12.8 有限状態機械" では、有限状態機械と文字列に関する問題を出題していますが、解決には生成的再帰が必要なため、この章まで遅らせました。これで、この問題に取り組むために必要な設計知識を習得したことになります。

関数fsm-matchを設計してください。この関数は、有限状態機械のデータ表現と文字列を消費します。文字列中の文字の並びが有限状態機械を初期状態から最終状態に遷移させる場合、#trueを出力します。

この問題は生成的再帰関数の設計に関するものなので、本質的なデータ定義とデータ例を示します。

    (define-struct transition [current key next]) 
    (define-struct fsm [initial transitions final])
     
    ; FSMは構造体である。
    ; (make-fsm FSM-State [List-of 1Transition] FSM-State)

    ; 1Transitionは構造体である。
    ; (make-transition FSM-State 1String FSM-State)

    ; FSM-Stateは構造体である。

    ; データ例：演習問題109参照
     
    (define fsm-a-bc*-d
      (make-fsm
       "AA"
       (list (make-transition "AA" "a" "BC")
             (make-transition "BC" "b" "BC")
             (make-transition "BC" "c" "BC")
             (make-transition "BC" "d" "DD"))
       "DD"))

データ例は正規表現 a (b|c)* d に対応します。練習問題109で述べたように、"acbd", "ad", "abcd" は許容できる文字列の例で、"da", "aa", "d" はマッチしない例です。

この文脈で、次のような関数を設計することになります。

    ; FSM String -> Boolean
    ; an-fsmが与えられた文字列を認識するかどうか
    (define (fsm-match? an-fsm a-string)
      #false)

ヒント fsm-match? 関数に必要な補助関数をlocalで設計してください。この場合、問題は、有限状態機械の現在の状態と、残りの1Stringsのリストという2つのパラメータの組で表現されます。 ■


    ; [List-of X] -> [List-of [List-of X]]
    ; w の項目のすべての並べ替えのリストを作成する。
    (define (arrangements w)
      (cond
        [(empty? w) '(())]
        [else
          (foldr (lambda (item others)
                   (local ((define without-item
                             (arrangements (remove item w)))
                           (define add-item-to-front
                             (map (lambda (a) (cons item a))
                                  without-item)))
                     (append add-item-to-front others)))
            '()
            w)]))


    ; [List-of [List-of 1String]] -> Boolean
    ; "rat", "art", "tar"という単語は与えられたリストに含まれるか？
    (define (all-words-from-rat? w)
      (and (member (explode "rat") w)
           (member (explode "art") w)
           (member (explode "tar") w)))

    (check-satisfied (arrangements '("r" "a" "t"))
                     all-words-from-rat?)

    図171:生成的再帰を用いた(関数) arrangements の定義


練習問題477
図171のarrangementsの関数定義を調べてみてください。この図は、"12.4 問題の核心である「言葉遊び」について"で取り上げられた拡張された設計問題の生成-再帰的解法、すなわち

    単語が与えられたら、可能な限りの文字の並べ替えを作る。

ということを表しています (Mark Engelbergがこの演習を提案してくれたことに感謝します)。

拡張された演習は、主関数と2つの補助関数の構造的な再帰的設計を直接ガイドするものです。後者(補助関数)の設計にはさらに2つのヘルパー関数を作成する必要があります。これに対して、図171では、生成的再帰の力 ? それに加えfoldrとmap ? を使い、同じプログラムを一つの関数定義としています。

arrangements の生成的再帰版の設計を説明しなさい。生成的再帰の設計レシピが提起するすべての質問（終了の質問を含む）に答えてください。

図171のarrangements は、"12.4 問題の核心である「言葉遊び」について"の解答と同じリストを作るでしょうか？■


=====

29.2 プロジェクト: バックトラック

n クイーンパズルはチェスの世界では有名な問題で、また、バックトラックの適用性を自然な形で示します。チェス盤は、n×nの正方形の格子です。クイーンは、他の駒を"飛び越える"ことなく、水平、垂直、斜め方向に任意に動くことができるゲームの駒です。クイーンがあるマスを脅かすもしくは脅威を与えるというのは、そのマスにいるか、そのマスに移動できる場合のことをいいます。図172はこの概念を図式化したものです。クイーンは2列目、6行目にある。クイーンから放射状に伸びる実線は、クイーンに脅かされているすべてのマスを通過します。(Mark Engelbergがこのセクションを再定式化してくれたことに感謝します)


                イメージ

    図172:クイーンが1つ置かれたチェス盤と、クイーンが脅かす位置


古典的なクイーン問題は、8×8のチェス盤上に8個のクイーンを、盤上のクイーンが互いに脅威を与えないように配置することです。コンピュータ科学者はこの問題を一般化し、n×nのチェス盤にn個のクイーンを配置し、クイーンが互いに脅威を与えないようにすることが可能かどうかを問います。

n = 2の場合、このパズルは明らかに解が存在しません。4つのマスのいずれかにクイーンが置かれると、残りのすべてのマスが脅かされます。


               イメージ    イメージ     イメージ

    図173：3×3チェス盤に対する3つのクイーンの配置


また、n=3の解も存在しません。図173は、2つのクイーンの全ての異なる配置、つまり、k = 3とn = 2の解を示したものです。いずれの場合も、左列のマスに左のクイーンが入り、2番目のクイーンは、最初のクイーンが脅威を与えないマスのうちの1つに配置されます。2つ目のクイーンを置くと、残りの空いているマスがすべて脅かされるので、3つ目のクイーンを置くことは不可能です。


練習問題478
(n=3の場合に)また、一番上の列、一番右の列、一番下の列のすべてのマスに最初のクイーンを置くことができます。これらの解答がすべて図173に描かれている3つのシナリオと同じである理由を説明しなさい。

これで中央のマス(に対する考慮)が残りました。3×3のボードの中央のマスに最初のクイーンを置いた後、2つ目のクイーンを置くことは可能でしょうか？■


            イメージ            イメージ

    図174:4x4 と 5x5 のボードにおける n クイーンパズルの解。


図174は、n クイーンパズルの2つの解答を示しています。左はn = 4の場合、右はn = 5の場合です。この図からいずれの場合も、各行と各列にクイーンが1個ずつあることがわかります。クイーンは、そのマスから放射状に広がる行と列全体を脅かすので、これは理にかなっています。

十分に詳細な分析ができたので、次は解決のフェーズに進みます。分析によって、いくつかのアイデアが提案されます：

1. この問題は、クイーンを一度に一個ずつ配置することについての問題である。クイーンをボードに配置するとき、対応する行、列、対角線に、他のクイーンのために使えないという印をつけることができる。

2. 別のクイーンのために、脅かされていないスポットのみを考慮します。

3. 最初に選んだマスが後で問題になったときのために、そのクイーンを置くことが可能な他のマスを覚えておきます。

4. クイーンを置くはずなのに安全なマスが残っていない場合、数個のマスからあるマスを選んだ、プロセスの1つ前の時点までバックトラックして、残ったマスのどれかを試してみます。

つまり、この解法は「経路探索」アルゴリズムと同じようなものです。

プロセスの記述から設計されたアルゴリズムに移行するためには、明らかに2つのデータ表現が必要です：1つはチェス盤、もう1つは盤上のポジションです。後者から始めましょう：

    (define QUEENS 8)
    ; QPは構造体である。
    ;   (make-posn CI CI)
    ; CIは[0,QUEENS) (0以上QUEENS未満) における整数である。
    ; 解釈 (make-posn r c)は r行c列のマスを示します。

結局のところ、チェス盤は基本的に選択肢を決めてしまうのです。

CIの定義には [0, QUEENS) の代わりに [1,QUEENS] を使うこともできますが、この2つの定義は基本的に同等で、0からカウントアップすることはプログラマが行うことです。同様に、チェスのポジションのいわゆる代数的表記法では、盤面の次元の1つに対して 'a から 'h の文字が使われていますが、これはQPがCIやそのような文字を使うことができたということを意味します。ここでも両者はほぼ等価であり、ISL+では文字よりも自然数で多くのポジションを作る方が簡単です。

練習問題479
関数 threatening? を設計してください。これは 2 つの QP を消費し、2 つのそれぞれのマスに置かれたクイーンが互いに脅かし合うかどうかを判断します。

領域知識(1) 図172を調査してみてください。この図のクイーンは、水平方向、垂直方向、そして対角線方向のすべてのマスを脅かしています。逆に、それらの線上の任意のマスに別のクイーンがあると、そのクイーンが脅かされます。

(2) 得られた知見を、正方形の座標を互いに関連付ける数学的条件に置き換えましょう。例えば、水平方向にあるすべてのマスのy座標は同じです。同様に、ある対角線方向にあるすべてのマスは、その和が同じ座標となる。それはどの対角線のことでしょうか？ 別の対角線では、2つの座標の差は同じままです。このアイデアはどの対角線について述べているでしょうか？

ヒント 領域知識がわかったら、水平方向、垂直方向、対角線方向をカバーするテストスイートを作成しましょう。 #false を生成する threatening? の引数をテストに含めるのを忘れないようにしましょう。■


演習480
関数 render-queens を設計してください。この関数は、自然数 n, QP のリスト、および Image を消費します。この関数は、与えられた画像が与えられた 複数の QP に従って配置された n x n のチェス盤の画像を生成します。

チェスのクイーンの画像は、オンラインで探すか、使用可能な画像関数を使って簡単なものを作成するのもよいでしょう。■


チェス盤 Board の データ表現については、アルゴリズムがどのように処理を実装するのか分かるまで、このステップは先送りにします。そのようにすることはデータの抽象化のもう一つの練習になります。実際、Boardのデータ定義はアルゴリズムのシグネチャーを適切に記述するのに必要でさえありません。

    ; N -> [Maybe [List-of QP]].
    ; n クイーン問題に対する解を求める。

    ;データの例: [List-of QP]
    (define 4QUEEN-SOLUTION-2
      (list (make-posn 0 2) (make-posn 1 0)
            (make-posn 2 3) (make-posn 3 1)))

    (define (n-queens n)
      #false)

このパズルは、n×nのチェス盤上のn個のクイーンの配置を見つけるものです。したがってあきらかに、このアルゴリズムは自然数以外には何も消費せず、―解が存在すれば― n個のクイーンの配置を表現することができます。後者はQPのリストで表現することができ、それゆえ

    ; [List-of QP] or #false

を結果とします。当然ながら、#falseは解が見つからなかったことを表します。

次のステップは、例を作り、テストとして定式化することです。n-queensは2か3が与えられると失敗しなければならないことが分かっています。4の場合、実際のボードと4つの同じクイーンを持つ2つの解があります。図174の左の図はそのうちの1つを示したもので、もう1つの解は次のものです：

    イメージ

しかし、データ表現としては、この2つのイメージは多数の異なる方法で表現することが可能です。図175はその一部をスケッチしたものである。残りを埋めてください。

  ; N -> [Maybe [List-of QP]]
  ; n クイーン問題に対する解を求める。

  (define 0-1 (make-posn 0 1))
  (define 1-3 (make-posn 1 3))
  (define 2-0 (make-posn 2 0))
  (define 3-2 (make-posn 3 2))

  (check-member-of
    (n-queens 4)
    (list 0-1 1-3 2-0 3-2)
    (list 0-1 1-3 3-2 2-0)
    (list 0-1 2-0 1-3 3-2)
    (list 0-1 2-0 3-2 1-3)
    (list 0-1 3-2 1-3 2-0)
    (list 0-1 3-2 2-0 1-3)
    ...
    (list 3-2 2-0 1-3 0-1))

  (define (n-queens n)
    (place-queens (board0 n) n))

    図175  4クイーンパズルの解


練習問題481
図175のテストはひどいものです。現実のプログラマーは、これらの可能性のある結果をすべて明示することはありません。

一つの解決策は、再び特性試験を使うことです。自然数nを消費して、与えられた(クイーンの)配置がn個のクイーンパズルの解であるかどうかの真偽値を出力する関数を返す、n-queens-solution? 関数を設計してください．

・n クイーンパズルの解答は、長さがnでなければならない。

・そのようなリストに載っているQPは、他の異なるQPを脅かすことはできない。

この真偽値を返す関数をテストしたら、それとcheck-satisfiedを使って、n-queensのテストを定式化してください。

もう一つの解決策は、QPのリストを集合として理解することです。2つのリストが異なる順序で同じQPを含む場合、図が示すように、それらは等価です。したがって、n-queensのテストは次のように定式化できます：

    ; [List-of QP] -> Boolean
    ;結果が2つのリストのいずれかに[集合として]等しいか？
    (define (is-queens-result? x)
      (or (set=? 4QUEEN-SOLUTION-1 x))
          (set=? 4QUEEN-SOLUTION-2 x))

関数 set=? を設計しなさい。この関数は2つのリストを消費し、順序に関係なく同じ項目が含まれているかどうかを判断します。■


練習問題482
重要なアイデアは、すでにいくつかのクイーンが置かれているかもしれないチェス盤に、n個のクイーンを置く関数を設計することです。

    ; Board N -> [Maybe [List-of QP]]
    ; ボード上にn個のクイーンを置く。それ以外の場合は#falseを返す。
    (define (place-queens a-board n)
      #false)

図175は、n-queensの定義ですでにこの機能を参照しています。

place-queens アルゴリズムを設計しなさい。Board を扱うために以下の関数を知っていると仮定します。

    ; N -> Board
    ; n x n の初期ボードを作成する
    (define (board0 n) ...)

    ;  Board QP -> Board
    ; a-board 上のqpにクイーンを置く。
    (define (add-queen a-board qp)
      a-board)

    ; Board -> [List-of QP]
    ; まだクイーンを置いても大丈夫な場所を探す
    (define (find-open-spots a-board)
      '())

最初の関数は、図175で place-queens のための最初のボード表現を作成するために使用されています。アルゴリズムの生成ステップを記述するために、他の2つが必要です。■


前問の解答がうまくいくかどうかはまだ確認できません。なぜなら、この解答は広範なウィッシュリストに依存しているからです。ウィッシュリストの3つの機能をサポートするBoardsのデータ表現が必要です。これが残された問題です。


練習問題483
Board のデータ定義を作成し、演習 482 で指定された 3 つの関数を設計しなさい。以下のアイデアを検討しなさい。

・Board は、まだクイーンを置くことができる位置を集めています。

・Board には、クイーンが置かれている位置のリストが含まれています。

・Board は n x n 個の正方形からなる格子で、各正方形にはクイーンが置かれている可能性があります。セルを表すのに3つのフィールドをもつ構造体を使います：1つはx、次の1つはy、そして3つ目はそのマスが脅かされているかどうかを表すフィールドです。

上記のいずれかの考え方で、この練習問題を解いてみてください。

課題 3つのアイデアを駆使して、Boardの3つの異なるデータ表現を考えなさい。練習問題 482 の解答を要約し、Board の(あなたの) どのデータ表現でも動作することを確認しなさい。■



=====

30 まとめ

この第5部では、プログラム設計に「エウレカ！」という考え方を導入しています。第1部から第4部までの構造設計とは異なり、「エウレカ！」の設計は、プログラムがどのように問題を解決すべきか、あるいは問題を表すデータを処理すべきかというアイデアから出発します。ここでいう設計とは、与えられた問題に似ているがより単純な新しい種類の問題に対して、再帰関数を呼び出す賢い方法を考え出すことであす。

ここでは生成的再帰と名付けたが、多くのコンピュータ科学者は、これらの関数をアルゴリズムと呼んでいることに留意してください。

この部を読み終えると、生成的再帰の設計について次のことが理解できるようになります。

1. デザインレシピの標準的なアウトラインはそのまま有効です。

2. 大きな変更点は、コーディングのステップに関するものです。生成的再帰のための完全に汎用的なテンプレートから完全な関数に至るまで、4つの新しい問題が導入されました。このうち2つは解答プロセスの「自明な部分」を、残りの2つは生成的な解答ステップを解決するためのものです。

3. 少し変更されたのは、生成的再帰関数の終了動作に関するものです。構造的に設計された関数とは異なり、アルゴリズムはある入力に対して終了しないことがあります。この問題は、アイデアに内在する限界か、アイデアをコードに変換することに起因するかもしれません。いずれにせよ、あなたのプログラムの将来の読者は、潜在的に「良くない」入力についての警告を受けるに値します。

実際のプログラミング作業では、単純なアルゴリズムやよく知られたアルゴリズムに遭遇し、それに対処することが求められます。本当に賢いアルゴリズムについては、ソフトウェア会社は、プログラマにコンセプトをプログラムに変えるよう依頼する前に、高給の専門家、領域の専門家、数学者を雇ってコンセプトの細部を練り上げるのです。このような仕事に対する準備も必要であり、最良の準備は練習することです。



