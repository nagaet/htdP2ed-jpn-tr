
プログラム設計の方法 第2版

プロローグ   プログラムの作り方

＝＝＝
小さい頃、親から数の数え方を教わったと思いますが、1＋1は2, 1＋2は3, ......というように。そして、「3＋2は何ですか」と聞かれたら、あなたは片手の指を数えたことでしょう。彼らはプログラミングして、あなたは計算した。ある意味で、それがプログラミングとコンピューティングのすべてなのです。

  (DrRacketはホームページからダウンロードしてください)

さて、いよいよ役割を交代します。DrRacketを起動します。すると、図3のようなウィンドウが表示されます。メニューから「言語を選択」を選ぶと、「プログラムの設計方法」の「教える言語」のリストが表示されます。この作業が完了すると、プログラミングができるようになり、DrRacketのソフトが子になります。まずは一番簡単な計算から始めましょう。次のように入力します。

    (+ 1 1)

をDrRacketの上部に入れ、RUNをクリックすると、下部に2が表示されます。

    図3：DrRacketの紹介

それくらい、プログラミングは簡単なのです。DrRacketが子供であるかのように、あなたがDRacketに質問をすると、DrRacketは計算を行います。また、一度に複数の処理を依頼することも可能です。

    (+ 2 2)
    (* 3 3)
    (- 4 2)
    (/ 6 2)

RUNをクリックすると、DrRacketの下半分に4 9 2 3と表示されますが、これは予想された結果です。

少しスローダウンして、いくつかの言葉を紹介しましょう。

・DrRacketの上半分を定義エリアと呼びます。このエリアで、プログラムを作成することを編集と呼びます。定義エリアで単語を追加したり、何かを変更すると、すぐに左上にSAVEボタンが表示されます。初めてSAVEをクリックすると、DrRacketはあなたのプログラムを永久に保存できるように、ファイル名の入力を求めてきます。定義域がファイルに関連づけられたら、SAVEをクリックすると、定義域の内容がファイルに安全に保存されます。

・プログラムは式で構成されています。数学で式を見たことがあると思います。今のところ、式は単なる数字か、左括弧 "(" で始まり右括弧 ")" で終わるもののどちらかです。

・RUNをクリックすると、DrRacketは定義エリアにある式を評価し、その結果をインタラクションエリアに表示します。そして、あなたの忠実な召使いであるDrRacketは、プロンプト(>)であなたの命令を待ちます。プロンプトの出現は、DrRacketが追加式の入力を待っていることを示し、DrRacketはその式を定義エリアの式と同様に評価します：

        > (+ 1 1)
        2

    プロンプトに式を入力し、キーボードの"return" または "enter" キーを押して、DrRacketがどのように結果を応答するかを見てください。この操作は何度でもできます。

        > (+ 2 2)
        4

        > (* 3 3)
        9

        > (- 4 2)
        2
        > (/ 6 2)
        3

        > (sqr 3)
        9

        > (expt 2 3)
        8

        > (sin 0)
        0

        > (cos pi)
        #i-1.0

最後の数字をよく見てください。この「#i」という接頭辞は「正確な数値は分からないので、今は「不正確な数値」と解釈してください」という意味のショートです。電卓や他のプログラミングシステムとは違い、DrRacketは正直です。正確な数字がわからないときは、この特別な接頭辞で警告を出します。後ほど「コンピュータの数字に関する奇妙な事実」をお見せしますが、そのときあなたは、DrRacketがこのような警告を発してくれることを心から感謝するでしょう。

DrRacketは一度に2つ以上の数字を足すことができるのだろうかと思われるかもしれません。実は、2つの異なる方法でこれを行うことができます。

    > (+ 2 (+ 3 4))
    9

    > (+ 2 3 4)
    9

一つ目は学校で習ったような入れ子式演算です。後者は、BSL演算です；この表記法では常に括弧を使って演算と数をグループ化するので、当然といえば当然です。

(たとえエディタがDrRacketと呼ばれていても、本書はRacketを教えるものではありません。独自の言語を開発する選択についての詳細は、序文、特にDrRacketと教育言語のセクションを参照してください)

BSLでは、"演算演算" (calculator operation) を使いたいときは毎回、始め括弧、実行したい演算、例えば＋、演算の対象となる数字（スペースまたは改行で区切る）、そして最後に終わり括弧を記述します。演算の後に続くものをオペランドと呼びます。入れ子演算は、オペランドに式を使えるということです。

    > (+ 2 (+ 3 4))
    9

上記は立派なプログラムです。似たような演算を(以下のように)何度でも実行できます。

    > (+ 2 (+ (* 3 3) 4))
    15

    > (+ 2 (+ (* 3 (/ 12 4)) 4))
    15

    > (+ (* 5 5) (+ (* 3 (/ 12 4)) 4))
    38

ネスティングにはあなたの忍耐力以外に制限はありません。

当然ながら、DrRacketが計算を行う際には、あなたが知っている数学のルールを使用します。DrRacketは、オペランドがすべて数字の場合のみ、足し算の結果を求めることができます。オペランドが括弧付きの演算子式 "（" と演算で始まるものである場合は、その括弧付きの演算子式の結果を最初に決定します。あなたとは違って、DrRacketはどの式を先に計算するか考える必要はないのです。

DrRacket の利便性の代償として、括弧には意味があるのです。これらの括弧はすべて入力しなければならず、また、あまり多く入力してはいけません。例えば、数学の先生には余分な括弧は許容されますが、BSLではそうはいきません。(+ (1) (2)) という式は、あまりにも多くの括弧を含んでおり、DrRacketはあなたにはっきりとそのことを知らせます。

    > (+ (1) (2))
    function call:expected a function after the open parenthesis, found a number
    (訳: 関数呼び出し:始め括弧の後に関数を期待したが、数値が見つかった)

しかし、一度、BSLプログラミングに慣れると、それは全く代償ではないことがわかるでしょう。まず、複数のオペランドに対する演算を一度に行うことができるようになります（当然といえば当然ですが）。

    > (+ 1 2 3 4 5 6 7 8 9 0)
    45

    > (* 1 2 3 4 5 6 7 8 9 0)
    0

もし、ある演算が複数のオペランドに対してどのような動作をするのか分からない場合は、インタラクションエリアに例を入力して"return" を押してください。また、HelpDeskを使ってドキュメントを読むこともできます。お気づきかもしれませんが、オンラインテキストの演算名はHelpDeskのドキュメントにリンクされています。次に、他の人が書いたプログラムを読むとき、どの式が先に評価されるのか迷うことはありません。括弧と入れ子ですぐに分かります。

この文脈では、プログラミングとは理解しやすい算数式を書き下すことであり、計算とはその値を決定することです。DrRacketを使えば、このようなプログラミングや計算を簡単に探求することができます。


======
算数と算数

もし、プログラミングが数字や算数だけだったら、数学と同じくらい退屈なものになるでしょう。幸いなことに、プログラミングには数字以外にも、テキスト、真理値、画像、その他多くのものがあります。

(冗談です：数学は魅力的な科目ですが、今のところあまり必要ないでしょう)

まず知っておかなければならないのは、BSLでは、テキストとは二重引用符（"）で囲まれたキーボード文字の連続のことだということです。私たちはそれを文字列と呼びます。したがって、"hello world "は完全に正しい文字列です。DrRacketがこの文字列を評価するとき、それは単に数字のようにインタラクションエリアにエコーバックされるだけです。

    > "hello world"
    "hello world"

実際、多くの人が最初に作るプログラムは、まさにこの文字列を表示するものです。

そうでなければ、DrRacketは数値の算数に加えて文字列の算数も知っている必要があります。そこで、この形式の算数を説明する2つのインタラクションを紹介します。

    > (string-append "hello" "world")
    "helloworld"

    > (string-append "hello " "world")
    "hello world"


"+" と同じように string-append も操作のひとつです。最初のインタラクションが示すように、これは文字どおり、2つの文字列の間に何も付け加えずに行います。したがって、"hello world "というフレーズを見たい場合は、これらの単語のいずれかにスペースを追加する必要があるのです。もちろん、2つの単語からこのフレーズを作る最も自然な方法は、次のように入力することです。

    (string-append "hello" " " "world")

というのも、文字列の追加も + と同様、オペランドの数だけ扱えるからです。

文字列は、追加するだけでなく、もっといろいろなことができます。文字列から断片を取り出したり、逆順にしたり、すべての文字を大文字にしたり（小文字にしたり）、左右の空白を取り除いたり、などなど。そして何より、これらの処理を暗記する必要はありません。もし、文字列で何ができるかを知りたい場合は、HelpDeskでその用語を調べてください。

(F1キーか右のドロップダウンメニューでHelpDeskを開いてください。BSLのマニュアルとその定義済み演算のセクション、特に文字列に関するものを見てください)

BSLのプリミティブ演算を調べた場合、プリミティブ（ときどき事前定義や組み込みと呼ばれることもある）演算は文字列を消費して数値を生成できることがわかるでしょう：

  > (+ (string-length "hello world") 20)
  31

  > (number->string 42)
  "42"


また、文字列を数値に変換する演算もある。

  > (string->number "42")
  42


もし、あなたが "42" (訳注: 銀河ヒッチハイク・ガイドで有名な数) のような賢い計算を期待したのなら、申し訳ありませんがそれはあなたが文字列計算機に求めるものではありません。

しかし、最後の式は問題を提起します。もし誰かが文字列引用符で囲まれた数字でない文字列をstring->number で指定したらどうでしょうか？その場合、この演算は別の種類の結果を生成します。

  > (string->number "hello world")
  #false


これは数値でも文字列でもなく、ブール値です。数値や文字列とは異なり、ブール値には2種類しかありません。#trueとfalseです。前者は真実で、後者は偽りです。しかし、DrRacketにはブール値を組み合わせるためのいくつかの演算が用意されています。

  > (and #true #true)
  #true

  > (and #true #false)
  #false

  > (or #true #false)
  #true

  > (or #false #false)
  #false

  > (not #false)
  #true


演算を実行すると、演算の名前が示すような結果が得られます。(and,or,notは何を計算するのかご存知ですか？簡単です。(and x y) は x と y が真なら真、(or x y)は x か y のどちらか、または両方が真なら真、(not x) は x が #false のとき正確に #true になります)。

また、2つの数値をブール値に変換するのにも便利です。

    > (> 10 9)
    #true

    > (< -1 0)
    #true

    > (= 42 9)
    #false


ここでいったん立ち止まってください。(>= 10 10), (<= -1 0), (string=? "design" "tinker") の3つの式を試してみてください。この最後の1つはまた違いますが、心配しないでください。あなたならできます。

新しい種類のデータ（数値、文字列、ブール値もデータです）や演算が飛び交っていると、入れ子演算のような基本的なことを忘れがちになります。

  (and (or (= (string-length "hello world")
              (string->number "11"))
           (string=? "hello world" "good morning"))
       (>= (+ (string-length "hello world") 60) 80))


この式の結果はどうなるのでしょうか？どうやって計算したのですか？自分で考えたのですか？それとも、DrRacketのインタラクションエリアに入力してリターンキーを押しただけですか？もし後者なら、自分でどうやればいいかわかると思いますか？結局のところ、小さな表現に対してDrRacketが何をするか予測できないなら、それより大きなタスクを評価のために提出するときにDrRacketを信用したくないと思うかもしれませんね。

"現実の"プログラミングをどう行うかということを説明する前に、スパイスを加えるためにある種のデータを議論しましょう。それは画像データです。画像データをインタラクションエリアに挿入し、
リターンキーを押すと次のようにレスポンスが返ります：

(訳注: もとの教材だとロケットのイラストの画像を挿入しているのですがテキストファイルだとそれは無理なので以下を先に実行してください。
  (define ROCKET-IMAGE (overlay
                        (circle   2  "solid" "green")
                        (circle   4  "solid" "white")
                        (ellipse  20 38 "solid" "blue")
                        (isosceles-triangle 40 30 "solid" "blue")
                        ))
)

  > ROCKET-IMAGE

  (ロケットのような画像をDrRacketに挿入するには、Insertメニューを使用します。このロケットのような画像をDrRacketに挿入するには、Insertメニューを使用するか、ブラウザから画像をコピーしてDrRacketに貼り付けてください。このような画像をDrRacketに挿入するには、Insertメニューを使用します)

DrRacketは画像で返信します。他の多くのプログラミング言語とは対照的に、数値や文字列の演算をサポートするのと同じように、BSLは画像を理解し、画像の演算をサポートします。要するに、あなたのプログラムは画像を使って計算することができ、インタラクションエリアでそれを行うことができるのです。さらに、BSLプログラマーは ―他のプログラミング言語のプログラマーと同じように― 他の人が役に立つと思うようなライブラリを作成します。このようなライブラリを使うことは、ちょうど新しい単語で語彙を増やし、新しいプリミティブでプログラミングの語彙を増やすようなものです。私たちは、このようなライブラリーをティーチパック(teachpacks)と呼んでいます。

  (定義エリアに（require 2htdp/image）を追加するか、言語メニューからティーチパックの追加を選び、Preinstalled HtDP/2e Teachpackメニューからimageを選択します)

重要なライブラリの1つである2htdp/imageライブラリは、画像の幅と高さを計算するための演算をサポートしています。

   (* (image-width ROCKET-IMAGE) (image-height ROCKET-IMAGE))

プログラムにライブラリを追加した後、「RUN」をクリックすると、28ピクセル×42ピクセルの画像の面積である1176が表示されます。

Googleで画像を検索し、InsertメニューでDrRacketプログラムに挿入する必要はありません。DrRacketに指示して、簡単な画像をいちから作成することも可能です。

    > (circle 10 "solid" "red")
    (訳注: 円の画像が表示されます)

    > (矩形 30 20 "輪郭" "青")
    (訳注: 青い線の長方形の画像が表示されます)


式の結果が画像の場合、DrRacketはそれをインタラクションエリアに描画します。しかし、それ以外の場合、BSLプログラムは画像を数値と同じようにデータとして扱います。特に、BSLは、数値の加算や文字列の追加と同じように、イメージを結合するための演算を持っています。

  > (overlay (circle 5 "solid" "red")
           (rectangle 20 20 "solid" "blue"))
  (訳注: 青い正方形に赤い丸がある画像が表示されます)


これらの画像を逆の順番で重ね合わせると、青い無地の正方形になります。

  > (overlay (rectangle 20 20 "solid" "blue")
             (circle 5 "solid" "red"))
  (訳注: 青い正方形の画像が表示されます)


この結果について、少し立ち止まって考えてみてください。

見ての通り、overlay は + よりも string-append に似ていますが、string-append が文字列を追加し、 + が数字を追加するように、画像を "追加" するものです。もうひとつ、アイデアを説明する図を示します。

  > (image-width (square 10 "solid" "red"))
  10

  > (image-width
      (overlay (rectangle 20 20 "solid" "blue")
               (circle 5 "solid" "red")))
  20


DrRacketとのインタラクションは、何も描画せず、ただ幅を測定しているだけです。

さらに、empty-sceneとplace-imageという2つの演算が重要です。1つ目の演算は、特殊な矩形であるシーンを作成します。もうひとつは、そのシーンに画像を配置する演算である。

  (place-image (circle 5 "solid" "green")
               50 80
               (empty-scene 100 100))

とすると、次のようになります。

(実際に出力された画像にはグリッドがありません。そこで、何もないシーンにグリッドを重ね合わせ、緑のドットがどこに配置されているかを確認できるようにしました)

    (訳注: 升目が細かく描かれた正方形に、緑色の点が表示された画像 が表示されます)


この画像からわかるように、原点（または(0,0)）は左上隅にあります。数学とは異なり、y座標は上向きではなく下向きに測られます。そうでなければ、この画像はあなたが期待するものを示しています。100 x 100 の空の長方形の座標 (50,80) に、緑色の固い円盤があります。

もう一度まとめてみましょう。プログラミングとは算数式を書くことですが、もはや退屈な数字に限定されるものではありません。BSLでは、算数は、数、文字列、ブール値、そして画像データの算数でもあります。しかし、計算するということは ―その値が文字列、数字、ブール値、画像であることを除けば― 式の値を決定するということです。

これでロケットを飛ばせるプログラムを書く準備ができました。


======
入力と出力

あなたがこれまで書いてきたプログラムは、とても退屈なものでした。ある式を書いて、RUNをクリックすると、結果が表示されます。もう一度RUNをクリックすると、全く同じ結果が表示されます。実は、何度でもRUNをクリックすれば、同じ結果が表示されるのです。つまり、DrRacket が数字だけでなくあらゆる種類のデータを使って計算することを除けば、プログラムはまさにポケット電卓で計算するようなものなのです。

これは良いニュースでもあり、悪いニュースでもあります。良いというのは、プログラミングと計算は電卓を使うことの自然な一般化であるべきだからです。しかし、プログラミングの目的はたくさんのデータを扱い、多かれ少なかれ同じような計算でたくさんの異なる結果を得ることだから、悪いニュースです。つまり、プログラミングができるようになるには、まだまだ勉強しなければならないのです。心配はいりません：数字や文字列、ブール値、画像などの演算に関する知識があれば、"hello world"をどこかに表示するプログラムだけではなく、動画を作るプログラムを書くことができるようになります。そこで、次はそれをやってみようというわけです。

念のため言っておくと、動画とは一連の画像を順番に高速で表示したものである。もし、代数の先生が前のセクションで見た"イメージの算数"について知っていたら、代数学で退屈な数列の代わりに動画を作ることができたかもしれません。さて、ここでもう一つそのような表を紹介しましょう。

  x =  1  2  3  4  5  6  7  8  9  10
  y =  1  4  9 16 25 36 49 64 81   ?

先生から「空欄を埋めなさい」、つまり「"?"マークを数字に置き換えなさい」と言われたことがあるでしょう。

動画作りは、このような数字の表を完成させることほど複雑なことはないのだ。実際、そのような表がすべてです。

  x =     1                          2                     3                     4
  y =  (訳注 黒い線の正方形  (訳注 黒い線の正方形  (訳注 黒い線の正方形)        不明
        の中央より少し上に    の中央のところに      の中央より少し上に
        赤い点がある画像      赤い点がある画像)     赤い点がある画像)

具体的に言うと、ここで先生が「4枚目、5枚目、1273枚目の画像を描いてください」とあなたに求めるのは、動画というのは1秒間に20枚とか30枚とかとにかくたくさんの画像からなるためです。だから、1分間の動画を作るには1200枚から1800枚くらいの画像が必要になります。

また、先生は、ある数列の4番目や5番目の数だけでなく、与えられたxから数列の任意の要素を求める式も求めていたことをあなたは思い出すかもしれません。

    y = x・x

xに1, 2, 3, ...と入れると、yは1, 4, 9, ...と表通りになる。画像の列については、次のように言うことができます。

    y = 上から x^2 ピクセル下のドットを含む画像。

このワンライナーは、単なる式ではなく、関数であることがポイントです。

一見すると、関数は式のようなもので、常に左側にy、その後に記号の'='、そして式が続きます。しかし、これらは式ではありません。また、学校でよく目にする関数の表記は、まったくもって誤解を招きやすいものです。そのため、DrRacketでは少し変わった関数の書き方をします。

    (define (y x) (* x x))

defineの定義(https://docs.racket-lang.org/htdp-langs/beginner.html#%28form._%28%28lib._lang%2Fhtdp-beginner..rkt%29._define%29%29 )では、「y を関数と見なす」、つまり式と同じように値を計算するとあります。しかし、関数の値は入力と呼ばれるものの値に依存し、それを(y x)と表現します。この入力が何であるかは分からないので、入力を表すために名前を使います。数学の伝統に従って、ここでは未知の入力を表すためにxを使っているが、やがてあらゆる種類の名前を使うことになるでしょう。

この2番目の部分は、yの特定の値を決定するために、xに1つの数値を与えなければならないことを意味します。このとき、DrRacketはxの値を関数に関連付けられた式に差し込みます。ここでは、式は(* x x)です。xが値、例えば1に置き換えられると、DrRacketは関数の出力とも呼ばれる式の結果を計算することができます。

(DrRacketで)RUN(ボタン)をクリックし、何も起こらないのを見ましょう。インタラクションエリアには何も表示されません。DrRacketの他の部分には何も変化がないようです。まるで何も成し遂げていないかのようです。しかし、あなたはなにかを実行したのです。あなたは実際に関数を定義し、その存在をDrRacketに知らせたのです。実際、DrRacketはその関数を使用する準備ができています。入力

    (y 1)

をインタラクションエリアのプロンプトに入力し、それに対して1が表示されるのを見ましょう。

(数学ではy(1)を関数適用と呼びますが、先生は教えてくれませんでしたね)

試しに

    (y 2)

と入力して、4が出てくるのをみましょう。もちろん、これらの式をすべて定義エリアに入力して、「RUN」をクリックすることもできます。

    (define (y x) (* x x))

    (y 1)
    (y 2)
    (y 3)
    (y 4)
    (y 5)

これに対し、DrRacketはこう表示します。1 4 9 16 25 と表示され、これが上の表の数字です。ここで、欠落している項目を調べます。

つまり、関数は一つの式でたくさんの面白い値を計算することができる経済的な方法なのです。実際、プログラムは関数です。そして、関数をよく理解すれば、プログラミングのほとんどすべてを知ることができます。その重要性に鑑み、関数についてこれまでに分かっていることをまとめてみましょう。

・最初に

    (define (FunctionName InputName) BodyExpression)

  は関数定義です。キーワード "define" で始まるので、そのように認識されます。この関数は基本的に3つの部分から構成されています：2つの名前と式です。最初の名前は関数の名前で、関数を何度も適用するために必要です。2つ目の名前（パラメータと呼ばれる）は関数の入力を表し、関数を実行するまでわかりません。ボディと呼ばれる式は、特定の入力に対する関数の出力を計算します。

・2番目に、

    (FunctionName ArgumentExpression)

  は関数適用です。最初の部分は、どの関数を使いたいかをDrRacketに伝えます。2番目の部分は、その関数を適用したい入力です。WindowsやMacのマニュアルを読んでいると、この式はFunctionNameというアプリケーションを表示し、ArgumentExpressionを入力として処理すると書いてあることがあります。すべての式がそうであるように、後者は単純なデータであったり、深くネストされた式である可能性があります。

関数は数字以外のものも入力できますし、あらゆる種類のデータを出力することができます。次の課題は、最初の関数が数値テーブルをシミュレートしたように、2番目のテーブル（色のついた点の画像を含むテーブル）をシミュレートする関数を作ることです。式から画像を作るというのはあなたは高校生のときから知っているものではないので、簡単に始めましょう。empty-scene 関数は覚えていますか？前章の最後にさっと触れましたが、この関数が使えるようになるには、次のような手順が必要です。それをインタラクションエリアに入力すると、このようになります。

    > (empty-scene 100 60)

    (訳注 横が100, 縦が60の長方形の白い画像 が表示されます)

DrRacketは空の長方形を生成し、これをシーン(scene)とも呼びます。シーンに画像を追加するには、place-image 関数を使用します。


(訳注: もとの教材だとロケットのイラストの画像を挿入しているのですがテキストファイルだとそれは無理なのでここでも以下を先に実行してください。
  (define ROCKET-IMAGE (overlay
                        (circle   2  "solid" "green")
                        (circle   4  "solid" "white")
                        (ellipse  20 38 "solid" "blue")
                        (isosceles-triangle 40 30 "solid" "blue")
                        ))
)
    > (place-image ROCKET-IMAGE 50 23 (empty-scene 100 60))

    (訳注 白い長方形にロケットの画像が置かれた画像が表示されます)

ロケットは、(数学の授業で習った)上の表における点のような物体だと考えてください。違うのは、ロケットは興味深いということです。

次に、上の表の点のように、ロケットが下降していくようにします。前節で、place-image に与える y 座標を大きくすることで、この効果を得ることができることがわかりました。

    > (place-image ROCKET-IMAGE 50 20 (empty-scene 100 60))

    (訳注: ロケットが上の方にあるイメージが表示されます)

    > (place-image ROCKET-IMAGE 50 30 (empty-scene 100 60))

    (訳注: ロケットが中間のところにあるイメージが表示されます)

    > (place-image ROCKET-IMAGE 50 40 (empty-scene 100 60))

    (訳注: ロケットが下の方にあるイメージが表示されます)

あとは、このようなシーンを簡単にたくさん作り、それらを順番に、高速で表示することができればいいのです。


  (define (picture-of-rocket height)
    (place-image ROCKET-IMAGE 50 height (empty-scene 100 60)))

    図4 ロケットを着陸させる（バージョン1）



最初の目標はもちろん、関数を使って達成することができます(図4 をみてください)。そうです、これは関数の定義です。x の代わりにpicture-of-rocketという名前を使っていますが、これはこの関数が何を出力するか、つまりロケットのあるシーンを出力することが一目でわかる名前です。この名前は、パラメータが数字であることと、パラメータがロケットの位置を示していることを示唆しています。この関数の本体の式は、数値の代わりにheightを使っていることを除けば、先ほど実験した一連の式と全く同じです。そして、これらのイメージはすべてこの関数ひとつで簡単に作ることができるのです (メモ. BSLでは、g-hやg.hを含むあらゆる種類の文字を名前に使用することができます)。

  (picture-of-rocket 0)
  (picture-of-rocket 10)
  (picture-of-rocket 20)
  (picture-of-rocket 30)

定義エリアとインタラクションエリアで試してみると、どちらも期待通りのシーンが表示されます。

2番目の目標は、別のティーチパックのプリミティブ演算に関する知識が必要です。それは 2htdp/universeライブラリの animate です ((require 2htdp/universe) を定義エリアに追加するか、言語メニューからティーチパックを追加するを選んでプリインストールされた HtDP/2eティーチパックメニューから universeを選んでください)。RUNをクリックし、次の式を入力します。

  > (animate picture-of-rocket)

ここで立ち止まってください。そして引数の式が関数であることに注意してください。関数を引数として使うことを今のところは心配しないでください。(しかし)animateではうまくいきますが、まだ自分のところでanimateのような関数を定義しようとしないでください。

return キーを押すとすぐに、DrRacketは式を評価しますが、結果は表示されず、プロンプトさえも表示されません。DrRacketは別のウィンドウ（キャンバス）を開き、1秒間に28回鳴るクロックを開始します。時計が動くたびに、DrRacketはこの関数呼び出しから経過した刻みの数にpicture-of-rocketを適用します。これらの関数呼び出しの結果はキャンバスに表示され、アニメーションムービーのような効果を生み出します。シミュレーションは、あなたがウィンドウを閉じるまで実行されます。その時点で animate は経過したティック数を返します。

問題は、ウィンドウに表示される画像がどこから来るかです。簡単に説明すると、アニメイトはオペランドを0,1,2...といった数字の上で動かし、その結果の画像を表示する、というものです(練習問題298は animateを設計する方法を説明します)。長い説明は以下のとおりです:

  ・animateはクロックをスタートさせ、ティックの数をカウントします。

  ・クロックは1秒間に28回ティックします。

  ・クロックがティックするたびに、animate は関数 picture-of-rocket を現在のクロックのティックに適用します。

  ・アプリケーションが作成したシーンがキャンバス上に表示されます。

つまり、ロケットはまず高さ0に現れ、次に1、2...という高さに現れます。つまりキャンバスの上から下へ降りてくるという説明になっています。つまり、われわれが定義した3行のプログラムでは、約3.5秒間に100枚ほどの画像を作り、それを高速に表示することで、ロケットが地上に降りてくるような効果を出しているのです。

では、このセクションで学んだことを紹介します。関数は、たくさんのデータを短時間で処理することができるので便利です。いくつかの選択した入力に対して手で関数を起動し、適切な出力を生成することを確認することができます。これを関数のテストと呼びます。あるいは、DrRacketはいくつかのティーチパックの助けを借りて、多くの入力に対して関数を起動することができます。もちろん、キーボードのキーを押したときや、コンピュータのマウスを操作したときにも、DrRacketは関数を起動することができます。その方法については、このまま読み進めてください。関数アプリケーションのトリガーが何であるかは重要ではありませんが、（単純な）プログラムは関数であるということは覚えておいてください。


======
いろいろな計算方法

(animate picture-of-rocket) を評価すると、ロケットはやがて(キャンバスの)下の方に消えていきます (Venkat Pamulapatiが指摘するように、この文が書かれた後、SpaceXは多くのロケットを垂直に着陸させています)。そんなことは馬鹿げたことです。というのは昔のSF映画では、ロケットは地面に沈むのではなく、底に優雅に着地し、そこで映画は終わるはずです。

この考え方は、状況に応じて計算を変えるべきであるということを促します。この例では、picture-of-rocket プログラムはロケットが飛行している間は「そのまま」に動くはずです。しかし、ロケットの底がキャンバスの底に触れると、ロケットはそれ以上下降しないようにしなければなりません。

ある意味で、この考え方はあなたにとって新しいものではないでしょう。数学の先生も、様々な状況を区別するために関数を定義しています。

               1 (x>0のとき)
    sign(x) =  0 (x=0のとき)
              -1 (x<0のとき)

このsign関数は、0より大きい数、0に等しい数、0より小さい数の3種類で入力を区別し、入力に応じて関数の結果を+1, 0, -1のいずれかにします。

DrRacketでは、条件式を使って、この関数を簡単に定義することができます。

    (define (sign x)
      (cond
        [(> x 0) 1]
        [(= x 0) 0]
        [(< x 0) -1]))

(DrRacketで)RUN ボタンをクリックした後は、他の関数と同じようにsignとインタラクトすることができます(なおここではDrRacketの新しいタブを開き、まっさらな状態から始めましょう):

    > (sign 10)
    1

    > (sign -5)
    -1

    > (sign 0)
    0

    (これは、STEPボタンが何をするのかを探るのに良い機会です。定義エリアに (sign -5) を追加し、上記のsignプログラムのため STEPボタンをクリックします。新しいウィンドウが表示されたら、そこで右と左の矢印をクリックします。

一般に、条件式は次のような形をしています。

    (cond
      [<条件式1> <結果式1>]
      [<条件式2> <結果式2>]
      ...
      [<条件式N> <結果式N>])

つまり、条件式は必要なだけの条件行から構成される。各行には2つの式が含まれます。左の式をcondition、右の式をresultと呼ぶことが多く、たまにquestionやanswerも使います。Cond式を評価するために、DrRacketは最初の条件式であるConditionExpression1を評価します。これが#trueとなった場合、DrRacketはcond式をResultExpression1に置き換えて評価し、その値をcond式全体の結果として使用します。ConditionExpression1 の評価が#falseとなった場合、DrRacketは最初の行を削除してやり直します。すべてのcond式が#falseと評価された場合、DrRacketはエラーを通知します。

  (define (picture-of-rocket.v2 height)
    (cond
      [(<= height 60)
       (place-image ROCKET-IMAGE 50 height
                    (empty-scene 100 60))]
    [(> height 60)
     (place-image ROCKET-IMAGE 50 60
                  (empty-scene 100 60))]))

    図5 ロケットを着陸させる（バージョン2）


この知識をもとに、今度はシミュレーションのコースを変更することができます。目標は、ロケットが100×60 (ピクセル)のシーンで、地面の高さより下に降下しないようにすることです。picture-of-rocket 関数はロケットを置く高さを引き数として消費するので、与えられた高さと最大の高さを比較する単純なテストで十分なようです。

修正された関数定義については図5を参照してください。この定義では、2つのバージョンを区別するために picture-of-rocket.v2 という名前を用いている。区別できる名前を使うことで、インタラクション・エリアで両方の関数を使い、その結果を比較できます。以下は、(地面の高さを考慮しない)オリジナル版の動作です。

    > (picture-of-rocket 5555)
    <ロケットが表示されていないイメージ>

そして、こちらが修正版を使ったときの動作です:
    > (picture-of-rocket.v2 5555)
    <ロケットの上半分が表示されたイメージ>

picture-of-rocket.v2にどのような数値を与えても、60以上であれば同じシーンが表示されます。特に

    > (animate picture-of-rocket.v2)

を実行すると、ロケットは下降し、地面に半分ほど沈んでから停止します。

ここで立ち止まってください。私たちは何を見たかったんでしょうか？

ロケットがここまで降下していると、不格好です。そしてまた、あなたはプログラムのこの点を修正する方法を知っています。いままで見たように、BSL は画像の演算を知っています。画像をシーンに追加するとき、画像には実際の高さと幅があるにもかかわらず、その中心点を画像全体であるかのように使用します。イメージの高さは、image-height という操作で測定することができます。この機能は、ロケットの底が地面につくまでロケットを飛ばしたいという場合に便利です。

これらを合わせると、次の式は、ロケットの降下を停止させたい点であるということがわかるでしょう:

    (- 60 (/ (image-height ROCKET-IMAGE) 2))

これはプログラムを直接いじってもわかるし、インタラクションエリアで画像演算で実験してもいいです。

ここでは、最初の試みを紹介します。

    (place-image ROCKET-IMAGE 50 (- 60 (image-height ROCKET-IMAGE))
                 (empty-scene 100 60))

ここで、上記のアプリケーションの第3引数を次のように置き換えてください。

    (- 60 (/ (image-height ROCKET-IMAGE) 2))

ここでストップしてください! 実験をしてみましょう。あなたはどちらの結果が好きですか？

(define (picture-of-rocket.v3 height)
  (cond
    [(<= height (- 60 (/ (image-height ROCKET-IMAGE) 2)))
     (place-image ROCKET-IMAGE 50 height
                  (empty-scene 100 60))]
    [(> height (- 60 (/ (image-height ROCKET-IMAGE) 2)))
     (place-image ROCKET-IMAGE 50 (- 60 (/ (image-height ) 2))
                  (empty-scene 100 60))]))

    図6 ロケットを着陸させる（バージョン3）


このように考えて実験していくと、最終的に図6のようなプログラムに行き着きます。ロケットの高さを表す数が与えられると、まずロケットの底が地面から浮いているかどうかを調べます。もしそうであれば、先ほどと同じようにロケットをシーンに配置します。そうでない場合は、ロケットの底が地面につくように画像を配置します。


=====
1つのプログラム、たくさんの定義

ここで、あなたの友人がアニメーションを見たが、あなたのキャンバスの大きさが気に入らないとします。その場合、200×400のシーンを使ったバージョンを要求するかもしれません。この単純な要求のために、あなたはプログラム中の5箇所で100を400に、他の2箇所で60を200に置き換えなければなりません。

ここで立ち止まってください。この先、5行のプログラムに対してこの要求を実行することがいかに困難であるかを理解するために、その要求を試してみてください。世の中のプログラムは、5万行、50万行、あるいは500万行以上のプログラムコードで構成されていることを念頭に置きながら読み進めてください。

理想的なプログラムでは、キャンバスのサイズを変更するような小さなリクエストは、同じように小さな変更で済むはずです。BSLでこのシンプルさを実現するツールはdefineです。関数の定義に加えて、定数の定義も導入することができます。これは、定数に何らかの名前を割り当てるものです。定数定義の一般的な形は、簡単です。

    (define Name Expression)

したがって、例えば、次のように書き出すとします：

    (define HEIGHT 60)

これは「HEIGHTは常に60という数を表す」ということを意味していますね。このような定義の意味は、あなたが期待するものです。DrRacketは計算中にHEIGHTに遭遇すると、代わりに60を使用します。

  (define (picture-of-rocket.v4 h)
    (cond
      [(<= h (- HEIGHT (/ (image-height ROCKET) 2)))
       (place-image ROCKET 50 h (empty-scene WIDTH HEIGHT))]
      [(> h (- HEIGHT (/ (image-height ROCKET) 2)))
       (place-image ROCKET
                    50 (- HEIGHT (/ (image-height ROCKET) 2))
                    (empty-scene WIDTH HEIGHT))]))

  (define WIDTH 100)
  (define HEIGHT 60)
  (define ROCKET ROCKET-IMAGE)

    図7：ロケットの着地（バージョン4）

図7のコードを見てみましょう。これは、上記の簡単な変更を実装し、ロケットの画像に名前を付けます。DrRacketにこのプログラムをコピーして、RUNをクリックしましょう。その後、次のようなインタラクションを評価してみてください。

    > (animate picture-of-rocket.v4)

プログラムが以前と同じように機能することを確認してください。

図7のプログラムは、1つの関数の定義と3つの定数の定義、つまり合計4つの定義で構成されてます。100と60という数字は、WIDTHの値として1回、HEIGHTの値として1回、つまり計2回だけ出現します。また、picture-of-rocket.v4の関数のパラメータとして、heightの代わりにhが使われていることにお気づきかもしれません。厳密に言うと、DrRacket は height と HEIGHT を混同することはないのでこの変更は必要ないのですが、あなたの混乱を避けるためにこのようにしました。

DrRacket が (animate picture-of-rocket.v4) を評価するとき、これらの名前に出会うたびに HEIGHT を 60 に、WIDTH を 100 に、ROCKET を画像に置き換えます。本物のプログラマーの楽しさを味わうために、HEIGHTの隣の60を400に変えて、RUNをクリックしてみてください。100×400のシーンに、ロケットが降下して着地するのが見えますね。たった一つの小さな変更で、すべてがうまくいったのです。

現代の言葉で言えば、あなたは今、初めてプログラムのリファクタリングを体験したところです。将来起こりうる変更要求に備えてプログラムを整理するたびに、あなたはプログラムをリファクタリングしているのです。それを履歴書に書きます。たとえそれがあなたを優秀なプログラマーにするものでなかったとしても、それは良い響きであり、あなたの将来の雇用主はおそらくそのような流行語を読むのを楽しむでしょう。しかし、優秀なプログラマーが決して我慢できないのは、プログラムに同じ表現が3回含まれることです。

    (- HEIGHT (/ (image-height ROCKET) 2))

あなたの友人や同僚がこのプログラムを読むたびに、この式が何を計算しているのか、つまりキャンバスの一番上と、キャンバスの一番下に止まっているロケットの中心点との間の距離を理解する必要があるのです。DrRacketが式の値を計算するたびに、3つのステップを実行する必要があります。(1) 画像の高さを決める、(2) それを2で割る、(3) その結果をHEIGHTから差し引く。そして、毎回、同じ数値が算出される。

この観察から、もう一つの定義が必要になります：

    (define ROCKET-CENTER-TO-TOP)
      (- HEIGHT (/ (image-height ROCKET) 2)))


では、プログラムの残りの部分で ROCKET-CENTER-TO-TOP を (- HEIGHT (/ (image-height ROCKET) 2)) という表現に置き換えてみてください。この定義は HEIGHT の定義の上に置くべきか下に置くべきか迷うかもしれません。もっと一般的に言えば、定義の順序は重要なのかどうかということです。その答は、定数の定義の場合は順序が関係しますが、関数の定義の場合は関係しないということです。DrRacketは定数の定義に遭遇するとすぐに、式の値を決定し、その値に名前を関連付けます。例えば、

    (define HEIGHT (* 2 CENTER))
    (define CENTER 100)

は、DrRacketがHEIGHTの定義に遭遇したとき、DrRacketは "CENTERがその定義より前に使用されていること”を(エラーとして)訴えます。これに対して

    (define CENTER 100)
    (define HEIGHT (* 2 CENTER))

は期待通りに動作します。まず、DrRacketはCENTERを100と関連付けます。次に、(* 2 CENTER)を評価し、200を生成します。最後に、DrRacketは200をHEIGHTと関連付けます。

定数の定義では順番が関係しますが、関数の定義に対して定数定義をどこに配置するかは重要ではありません。実際、プログラムが多くの関数定義で構成されている場合、その順番は関係しません。しかし、すべての定数の定義を最初に紹介し、その後に重要度が低くなる順に関数の定義を紹介するのは良いことです。この順番がなぜ重要なのかは、実際に複数の定義を持つプログラムを書いてみるとわかります。

  ; constants
  (define WIDTH  100)
  (define HEIGHT  60)
  (define MTSCN  (empty-scene WIDTH HEIGHT)) ; empty-scene はempty scene (空のシーン)を表します
  (define ROCKET ROCKET-IMAGE)
  (define ROCKET-CENTER-TO-TOP
    (- HEIGHT (/ (image-height ROCKET) 2)))

  ; functions
  (define (picture-of-rocket.v5 h)
    (cond
      [(<= h ROCKET-CENTER-TO-TOP)
       (place-image ROCKET 50 h MTSCN)]
      [(> h ROCKET-CENTER-TO-TOP)
       (place-image ROCKET 50 ROCKET-CENTER-TO-TOP MTSCN)]))

    図8：ロケットの着地（バージョン5）

(このプログラムには、セミコロン(”;")で始まる2行のコメントも含まれています。DrRacketはこのようなコメントを無視しますが、コメントは人間の読者のためにあるものなので、プログラムを読む人は無視してはいけません。これは、プログラムの作者とその将来の読者すべてとの間の、プログラムに関する情報を伝達するための「バックチャネル」なのです)


繰り返される式をすべて削除すると、図8のようなプログラムになります。これは、1つの関数定義と5つの定数定義で構成されています。これらの定数定義は、ロケットの中心の配置だけでなく、画像そのものや、空のシーンの作成も要素となります。

この先を読む前に、次のようなプログラムの変更について考えてみてください。

  ・200×400のシーンを作るには、プログラムをどのように変更すればよいでしょうか？

  ・緑色のUFO（未確認飛行物体）の着陸を描くように、プログラムを変更するにはどうしたらよいでしょうか。UFOを描くのは簡単です。たとえば以下のようにします：

    (overlay (circle 10 "solid" "green")
             (rectangle 40 4 "solid" "green"))

  ・背景が常にブルーになるようにプログラムを変更するにはどうしたらよいでしょうか。

  ・ロケットが底面より10ピクセル高い平らな岩盤に着地するように、プログラムを変更するにはどうしたらよいでしょうか？風景を変えるのも忘れないでください。

考えるよりやってみる。それが学ぶための唯一の方法です。だから、私たちに邪魔されないでください。ただやってみましょう。

マジックナンバー: picture-of-rocket.v5 をもう1度見てみましょう。繰り返される式をすべて削除したため、この関数定義からは1つの数字を除いてすべてが消えています。プログラミングの世界では、このような数字をマジックナンバーと呼びますが、誰もこれを好みません。その数がどのような役割を果たし、どのような変更が正当なものであるかをいつの間にか忘れてしまうのです。このような数値は定義の中で名前を付けておくのが一番です。

ここで、50は ロケットのX座標に選択した値であることは、実際に私たちは知っています。50はたいした式には見えないが、これも繰り返しの式である。関数の定義から50を削除する理由は2つありますがそれはあなたに任せます。


=====
もう1つの定義

animate 関数は、最初に呼ばれてから経過したクロック・ティックの数を関数に適用していることを思い出してください。つまり、picture-of-rocket の引数は高さではなく、時間です。これまでの picture-of-rocket の定義では、引数に間違った名前を使用していました。h ― height (高さ) の省略形 ― の代わりに時間の省略形 t を使うべきです。

("Danger ahead!" : このセクションでは、物理学の知識を1つ紹介します。あなたが物理学を怖がる場合、最初に読むときにはその物理の知識をスキップしてください。この節のプログラミングに物理の知識は(本来)必要ないのです)

  (define (picture-of-rocket t)
    (cond
      [(<= t ROCKET-CENTER-TO-TOP)
       (place-image ROCKET 50 t MTSCN)]
      [(> t ROCKET-CENTER-TO-TOP)
       (place-image ROCKET
                    50 ROCKET-CENTER-TO-TOP
                    MTSCN)]))

そして、この定義の小さな変更によって、このプログラムは時間を距離であるかのように使っていることがすぐに明らかになりました。なんという悪いアイデアでしょう。

物理の授業を受けたことがない人でも、時間は距離ではないことは知っているはずです。だから、私たちのプログラムは偶然に正しく動いてしまったのです。しかし心配しないでください。少しのロケット工学の知識 ―それを私たちのような人々は物理学とよびます― があればいいのです。

物理学？！？ ええ、あなたはそのコースで学んだことをおそらくすでに忘れてしまっていることでしょう。あるいは、あなたはあまりにも若すぎるか穏やかな人なので、物理の講義を受けたことがないのかもしれません。心配はいりません。音楽、経済、写真、看護、その他あらゆる分野の問題で人々を助ける必要があるため、最高のプログラマーにも常にこのようなことが起こります。もちろん、プログラマーだってすべてを知っているわけではありません。だから、必要なことは調べる必要があります。あるいは、適切な人たちに話をします。物理学者と話をすれば、移動距離は時間に比例することがわかるでしょう。

    d = v・t

つまり、物体の速度をvとすると、t秒間にdマイル（またはメートル、ピクセルなど何でも）進むことになります。

もちろん、先生は適切な関数の定義を見せてくれるはずです。

    d(t) = v・t

なぜなら、これによって、d の計算が t に依存し、v が定数であることが誰にでもすぐにわかるからです。プログラマーはさらに進んで、これらの一文字の略語に意味のある名前をつけます。

    (define V 3)

    (define (distance t)
      (* V t))

このプログラム断片は2つの定義から構成されます：一定の速度で移動する物体の移動距離を計算する関数 distance と、その速度を表す定数 V の2つです。

なぜここで V が 3 なのかと思われるかもしれません。特別な理由はありません。私たちは1 クロック・ティック あたり3ピクセルがちょうど良い速度だと考えています。あなたはそうではないかもしれません。この数値を試してみて、アニメーションがどうなるか見てみてください。

  ; ”world" のプロパティと降下するロケット
  (define WIDTH  100)
  (define HEIGHT  60)
  (define V 3)
  (define X 50)

  ; グラフィックに関する定数
  (define MTSCN  (empty-scene WIDTH HEIGHT)) ; 空のシーンの短縮形
  (define ROCKET )
  (define ROCKET-CENTER-TO-TOP
  (- HEIGHT (/ (image-height ROCKET) 2)))

  ; 関数
  (define (picture-of-rocket.v6 t)
    (cond
      [(<= (distance t) ROCKET-CENTER-TO-TOP)
       (place-image ROCKET X (distance t) MTSCN)]
      [(> (distance t) ROCKET-CENTER-TO-TOP)
       (place-image ROCKET X ROCKET-CENTER-TO-TOP MTSCN)]))

  (define (distance t)
    (* V t))

    図9 ロケットを着陸させる（バージョン6）


これでまた、picture-of-rocketを修正することができます。この関数では、t と高さを比較する代わりに、(distance t) を使ってロケットがどのくらい下にいるかを計算することができます。最終的なプログラムは、図9のようになります。これは、picture-of-rocket.v6 と distance の2つの関数定義で構成されている。残りの定数定義は、関数定義を読みやすく、変更しやすくするものです。いつものように、このプログラムは animate 関数で実行することができます。

  > (animate picture-of-rocket.v6)

前のバージョンのpicture-of-rocketと比較して、このバージョンは、プログラムがお互いを参照するいくつかの関数定義で構成されている可能性があることを示します。そしてまた、最初のバージョンでさえも、+と/を使用していました。それは、あなたがそれらをBSLに組み込まれていると考えるだけです。

本格的なプログラマーになると、プログラムは多くの関数定義と多くの定数定義で構成されていることに気づくでしょう。また、関数同士が常に参照しあっていることもわかるでしょう。このような関数を完成後何ヶ月経っても簡単に読めるように整理しておくことがプログラマに必要なことなのです。何しろ、古いバージョンのあなた ―もしくは他の誰か― が、これらのプログラムに変更を加えたいと思うでしょうから； そのときプログラムの構成を理解できなければ、小さな変更作業でさえも困難になってしまいます。そうでなくても、あなたは知るべきことをほとんど知っています。


=====
あなたは今、プログラマーです

あなたがプログラマーであるという主張は、前のセクションの終わりで、あなたにとって驚きだったかもしれませんが、それは真実です。あなたはBSLについて知っておくべきすべての仕組みを知っています。プログラミングは数値、文字列、画像、そしてあなたが選んだプログラミング言語がサポートするその他のデータの演算を使うことを知っています。プログラムが関数と定数の定義で構成されていることも知っています。最終的には、これらの定義を適切に整理することが重要であることをあなたに伝えました。最後になりますが、次のことは重要です：DrRacketとティーチパックは多くの関数をサポートしており、DrRacketのHelpDeskはこれらの関数が何を行うかを説明しています。

キーストロークやマウスクリックなどに反応するプログラムを書くには、まだ十分な知識がないと思うかもしれません。しかし、実はそうでもないことがわかります。2htdp/universe ライブラリには、animate 関数以外にも、キーボードやマウス、時計など、コンピュータの可動部にプログラムを接続するための関数が用意されています。また、2htdp/universeライブラリは、あなたのコンピュータと世界中の他のコンピュータを接続するプログラムもサポートしています。だから、これは実際には問題ではないのです。

要するに、プログラムを組み立てる仕組みはほとんどすべて見たことになります。利用可能なすべての関数をあなたが読めば、面白いコンピュータゲームを作ったり、シミュレーションをしたり、ビジネスの勘定科目を管理するようなプログラムを書くことができるようになります。問題は、これで本当にプログラマーになったかどうかだ。あなたはプログラマーですか？














































ストップ!まだページをめくってはいけません。考えてみてください！





















































=====
ノー、違います！

書店で「プログラミング」の本棚を見ると、その場でプログラマになれるという本がたくさん並んでいます。しかし、最初の例題をいくつかこなした今、あなたはおそらく、そんなことはありえないということに気づいているはずです。

コンピュータが理解できる式を書く、どの関数やライブラリが使えるか、といったプログラミングの機械的なスキルを身につけることは、実際のプログラミングにはあまり役に立ちません。もしそうなら、辞書に載っている1000の単語と、文法書に載っているいくつかの規則を覚えれば、外国語を習得できるのと同じことです。

優れたプログラミングとは、(人が話す)言語を習得するための仕組みを超えたものです。最も重要なことは、プログラマは将来他の人に読んでもらうためにプログラムを作るのだということを心に留めておくことです。良いプログラムには、問題の声明とその重要な概念が反映されています。また、簡潔な自己説明がついています。例はこの叙述を説明し、問題に関連付けます。例は、将来の読者があなたのコードがなぜ、どのように動作するかを知っていることを確実にします。つまり、優れたプログラミングとは、問題を体系的に解決し、コードの中でその体系を伝えることなのです。そして何より、このようなアプローチによって、プログラミングは誰にとっても身近なものになります ― つまりそれは一度に二人の主人に仕えるようなものです。

本書の内容は、DrRacketやBSL、ライブラリの仕組みについてはほとんど触れていません。この本では、優れたプログラマがどのように問題を考えているかを紹介しています。そして、この問題解決の方法が医者、ジャーナリスト、弁護士、エンジニアの仕事のような、人生の他の場面にも応用できることを、あなたは学ぶことができるのです。

ええ、ちなみにこの本の他の部分は、このプロローグよりも真面目な文章にふさわしい口調が使われています。お楽しみに。

本書で扱わないことについてのメモ: プログラミングの入門書には、その著者の好きな応用分野であるパズル、数学、物理、音楽などについての記述が多くなりがちです。しかし、これはプログラミングの本質を見失うことになります。そこで、他の分野の知識を極力排除し、コンピュータサイエンスが教えてくれる計算問題解決に集中できるようにしました。




